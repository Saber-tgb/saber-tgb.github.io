(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{276:function(e,l,v){"use strict";v.r(l);var _=v(0),t=Object(_.a)({},function(){var e=this,l=e.$createElement,v=e._self._c||l;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"flex-布局基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-布局基础知识","aria-hidden":"true"}},[e._v("#")]),e._v(" flex 布局基础知识")]),e._v(" "),v("p",[v("img",{attrs:{src:"http://ojvil4eq9.bkt.clouddn.com/17-9-12/53121912.jpg",alt:"flex"}})]),e._v(" "),v("ul",[v("li",[e._v("main axis(主轴): Flex 容器的主轴主要用来配置 Flex 项目。它不一定是水平，这主要取决于 flex-direction 属性")]),e._v(" "),v("li",[e._v("main-start|main-end(主轴起点|主轴终点): Flex 项目的配置从容器的主轴起点开始,往主轴终点结束")]),e._v(" "),v("li",[e._v("main size(主轴方向长度):Flex 项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex 项目的主轴长度属性是 width 或 height 属性，由哪一个对着主轴方向决定。")]),e._v(" "),v("li",[e._v("cross axis(侧轴):与主轴垂直的轴称作侧轴，是侧轴方向的延伸。")]),e._v(" "),v("li",[e._v("cross-start | cross-end(侧轴起点|侧轴终点):伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。")]),e._v(" "),v("li",[e._v("cross size(侧轴方向长度):Flex 项目的在侧轴方向的宽度或高度就是项目的侧轴长度，Flex 项目的侧轴长度属性是 width 或 height 属性，由哪一个对着侧轴方向决定。")])]),e._v(" "),v("h2",{attrs:{id:"flex-容器属性-主容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-容器属性-主容器","aria-hidden":"true"}},[e._v("#")]),e._v(" Flex 容器属性(主容器)")]),e._v(" "),v("ol",[v("li",[v("p",[v("code",[e._v("display")]),e._v(": 定义一个 Flex 容器，根据其取的值来决定是内联还是块。Flex 容器会为其内容建立新的伸缩格式化上下文。(定义成 flex 容器不等于定义成块级容器)")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flex-direction")]),e._v(": 定义主轴方向，Flex 项目在 Flex 容器中放置的方向")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("row")]),e._v("(默认值): Flex 项目从左向右排列")]),e._v(" "),v("li",[v("code",[e._v("row-reverse")]),e._v(": 与 row 相反，Flex 项目从右向左排列")]),e._v(" "),v("li",[v("code",[e._v("column")]),e._v(": Flex 项目从上向下排列")]),e._v(" "),v("li",[v("code",[e._v("columne-reverse")]),e._v(": 与 column 相反，Flex 项目从下向上排列")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flex-wrap")]),e._v(": 定义 Flex 项目是否多行显示")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("nowrap")]),e._v("(默认值): 单行显示，从左向右排列")]),e._v(" "),v("li",[v("code",[e._v("wrap")]),e._v(": 多行显示，从左向右排列")]),e._v(" "),v("li",[v("code",[e._v("wrap-reverse")]),e._v(": 多行显示，从右向左排列")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flex-flow")]),e._v(": "),v("code",[e._v("flex-direction")]),e._v("和"),v("code",[e._v("flex-wrap")]),e._v("属性的缩写 默认值是 row nowrap")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("justify-content")]),e._v(": 定义主轴方向的对齐方式")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("flex-start")]),e._v("(默认值): Flex 项目主轴起点对齐，伸缩项目向一行的起始位置靠齐。该行的第一个伸缩项目在主轴起点边的外边距与该行在主轴起点的边对齐，同时所有后续的伸缩项目与其前一个项目对齐")]),e._v(" "),v("li",[v("code",[e._v("flex-end")]),e._v(": Flex 项目主轴终点对齐，伸缩项目向一行的结束位置靠齐。该行的最后一个伸缩项目在主轴终点边的外边距与该行在主轴终点的边对齐，同时所有前面的伸缩项目与其后一个项目对齐。")]),e._v(" "),v("li",[v("code",[e._v("center")]),e._v(": Flex 项目主轴居中对齐，伸缩项目向一行的中间位置靠齐。该行的伸缩项目将相互对齐并在行中居中对齐，同时第一个项目与该行在主轴起点的边的距离等同与最后一个项目与该行在主轴终点的边的距离（如果剩余空间是负数，则保持两端溢出的长度相等）。著作权归作者所有。")]),e._v(" "),v("li",[v("code",[e._v("space-between")]),e._v(": Flex 项目主轴两端对齐，伸缩项目会平均地分布在行里。如果剩余空间是负数，或该行只有一个伸缩项目，则此值等效于 flex-start。在其它情况下，第一个项目在主轴起点边的外边距会与该行在主轴起点的边对齐，同时最后一个项目在主轴终点边的外边距与该行在主轴终点的边对齐，而剩下的伸缩项目在确保两两之间的空白空间相等下平均分布。")]),e._v(" "),v("li",[v("code",[e._v("space-around")]),e._v(": Flex 项目主轴平均分布对齐，伸缩项目会平均地分布在行里，两端保留一半的空间。如果剩余空间是负数，或该行只有一个伸缩项目，则该值等效于 center。在其它情况下，伸缩项目在确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半下平均分布。")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("align-items")]),e._v(": 定义侧轴方向的对其方式")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("flex-start")]),e._v(": flex 项目侧轴起点对齐，伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边")]),e._v(" "),v("li",[v("code",[e._v("flex-end")]),e._v(": flex 项目侧轴终点对齐,伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。")]),e._v(" "),v("li",[v("code",[e._v("center")]),e._v(": flex 项目侧轴居中对齐，伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。")]),e._v(" "),v("li",[v("code",[e._v("baseline")]),e._v(": flex 项目侧轴基线对齐，如果伸缩项目的行内轴与侧轴为同一条，则该值和 flex-start 等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。")]),e._v(" "),v("li",[v("code",[e._v("stretch")]),e._v(": 如果侧轴长度属性的值为 auto，则此值会使项目的外边距盒的尺寸在遵照 min/max-width/height 属性的限制下尽可能接近所在行的尺寸。")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("align-content")]),e._v(": 定义 Flex 项目多行的对齐方式，本属性在只有一行的伸缩容器上没有效果")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("flex-start")]),e._v(": 各行向伸缩容器的起点位置堆叠。伸缩容器中第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点的边，之后的每一行都紧靠住前面一行。")]),e._v(" "),v("li",[v("code",[e._v("flex-end")]),e._v(":各行向伸缩容器的结束位置堆叠。伸缩容器中最后一行在侧轴终点的边会紧靠住该伸缩容器在侧轴终点的边，之前的每一行都紧靠住后面一行。")]),e._v(" "),v("li",[v("code",[e._v("center")]),e._v(":各行向伸缩容器的中间位置堆叠。各行两两紧靠住同时在伸缩容器中居中对齐，保持伸缩容器在侧轴起点边的内容边和第一行之间的距离与该容器在侧轴终点边的内容边与第最后一行之间的距离相等。（如果剩下的空间是负数，则行的堆叠会向两个方向溢出的相等距离。）")]),e._v(" "),v("li",[v("code",[e._v("space-between")]),e._v(":各行在伸缩容器中平均分布。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于 flex-start。在其它情况下，第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点边的内容边，最后一行在侧轴终点的边会紧靠住伸缩容器在侧轴终点的内容边，剩余的行在保持两两之间的空间相等的状况下排列。")]),e._v(" "),v("li",[v("code",[e._v("space-around")]),e._v(":各行在伸缩容器中平均分布，在两边各有一半的空间。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于 center。在其它情况下，各行会在保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半的状况下排列。")]),e._v(" "),v("li",[v("code",[e._v("stretch")]),e._v("(默认值):各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于 flex-start。在其它情况下，剩余空间被所有行平分，扩大各行的侧轴尺寸。")])])])]),e._v(" "),v("h2",{attrs:{id:"flex-项目属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flex-项目属性","aria-hidden":"true"}},[e._v("#")]),e._v(" Flex 项目属性")]),e._v(" "),v("ol",[v("li",[v("p",[v("code",[e._v("order")]),e._v(":默认值是 0，Flex 项目是按文档源的流顺序排列,根据 order 重新排序伸缩项目。有最小（负值最大）order 的伸缩项目排在第一个。若有多个项目有相同的 order 值，这些项目照文件顺序排。这个步骤影响了伸缩项目生盒树成的盒子的顺序，也影响了后面的演算法如何处理各项目。著作权归作者所有。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flex-grow")]),e._v(": 定义一个 Flex 项目的扩大比例。它接受一个没有单位的值作为一个比例。它可以使用 Flex 项目完全占用 Flex 容器可用的空间。如果所有 Flex 项目的 flex-grow 设置为 1 时，表示 Flex 容器中的 Flex 项目具有相等的尺寸。如果你给其中一个 Flex 项目设置 flex-grow 的值为 2，那么这个 Flex 项目的尺寸将是其他 Flex 项目两倍（其他 Flex 项目的 flex-grow 值为 1）。flex-grow 取负值将失效。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flec-shrink")]),e._v(": 可以定义 Flex 项目的缩小比例,flex-shrink 取负值将失效。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flex-basis")]),e._v(": 定义主轴方向的长度(width|height)。定义了 Flex 项目在分配 Flex 容器剩余空间之前的一个默认尺寸。main-size 值使它具有匹配的宽度或高度，不过都需要取决于 flex-direction 的值。如果设置为 0，内容不在考虑周围额外空间。如果设置为 auto，额外空间会基于 flex-grow 值做分布。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("flex")]),e._v(": 是 flex-grow，flex-shrink 和 flex-basis 三个属性的缩写。第二个和第三个参数(flex-shrink 和 flex-basis)是可选值。其默认值是 0 1 auto。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("align-self")]),e._v(": 用来在单独的伸缩项目上覆写默认的对齐方式。（对于匿名伸缩项目，align-self 的值永远与其关联的伸缩容器的 align-items 的值相同)。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("flex-start")]),e._v(": 伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。")]),e._v(" "),v("li",[v("code",[e._v("flex-end")]),e._v(": 伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。")]),e._v(" "),v("li",[v("code",[e._v("center")]),e._v(": 伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。")]),e._v(" "),v("li",[v("code",[e._v("baseline")]),e._v(":如果伸缩项目的行内轴与侧轴为同一条，则该值和 flex-start 等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。")]),e._v(" "),v("li",[v("code",[e._v("stretch")]),e._v(":如果侧轴长度属性的值为 auto，则此值会使项目的外边距盒的尺寸在遵照 min/max-width/height 属性的限制下尽可能接近所在行的尺寸。")])])])]),e._v(" "),v("div",{staticClass:"language-css line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-css"}},[v("code",[v("span",{pre:!0,attrs:{class:"token selector"}},[e._v(".item")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token property"}},[e._v("align-self")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" auto | flex-start | flex-end | center | baseline | stretch"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br")])])])},[],!1,null,null,null);l.default=t.exports}}]);