<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5基础标签的掌握]]></title>
    <url>%2F2017%2F07%2F20%2FHTML5%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE%E7%9A%84%E6%8E%8C%E6%8F%A1%2F</url>
    <content type="text"><![CDATA[标签 &lt;abbr&gt; 标签表示简称或缩写，比如 “WWW” 或 “NATO” &lt;abbr&gt; 标签中使用全局的 title 属性，这样就能够在鼠标指针移动到 元素上时显示出简称/缩写的完整版本。1The &lt;abbr title=&quot;People&apos;s Republic of China&quot;&gt;PRC&lt;/abbr&gt; was founded in 1949.]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6一]]></title>
    <url>%2F2017%2F07%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B8%80%2F</url>
    <content type="text"><![CDATA[let声明 Es6中引入块级声明，let声明的变量作用域限制在代码块中； let声明不会被提升; 在同一作用域中不能用let重复定义已经存在的标识符，会抛出错误。 const声明 const声明的变量作用域也会限制在代码块中； const声明的是常量，其值一旦被设定后不可更改，每个通过const声明的常量必须进行初始化(赋值) const声明不允许修改绑定，但允许修改值；例如const声明对象，对象的值是可以修改的 临时死区的存在 临时死区(temporal dead zone)TDZ用来描述let和const的不提升效果； 与var声明不同，let和const声明的变量不会被提升到作用域的顶部，在javascript引擎扫描代码的时候会将let和const的声明放到临时死区中 循环中的块级作用域 常见的循环错误；var声明是全局变量 123456789var funcs = [];for(var i=0;i&lt;10;i++) &#123; funcs.push(function() &#123; console.log(i); &#125;)&#125;funcs.forEach(funcion(func) &#123; func(); //输出10次10 &#125;) 使用闭包解决这个问题 12345678910111213var funcs = [];for(var i=0;i&lt;10;i++) &#123; funcs.push((function(value)&#123; // 变量i的值在传递到这个作用域是被赋值给了value; // 此时这个值就不会随外部变量而变化了； return function() &#123; console.log(value); &#125; &#125;)(i));&#125;funcs.forEach(function(func) &#123; func(); //输出0，然后是1,2直到9&#125;) 使用let声明简化 123456789var funcs=[];for(let i=0;i&lt;10;i++) &#123; funcs.push(function() &#123; console.log(i); &#125;)&#125;funcs.forEach(function(func) &#123; func(); //输出0，然后是1,2直到9&#125;) 全局作用域的绑定 当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象(浏览器环境中的window对象)的属性 当在全局作用域中使用let和const,会在全局作用域下创建一个新的绑定，但是该绑定不会添加为全局对象的属性。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>块级作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码分析]]></title>
    <url>%2F2017%2F07%2F18%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1xx（临时响应）1表示临时响应并需要请求者继续执行操作的状态码 100（继续）: 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议）: 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）1表示成功处理了请求的状态码 200（成功）: 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。 201（已创建）: 请求成功并且服务器创建了新的资源。 202（已接受）: 服务器已接受请求，但尚未处理。 203（非授权信息）: 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）: 服务器成功处理了请求，但没有返回任何内容。 205（重置内容）: 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容）: 服务器成功处理了部分 GET 请求。 3xx （重定向）1要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 300（多种选择）: 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 301（永久移动）: 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置 302（临时移动）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引 303（查看其他位置）: 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改）: 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305（使用代理）: 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）1这些状态码表示请求可能出错，妨碍了服务器的处理 400（错误请求）: 服务器不理解请求的语法。 401（未授权）: 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）: 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问 404（未找到）：服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用）：禁用请求中指定的方法。 406（不接受）: 无法使用请求的内容特性响应请求的网页。 407（需要代理授权）: 此状态码与 401（未授权）类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时）: 服务器等候请求时发生超时。 409（冲突）: 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除）: 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度）: 服务器不接受不含有效内容长度标头字段的请求 412（未满足前提条件）: 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）: 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力 414（请求的 URI 过长）: 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）: 请求的格式不受请求页面的支持。 416（请求范围不符合要求）: 如果页面无法提供请求的范围，则服务器会返回此状态码 417（未满足期望值）: 服务器未满足”期望”请求标头字段的要求 5xx（服务器错误）1这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误）: 服务器遇到错误，无法完成请求。 501（尚未实施）: 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）: 服务器作为网关或代理，从上游服务器收到无效响应 503（服务不可用）: 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态 504（网关超时）: 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505（HTTP 版本不受支持）: 服务器不支持请求中所用的 HTTP 协议版本]]></content>
      <categories>
        <category>http</category>
        <category>状态码</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2017%2F07%2F18%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存的定义 Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。 缓存的命中和未命中 304 的标准解释： Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 HTTP在验证]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['HTTP协议的学习四']]></title>
    <url>%2F2017%2F07%2F17%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[web服务器的主要功能 建立连接 接受请求–从网络中读取一条HTTP请求报文 处理请求–对请求报文进行解释，并采取行动 构建响应–创建带有正确首部的HTTP响应报文 发送响应–将响应回送给客服端 记录事务处理过程–将于已完成事务有关的内容记录在一个日志文件中。 代理 web代理服务器是网络的中间实体，代理位于客服端和服务器之间，扮演‘中间人’的角色，在各端点之间来回传送HTTP报文。]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>服务器</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['HTTP协议的学习三']]></title>
    <url>%2F2017%2F07%2F17%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[工作中遇到的问题——对象的拷贝]]></title>
    <url>%2F2017%2F07%2F13%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[遇到的问题： 将对象赋值给一个变量时，当我改变变量的值，发现原来的对象也跟着改变。发现原因： 因为对象是应用类型，存放在堆内存中；当我们用变量保存一个对象时，实际上保存的是该对象指针，这个指针指向对象的位置，所以当我们改变变量的时候，会从指针找到对象的位置，从而改变了对象。解决方法：将对象拷贝再赋值给变量 浅拷贝 简单的引用复制 1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true ES6新方法Object.assign()1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 深度拷贝 Array的slice和concat方法 1234567 var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 123456789 var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice JSON对象的parse和stringify 123456789101112131415161718 //例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; 完整的拷贝方法12345678910111213141516171819202122232425262728293031323334353637var $ = (function()&#123; var types = &apos;Array Object String Date RegExp Function Boolean Number Null Undefined&apos;.split(&apos; &apos;); function type() &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125; for (var i = types.length; i--;) &#123; $[&apos;is&apos; + types[i]] = (function (self) &#123; return function (elem) &#123; return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return $;&#125;)();//类型判断 function copy(obj,deep)&#123; if(obj === null || (!$.isObject(obj) &amp;&amp; !$.isFunction(obj)))&#123; return obj; &#125; if($.isFunction(obj))&#123; return new Function(&quot;return &quot; + obj.toString())(); &#125;else&#123; var name, target = $.isArray(obj) ? [] : &#123;&#125;, value; for(name in obj)&#123; value = obj[name]; if(value === obj) &#123; continue; &#125; if(deep &amp;&amp; ($.isArray(value) || $.isObject(value)))&#123; target[name] = copy(value,deep); &#125;else&#123; target[name] = value; &#125; &#125; return target; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome开发工具指南]]></title>
    <url>%2F2017%2F07%2F12%2FChrome%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[谷歌浏览器开发工具综述 使用开发工具 选择浏览器位于浏览器窗口右上方的菜单栏的工具目录chrome-menu，选择开发者工具选项 右击页面任何位置并选择审查元素 使用快捷键f12 开发者工具窗口 开发者工具窗口的顶部工具栏中排列着任务相关的组。每个工具栏项目和相应的面板让你能够使用网页或应用程序的特定信息来工作，包括 DOM 元素，资源，和源。 总体而言，有八个主要的工具可供查看开发工具 元素面板(Element) 控制台面板(Console) 源代码面板(sources) 网络面板(Network) 性能面板(Performance) 内存面板(Memory) 应用面板(Application)(Audits) 安全面板(Security) 可以使用 Ctrl + [ 和 Ctrl + ] 快捷键在面板之间移动 元素面板(Element)详解 检查和调整页面 实时编辑 DOM 节点：只需双击选定元素，然后进行更改 实时编辑样式： 在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。 要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。 默认情况下，您的 CSS 修改不是永久的，重新加载页面时更改会丢失。 如果您想要在页面加载时保留更改，请设置永久制作 检查和编辑框模型参数： 使用 Computed 窗格检查和编辑当前元素的框模型参数。 框模型中的所有值均可修改，只需点击它们即可 编辑样式 检查应用到元素的样式 顶端为 element.style。这些样式要么直接使用样式属性（例如 ）直接应用到元素，要么在 DevTools 中应用 下方是与元素匹配的任何 CSS 规则。例如，在下面的屏幕截图中，选定元素从 tools.css 中定义的规则接收 line-height:24px 再下方是继承的样式，其中包括与选定元素的祖先实体匹配的任何可继承样式规则。 例如，在下面的屏幕截图中，选定元素从 user agent stylesheet 继承 display:list-item 编辑DOM]]></content>
      <categories>
        <category>chrome</category>
        <category>chrome开发工具</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>chrome开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的学习二]]></title>
    <url>%2F2017%2F07%2F12%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[URL和资源 URL的基本组成部分 URL的第一部分(http)是URL方案,方案可以告知Web客服端怎样访问资源 URL的第二部分指的是主机(服务器的位置)，这不分告知Web客服端资源位于何处。 URL的第三部分是资源路径，路径说明了请求的是服务器上那个特定的本地资源。 通用URL组件 URL由两种方式：绝对的和相对的 相对URL是不完整的，需要对基础的URL进行解析 相对URL解析为绝对URL的算法 HTTP报文详解 报文的流动性 报文在客服端，服务器和代理之间的流动称为报文流 HTTP使用术语流入(inbound)和流出(outbound)来描述事务处理(transaction)的方向 不管是请求报文还是响应报文，所有的报文都会想下游流动。所有的报文发送者都在接受者的上游 报文的组成部分 报文主要有三个部分组成；①对报文进行描述的起始行，②包含属性的首部块，③包含数据的主体部分。 报文的格式 请求报文格式： 123&lt;method&gt;(方法) &lt;request-URL&gt;(请求URL) &lt;version&gt;(版本)&lt;headers&gt;(首部)&lt;entity-body&gt;(主体部分) 响应报文格式： 123&lt;method&gt;(方法) &lt;status-code&gt;(状态码) &lt;reason-phrase&gt;(原因短语)&lt;headers&gt;(首部)&lt;entity-body&gt;(主体部分) 报文各部分的简要描述 方法(method):客服端希望服务器对资源执行的动作.比如GET,HEAD或者POST 请求URL(request-URL):命名了所请求的资源，或者URL路径组件的完整URL 版本(version):报文所使用的HTTP版本，其格式看起来是这样的HTTP/&lt;major&gt;.&lt;minor&gt;其中主要版本号(major)和次要版本号(minor)都是整数。 状态码(status-code):这三位数字描述了请求过程中所发生的情况。 原因短语(reason-phrase):数字转台码的可读版本，包含终止序列之前的所有文本。 首部(header):可以有零个或者多个首部，每个首部都包含一个名字，后面跟着一个冒号(:),然后是一个可选的空格，接着是一个值，最后是一个CRLF。例如：content-type:text/plain; 主体部分(entity-body):实体的主体部分包含一个有任意数据组成的数据块，并不是所有的报文都包含主体部分。 HTTP常见的请求方法 状态码的基本分类 首部 通用首部：提供报文最基本的信息，客服端和服务器都可以使用 通用的信息性首部 通用缓存首部 请求首部：只在请求报文中有意义，用于说明是谁或什么在发送请求，请求源自何处，或者客服端的喜好及能力。 响应首部 实体首部 扩展首部 状态码详解 400-499客服端错误代码]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的学习一]]></title>
    <url>%2F2017%2F07%2F11%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[初识HTTP协议 HTTP协议是一种数据传输协议，客服端通过HTTP请求向服务器获取资源，服务器通过HTTP响应提供资源给客服端。 媒体类型(MIME类型) HTTP给每种要通过 Web 传输的对象都打上了名为 MIME 类型（MIME type）的数据格式标签 MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔 HTML 格式的文本文档由 text/html 类型来标记 JPEG 版本的图片为 image/jpeg 类型 URI 每个 Web 服务器资源都有一个名字，服务器资源名被称为统一资源标识符，URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源 URI和URL的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。 URI 有两种形式，分别称为 URL 和 URN URL URL：统一资源定位符（URL）是资源标识符最常见的形式。URL 描述了一台特定服务器上某资源的特定位置。 大部分 URL 都遵循一种标准格式，这种格式包含三个部分 URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（http://）。 第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com）。 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif） URN URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。 报文 从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文（response message）。 HTTP 报文包括以下三个部分 起始行 报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况 首部字段 起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单 主体 空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本 事务 一个HTTP事务由一条(从客服端发往服务器的)请求命令来和一个(从服务器发回客服端的)响应结果组成。 方法 HTTP支持几种不同的请求命令，这些命令被称为HTTP方法,这写方法回告诉服务器要执行什么动作。一般有五种常见的HTTP方法。 GET：从服务器向客服端发送命名资源 PUT: 将来自客服端的数据存储到一个命名的服务器的资源中去 DELETE：从服务器中删除命名资源 POST：将客服端数据发送到个服务器网关应用程序 HEAD：仅发送命名资源响应中的HTTP首部 状态码 每条 HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作。 链接 HTTP 网络协议栈 12345HTTP 应用层TCP 传输层IP 网络层网络特有的链路接口 数据链路层物理网络硬件 物理层 在 HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。 (a)浏览器从 URL 中解析出服务器的主机名； (b)浏览器将服务器的主机名转换成服务器的 IP 地址； (c)浏览器将端口号（如果有的话）从 URL 中解析出来； (d)浏览器建立一条与 Web 服务器的 TCP 连接； (e)浏览器向服务器发送一条 HTTP 请求报文； (f)服务器向浏览器回送一条 HTTP 响应报文； (g)关闭连接，浏览器显示文档。 Web的结构组件 代理: 位于客户端和服务器之间的 HTTP 中间实体。 代理位于客户端和服务器之间，接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。 缓存: HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。 Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了 网关: 连接其他应用程序的特殊 Web 服务器。 网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。 隧道: 对 HTTP 通信报文进行盲转发的特殊代理 隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。 Agent 代理: 发起自动 HTTP 请求的半智能 Web 客户端。 用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>URI</tag>
        <tag>URL</tag>
        <tag>报文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm的快速使用]]></title>
    <url>%2F2017%2F07%2F06%2Fnpm%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本命令 npm初始化一个包 npm init创建一个新包 需要填写信息 npm init -y快速初始化 安装安装包 常规: npm install pkg, 速记: npm i pkg. 全局安装包: 常规: npm i --global pkg, 速记: npm i -g pkg. 安装包并包含在依赖中: 常规: npm i --save pkg, 速记: npm i -S pkg. 安装包并包含在开发依赖中: 常规: npm i --save-dev pkg, 速记: npm i -D pkg. 有意义的指令 进入安装包的官网 npm repo vue npm home vue 运行测试指令 npm test, 速记：npm t 枚举可用的脚本 当我们开始一个新项目，我们想知道如何开始。我们通常会问自己这样的问题：我们如何运行它？哪些脚本可用 打开package.json文件并检查scripts部分 我们只要运行npm run得到一个的所有可用的脚本的列表 枚举已经安装的包 当查看项目中的哪些依赖项，可以打开package.json文件和检查 枚举项目安装包 使用 npm ls --depth 0 枚举全局安装包 使用 npm ls -g --depth 0 npm更新 npm i -g npm]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel的使用总结]]></title>
    <url>%2F2017%2F07%2F01%2FBabel%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[babel-polfill插件 由于Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码，所以在IE浏览器下会出现缺少Promise对象的问题 为了完整使用 ES6 的 API ，我们只能安装这个插件npm install -save-dev babel-polyfills node.js 中require(&#39;babel-polyfill&#39;) webpack.config.js中 123module.exports = &#123; entry: [&apos;babel-polyfill&apos;, &apos;./app/js&apos;]&#125; vue-cli配置的环境下,在main.js中引入：import &#39;babel-polyfill&#39; 本地安装和全局安装全局安装：npm install --global babel-cli 这时候我们可以使用 Babel 命令编译文件： 123babel index.js --out-file compiled.js#或babel index.js -o compiled.js 编译目录： 123babel src -out-dir lib#或babel src -d lib 本地安装，记在项目的根目录下： npm install --save-dev babel-cli 但是在本地就不能用 babel 命令了，我们可以在 package.json 文件中添加点东西： 12345&#123; &quot;script&quot;: &#123; &quot;build&quot;: &quot;babel src -d lib&quot; &#125;&#125; 然后，运行 npm run build 即可把 src 目录编译输出到 lib]]></content>
      <categories>
        <category>Babel</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Babel</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习三]]></title>
    <url>%2F2017%2F06%2F27%2FVue-js%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[钩子函数的理解 文档翻译造成的问题，原名是“hook”（不负责任的直译为“钩子”而已），它是一种事件劫持机制，也就是说它会比你的事件更早进行执行处理。 可以简单地把它理解为vue的内置事件，但是这个内置事件是由你去配置的。 vue的生命周期详解vue生命周期图示 生命周期总共分为八个阶段 beforeCreate（组件实例创建前） el和data并未初始化 实例创建前：这个阶段实例的data、methods是读不到的 created（组件实例创建后）, 完成了 data 数据的初始化，el没有 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染 beforeMount(模板编译/挂载之前), 完成了 el 和 data 初始化 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted（模板编译/挂载之后） 完成挂载 el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染 beforeUpdate（组件更新之前） data的值改变后，组件更新，触发update的操作 数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理 updated（组件更新之后） data的值改变后，组件更新，触发update的操作 这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行 beforeDestroy（组件销毁前） 实例销毁之前调用。 destroyed（组件销毁后） 销毁完成后，我们再重新改变data中的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。 Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。钩子函数的使用 beforecreate : 可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 created：进行ajax请求异步数据的获取、初始化数据 mounted：挂载元素内dom节点的获取 nextTick：针对单一事件更新数据后立即操作dom updated：任何数据的更新，如果要做统一的业务逻辑处理 watch：监听具体数据变化，并做相应的处理 render(渲染)函数的使用(解决重复html) template模板中有重复HTMl的时候可以用render函数编译 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;mycomment :level=&quot;2&quot;&gt; 这是h2元素 &lt;/mycomment&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/x-template&quot; id=&quot;is&quot;&gt; &lt;div&gt; &lt;h1 v-if=&quot;level === 1&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-if=&quot;level === 2&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-if=&quot;level === 3&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-if=&quot;level === 4&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-if=&quot;level === 5&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-if=&quot;level === 6&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt; &lt;/div&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&apos;mycomment&apos;,&#123; template:&apos;#is&apos;, props:&#123; level:&#123; type:Number, required:true, &#125; &#125; &#125;) var app =new Vue(&#123; el:&apos;#app&apos;, &#125;) &lt;/script&gt; 用Render函数解决代码冗长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;render-teample :level=&quot;4&quot; &gt; &lt;div class=&quot;jah&quot; slot=&quot;myslot&quot;&gt;render function&lt;/div&gt; &lt;/render-teample&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.component(&apos;render-teample&apos;,&#123; render:function(createElement)&#123; return createElement( &apos;h&apos;+this.level, &#123; &apos;class&apos;:&#123; show:true, hide:false, &#125;, style:&#123; width:&apos;200px&apos;, height:&apos;400px&apos;, background:&apos;red&apos;, &#125;, attrs:&#123; name:&apos;h-ex&apos;, id:&apos;h-id&apos; &#125;, props:&#123; myprops:true, &#125;, on: &#123; click: function(event)&#123; alert(this.num) &#125; &#125;, nativeOn:&#123; click:function(event) &#123; alert(1111) &#125; &#125; &#125;, [ this.$slots.myslot, createElement(&apos;div&apos;,&#123; domProps:&#123; innerHTML:&apos;holle render&apos; &#125; &#125;) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;); var app=new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:110 &#125; &#125;); &lt;/script&gt; vue自定义指令 当项目中需要对纯 DOM 元素进行底层操作,就要用到自定义指令vue自定义指令的注册 注册全局自定义指令 12345Vue.directive(&apos;focus&apos;, &#123; inserted: function (el) &#123; el.focus() &#125;&#125;) 注册局部自定义指令 1234567directives: &#123; focus: &#123; inserted:function (el) &#123; el.focus() &#125; &#125;&#125; ###自定义指令函数提供的钩子函数 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下） componentUpdated: 被绑定元素所在模板完成一次更新周期时调用 unbind: 只调用一次， 指令与元素解绑时调用###钩子函数的参数 el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习二]]></title>
    <url>%2F2017%2F06%2F23%2FVue-js%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Class与Style绑定绑定HTML Class 对象语法： 给v-bind:class一个对象，以动态切换class,语法表示classactive的更新将取决于数据属性 isActive 是否为真值 1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 在对象中传入更多属性用来动态切换多个 class ,v-bind:class 指令可以与普通的 class 属性共存 123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt; 直接绑定数据里的一个对象 1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125; 数组语法 把一个数组传给 v-bind:class ，以应用一个 class 列表： 12345&lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 用三元表达式，据条件切换列表中的 class 1&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt; 条件渲染 v-if是“真正的”条件渲染，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换 区别：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好 vue时间处理器 用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码 v-on 可以接收一个定义的方法来调用，方法定义在methods事件修饰符 vue推荐methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节,当我们要调用 event.preventDefault() 或 event.stopPropagation(),就可以使用事件修饰符 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;div v-on:click.once=&apos;doThat&apos;&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。 关键修饰符 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 12&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt; Vue 为最常用的按键提供了别名 1234&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt; 全部的按键别名 123456789.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right vue的数据绑定 “Mustache” 语法（双大括号）{{text}} 单向的数据绑定 v-model 双向数据绑定v-model可以添加修饰符 可以添加一个修饰符 lazy ,从而转变为在 change 事件中同步： 12&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; 将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值 1&lt;input v-model.number=&apos;age&apos; type=&apos;number&apos;&gt; 如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入： 1&lt;input v-model.trim=&quot;msg&quot;&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2017%2F06%2F23%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装hexo 第一步、执行npm install hexo-cli -g 安装hexo 第二步、找到你想写博客的文件夹，执行hexo init blog生成文件 第三步、在生成的文件blog中执行hexo server，访问http://localhost:4000/ 安装和配置Next主题 在hexo目录下右键Git bash通过命令git clone https://github.com/iissnan/hexo-theme-next themes/nextnext主题自动下载到themes目录下 在blog文件下的站点配置文件_config.yml,找到 theme 字段，并将其值更改为 nexttheme:next hexo s验证主题配置是否成功，浏览器输入 http://localhost:4000 hexo书写博客 在source文件夹的_posts里面,通过hexo new 博客标题命令生成markdown文件 文章写好后，执行hexo generate命令生成静态的html文件 发送博客到github上 我们把public里面的文件发布到github上面 在创建github仓库是取名一定要去[github用户名].github.io 例子:saber-tgb.github.io 用git发送到githoub是一定要发送到master分支 不用更改生成的博客html文件的css，js的路径 传上去后路径就会正确 next主题的配置和优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat:#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信页面开发的注意事项]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[页面搜索框 为了保持和微信搜索一致，搜索框未点击时搜索图标在中间显示，点击搜索框后，搜索图标在左边 实现手机键盘显示搜索按钮&lt;form&gt;标签里面包含&lt;input type=search&gt;，&lt;form&gt;标签必须有action属性, 123456789&lt;form action=&quot;&quot; class=&quot;searchForm&quot; v-show=&quot;searchShow1&quot;&gt; &lt;input type=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;搜索&quot; class=&quot;search&quot; @focus=&quot;searchFocus&quot;&gt; &lt;i class=&quot;iconfont icon-sousuo icoImg&quot;&gt;&lt;/i&gt;&lt;/form&gt;&lt;form action=&quot;&quot; class=&quot;searchForm2&quot; v-show=&quot;searchShow2&quot;&gt; &lt;input type=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;搜索&quot; class=&quot;search&quot; v-model=&quot;keywords2&quot; @keydown=&quot;searchVk($event)&quot;&gt; &lt;i class=&quot;iconfont icon-sousuo icoImg&quot; @click=&quot;getVkBusList()&quot;&gt;&lt;/i&gt; &lt;span class=&quot;btn&quot; @click=&quot;cancelSearch&quot;&gt;取消&lt;/span&gt;&lt;/form&gt; vue绑定事件在&lt;input&gt;标签上,用监听键盘事件@keydown,要使用e.preventDefault()阻止默认事件触发。 页面1px边框显示问题 使用淘宝的flexible.js插件转化为1rem.]]></content>
      <categories>
        <category>微信</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm,browser-sync,gulp工具的学习]]></title>
    <url>%2F2017%2F06%2F16%2Fnpm-browser-sync-gulp%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[npm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 删除指定包:npm remove jquery --save 卸载一般用 npm uninstall –save jquery 或者 npm remove –save jquery 下载安装package.json中dependencies属性对的文件:npm install --production npm的使用步骤 第一步、npm init创建一个文件夹（注意：不要用中文名,不能以数字开头，不能有空格） 第二步、执行npm init -y 第三步、安装需要的js库 npm install –save jquery browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev -dev安装在本地 之所以在全局安装了一次还有在项目中安装，是为了保证gulp的版本的控制，每次使用的时候重新安装能控制gulp的版本 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 得到gulp对象var gulp = require(&quot;gulp&quot;);//引入gulp-uglify插件 用来压缩jsvar uglify = require(&apos;gulp-uglify&apos;);//引入gulp-concat插件 用来合并代码 js,css都能合并var concat = require(&apos;gulp-concat&apos;);//引入gulp-cssnano插件 用来对css进行压缩var cssnano = require(&apos;gulp-cssnano&apos;);//引入gulp-htmlmin插件 用来对html代码进行压缩var htmlmin = require(&apos;gulp-htmlmin&apos;);//引入gulp-imagemin插件 对图片进行压缩var imagemin = require(&apos;gulp-imagemin&apos;);//引入gulp-spriter插件 合并成精灵图var spriter = require(&apos;gulp-spriter&apos;);&lt;!-- more --&gt;//创建js压缩任务gulp.task(&apos;script&apos;,function()&#123; // 这里写任务具体需要做的事情. // 2.匹配到app.js文件,如果使用多个规则，需要以数组的形式来书写第一个参数，数组中的每一个元素都是一个规则。 gulp.src([&apos;./app.js&apos;,&apos;./signIn.js&apos;]) //合并后生成的文件名 .pipe(concat(&apos;all.js&apos;)) //调用方法 压缩js .pipe(uglify()) //将合格的js文件 输出到指定目录 .pipe(gulp.dest(&apos;./dist&apos;))&#125;);//创建css压缩任务gulp.task(&apos;style&apos;,function()&#123; // 匹配css文件 gulp.src([&apos;./style.css&apos;,&apos;./signIn.css&apos;]) .pipe(concat(&apos;all.css&apos;)) // 需要指定一个名字，作为压缩后文件的文件名 .pipe(cssnano()) .pipe(gulp.dest(&apos;./dist&apos;))&#125;);//创建html压缩任务gulp.task(&apos;htmlmin&apos;,function()&#123; gulp.src(&apos;./index.html&apos;) .pipe(htmlmin(&#123; //collapseWhitespace:清除空格 collapseWhitespace:true, //collapseBooleanAttributes:省略布尔属性的值， collapseBooleanAttributes:true, //removeComments:清除html中注释的部分 removeComments:true, //removeEmptyAttributes:清除所有的空属性 removeEmptyAttributes:true, //removeSciptTypeAttributes:清除所有script标签中的type=&quot;text/javascript&quot;属性。 removeScriptTypeAttributes:true, //removeStyleLinkTypeAttributes:清楚所有Link标签上的type属性 removeStyleLinkTypeAttributes:true, //minifyJS:压缩html中的javascript代码。 minifyJS:true, //minifyCSS:压缩html中的css代码 minifyCSS:true &#125;)) .pipe(gulp.dest(&apos;./dist&apos;));&#125;);//创建合并压缩方法gulp.task(&apos;concat&apos;,function()&#123; // 匹配文件 gulp.src([&apos;./1.js&apos;,&apos;./2.js&apos;]) //调用合并方法 生成新的文件名 .pipe(concat(&apos;index.js&apos;)) //调用压缩方法 .pipe(uglify()) //输出到指定目录 .pipe(gulp.dest(&apos;./build&apos;));&#125;)//创建图片压缩方法gulp.task(&apos;imagemin&apos;,function()&#123; //引入图片地址方法 gulp.src(&apos;./images/*&apos;) //调用图片压缩 .pipe(imagemin()) //输出压缩后图片的存放地址 .pipe(gulp.dest(&apos;dist/images&apos;));&#125;);//创建合并精灵图任务gulp.task(&apos;spriter&apos;,function()&#123; return gulp.src(&apos;./style.css&apos;)//原始的css文件地址 //调用spriter精灵图合并方法 .pipe(spriter(&#123; sprite:&apos;test.png&apos;,//合并后图片的名字 slice:&apos;./slice&apos;,//原始小图片路径 outpath:&apos;build/tests&apos;//合并后的大图的地址 &#125;)) //合并精灵图后的css的文件地址 .pipe(gulp.dest(&apos;./build/css&apos;));&#125;)//创建监视任务gulp.task(&quot;watch&quot;,function()&#123; //调用watch方法 //第一个参数是监视目标文件,第二个参数是执行的任务 gulp.watch([&apos;./app.js&apos;,&apos;./signIn.js&apos;],[&quot;script&quot;]); &#125;) 调用方法直接在控制台输入gulp 任务名 gulp监视文件的改变 监视文件,当文件发生改变时,watch方法就会执行目标文件所绑定的事件 使用：在cmd命令窗口直接调用gulp myWatch方法 第一个参数是监视目标文件,第二个参数是执行的任务12345gulp.task(&quot;myWatch&quot;,function()&#123; gulp.watch([&quot;./a.html&quot;,&quot;./b.html&quot;],function()&#123; console.console.log() &#125;)&#125;) gup 结合browsr-sync使用12345678910111213141516//gulp结合browser-sync一起使用//当你改动html,css,js的时候 --&gt; 合并,压缩我们的html,js,css --&gt; browser-sync刷新浏览器//使用之前要在当前项目安装browser-sync 命令:npm install --save-dev browser-syncvar browserSync = require(&apos;browser-sync&apos;) //得到browserSync对象//创建browserSync任务gulp.task(&quot;browserSync&quot;,function()&#123; // 静态服务器 //第一步先用gulp监视index.html,如果有改动就会执行htmlmin这个任务 gulp.watch([&quot;./index.html&quot;],[&quot;htmlmin&quot;]); //第二步开启browserSyn,一旦html文件夹里面压缩的html有改动，就会刷新浏览器 browserSync(&#123; server:&#123; baseDir:&quot;./html&quot; //创建服务器的文件夹 &#125;, files:[&quot;./html/index.html&quot;] //同步的html代码 &#125;); &#125;) gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin 对图片进行压缩 gulp-imagemin 合并精灵图 gulp-spriter]]></content>
      <categories>
        <category>npm</category>
        <category>browser-sync</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>browser-sync</tag>
        <tag>gulp</tag>
        <tag>前端自动化工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用]]></title>
    <url>%2F2017%2F06%2F16%2FGit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。 分布式，集中式版本管理工具 git属于分布式 svn集中式 git安装git初始化一个仓库 创建一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 对比文件差异 命令: git diff 用来比较暂存区文件内容与工作区文件内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 找到生成的ssh钥匙文件的地址：C盘/用户/用户名/.ssh/id_rsa.pub 找到公钥 在github右上角 –&gt; setting –&gt; ssh设置选项 把我们的公钥拷贝到github当中 以后push代码仓库的时候，使用ssh协议，也就是去使用git开头的那个链接 拉取github服务器上的代码及多人协作冲突处理 从服务器拉取代码的方式 方式一:’git clone git url’ 方式二:’git init’+ &apos;git pull url&apos; git pull和git clone这二种拉取方式的区别： 用git pull的话默认没有设置origin这个变量，必须自己手动设置(git remote add …..),而用了git clone则不需要了，默认origin这个变量就存在了 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 解决拒绝提交代码 执行git pull origin master 手动更改代码，解决冲突 执行:’git add’ 执行:’git commit 执行:’git pull origin master’ 执行:’git push origin master’ 如何避免尽量不会出现冲突？ 在每次push之前执行一次git pull git pull的作用： 更新本地仓库至最新改动，相当于先从远程服务器获取最新代码，接着进行自动合并(merge)，如果有冲突会提示你冲突，让你在本地手动解决掉冲突之后，再推送到服务器上面 多人共同使用同一个github服务器仓库 第一步、建立好一个github上面的仓库 第二步、点击setting 第三步、点击add collaborator，在里面找到你的小伙伴的用户名 第四步、生成一个邀请链接 第五步、把这个链接发给你的小伙伴，他同意之后就可以把自己写的代码提交到这个仓库了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代码提交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习]]></title>
    <url>%2F2017%2F06%2F05%2Fvuex%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[理解Vuex 运用Vue进行多组件开发时，多个组件间的数据通信和状态管理很难维护，使用Vuex将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了。 状态管理模式 vuex的状态自管理应用包含以下几个部分 state，驱动应用的数据源; view，以声明方式将state映射到视图； actions，响应在view上的用户输入导致的状态变化 State 每个应用将仅仅包含一个 store 实例,用来存储状态]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>vue</tag>
        <tag>Vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扎实基础JS一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80JS%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[扎实基础CSS一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80CSS%E4%B8%80%2F</url>
    <content type="text"><![CDATA[文本超出显示省略号1234width: 300px //要设置宽度overflow: hidden;white-space: nowrap; text-overflow: ellipsis;]]></content>
  </entry>
  <entry>
    <title><![CDATA[扎实基础HTML一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80HTML%E4%B8%80%2F</url>
    <content type="text"><![CDATA[html5新增的音频和视频 音频audio&lt;audio src=&#39;&#39;&gt;&lt;/audio&gt; 视频video&lt;video src=&#39;&#39;&gt;&lt;/video&gt; html5语义化标签的使用 头部–header和nav标签 header头部，body下的直接子元素header一般用于放页面的介绍性的信息如网站名称、logo或者导航栏nav。12345678910&lt;header&gt; &lt;h1&gt;html5语义化标签&lt;/h1&gt; &lt;nav&gt; &lt;h1&gt;导航&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;章节标签&lt;/li&gt; &lt;li&gt;标题标签&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; 主体部分——main和section main标签表示页面的主体部份，section标签给页面区分不同的章节。section是一个章节标签，构建页面的大纲(outline)。除此外还有nav、artical和aside三个标签能够勾勒页面的轮廓。章节标签通常会带上h1~h6的标题标签。不同的章节标题是独立的，嵌套的章节标题也跟着嵌套。另外多个标题可以用hgroup包括起来，在页面提纲里成为独立的一条内容。 &lt;hgroup&gt;标签用于对网页或区段（section）的标题进行组合。12345678910111213141516 &lt;main&gt; &lt;section&gt; &lt;hgroup&gt; &lt;h2&gt;章节标签&lt;/h2&gt; &lt;p&gt;为页面区分不同的章节&lt;/p&gt; &lt;/hgroup&gt; &lt;div&gt;包括section article nav aside &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;hgroup&gt; &lt;h2&gt;标题标签&lt;/h2&gt; &lt;p&gt;为不同的章节定义标题&lt;/p&gt; &lt;/hgroup&gt; &lt;div&gt;h1 h2 h3 h4 h5 h6六个标题标签&lt;/div&gt; &lt;/section&gt;&lt;/main&gt; 尾部——footer footer和header一样，用在不同的章节里，可以显示该章节（如body整个页面）相关的外链、版权等信息。123&lt;footer&gt; &lt;p&gt;copyright &amp;copy hello, world&lt;/p&gt;&lt;/footer&gt; div和section、section和article的区别 div是一个普通的容器，而section不能当作一个普通的容器使用，使用section要让其起outline的作用，而article比section的章节概念更强。article适用于独立性强的内容，如本身就是一篇文章、博客，或者用户的评论等，article比section更加强调需要包含一个标题标签h1~h6。如果使用article的语义性更好的时候，就不用section。或者，内容可再继续细分章节的也应使用article。 章节的内容是独立的，并且可以嵌套 独立是指每个章节都可以有自己的标题标签、header、footer和nav，并且章节可以相互嵌套123456789101112131415&lt;body&gt; &lt;h1&gt;html标签&lt;/h1&gt; &lt;article&gt; &lt;h1&gt;html5标签&lt;/h1&gt; &lt;section&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;章节标签&lt;/h1&gt; &lt;/section&gt; &lt;/article&gt; &lt;article&gt; &lt;h1&gt;html4标签&lt;/h1&gt; &lt;/article&gt;&lt;/body&gt; 5 其它常用标签 figure用作照片及其注释的容器 1234&lt;figure&gt; &lt;img src=&quot;Mars.jpg&quot; alt=&quot;&quot;&gt; &lt;figcaption&gt;火星&lt;/figcaption&gt; &lt;/figure&gt; aside的内容与页面的主体内容相切，可用作侧边栏]]></content>
      <categories>
        <category>html - html5</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html5</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的学习一]]></title>
    <url>%2F2017%2F06%2F03%2FES6%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vue脚手架vue-cli1的学习一]]></title>
    <url>%2F2017%2F06%2F03%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[vue-cli的模板 vue-cli的脚手架项目模板有webpack-simple 和 webpack 两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能 vue-cli的项目结构1234567891011121314151617181920212223242526272829.|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico |-- index.html // 入口页面|-- package.json // 项目基本信息 package.json文件 package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。自定义npm相关命令 在package.json文件里有一个scripts字段。1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125; 在开发环境下，在命令行中运行npm run dev就相当于在执行node build/dev-server.js。所以script字段是用来指定npm相关命令的缩写的。 dependencies字段和devDependencies字段 dependencies字段指定了项目运行时所依赖的模块 devDependencies字段指定了项目开发时所依赖的模块(项目环境依赖) 在命令行中运行npm install命令，会自动安装dependencies和devDependencies字段中的模块。webpack配置相关 详情在webpack相关博客dev-server.js12345678910111213141516......// http-proxy可以实现转发所有请求代理到后端真实API地址，以实现前后端开发完全分离// 在config/index.js中可以对proxyTable想进行配置var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)......// 热加载要使用webpack-dev-middleware在没有webpack-dev-server的时候进行热加载var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)// 当html-webpack-plugin模板改变是强制进行页面重新加载compiler.plugin(&apos;compilation&apos;, function (compilation) &#123; compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) &#123; hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;) cb() &#125;)&#125;) webpack.base.conf.js123456789101112131415161718192021222324252627282930......module.export = &#123; // 编译入口文件 entry: &#123;&#125;, // 编译输出路径 output: &#123;&#125;, // 一些解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js文件用babel转码 &#123; test: /\.js$/, loader: &apos;babel&apos;, include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // vue文件一些相关配置 vue: &#123;&#125;&#125; check-version.js 这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。12345678910111213141516171819202122232425262728293031323334353637// 加载语义化版本测试库var semver = require(&apos;semver&apos;)// 定制控制台日志的输入样式var chalk = require(&apos;chalk&apos;)// 引入package.json文件var packageConfig = require(&apos;../package.json&apos;)var exec = function (cmd) &#123; return require(&apos;child_process&apos;) .execSync(cmd).toString().trim()&#125;// 定义node和npm版本需求所组成的数组var versionRequirements = [ &#123; name: &apos;node&apos;, currentVersion: semver.clean(process.version), versionRequirement: packageConfig.engines.node &#125;, &#123; name: &apos;npm&apos;, currentVersion: exec(&apos;npm --version&apos;), versionRequirement: packageConfig.engines.npm &#125;]module.exports = function () &#123; var warnings = [] // 依次判断版本是否符合要求 for (var i = 0; i &lt; versionRequirements.length; i++) &#123; var mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &apos;: &apos; + chalk.red(mod.currentVersion) + &apos; should be &apos; + chalk.green(mod.versionRequirement) ) &#125; &#125; ...&#125; .babelrc Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码12345// 设定转码规则&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],// 转码的一些插件&quot;plugins&quot;: [&quot;transform-runtime&quot;],&quot;comments&quot;: false .editorconfig 该文件定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要。123456789root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>脚手架</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的学习一]]></title>
    <url>%2F2017%2F05%2F24%2Fwebpack%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue与后端的交互--axios的使用]]></title>
    <url>%2F2017%2F05%2F24%2FVue%E4%B8%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E4%BA%A4%E4%BA%92-axios%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[axios 基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 功能特性 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 自动转换 JSON 数据 客户端支持保护安全免受 XSRF 攻击 默认配置 可以为每一个请求指定默认配置。 全局 axios 默认配置123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 自定义实例默认配置1234let axiosIns = axios.create(&#123; baseURL: &apos;https://api.example.com&apos;, timeout: 10 * 1000&#125;); 请求方法别名 axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 例子 发送一个 GET 请求 123456789101112131415161718192021// Make a request for a user with a given IDaxios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;);// Optionally the request above could also be done asaxios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送一个 POST 请求 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求 123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); axios API 可以通过给 axios传递对应的参数来定制请求：axios(config)12345678axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 请求配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; //用来向服务器发送请求的url地址 url: &apos;/user&apos;, //请求方法，默认是GET方法 method: &apos;get&apos;, //基础URL路径，假如url不是绝对路径，如 https://some-domain.com/api/v1/login?name=jack,那么向服务器发送请求的URL将会是baseURL + url baseURL: &apos;https://some-domain.com/api/&apos;, // transformRequest方法允许在请求发送到服务器之前修改该请求，此方法只适用于PUT、POST和PATCH方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。 transformRequest: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], //transformResponse方法允许在数据传递到then/catch之前修改response数据。此方法最后也要返回数据。 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // 发送自定义Headers头文件，头文件中包含了http请求的各种信息。 headers: &#123;&apos;Content-Type&apos;:&apos;application/json&apos;&#125;, // params是发送请求的查询参数对象，对象中的数据会被拼接成url?param1=value1&amp;param2=value2。 params: &#123; ID: 12345 &#125;, //params参数序列化器 paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, //data是在发送POST、PUT或者PATCH请求的数据对象。 data: &#123; firstName: &apos;Fred&apos; &#125;, //请求超时设置，单位为毫秒 timeout: 1000, //表明是否有跨域请求需要用到证书 withCredentials: false, // default //adapter允许用户处理更易于测试的请求。返回一个Promise和一个有效的response adapter: function (resolve, reject, config) &#123; /* ... */ &#125;, //auth表明提供凭证用于完成http的身份验证。这将会在headers中设置一个Authorization授权信息。自定义Authorization授权要设置在headers中。 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125; //表示服务器将返回响应的数据类型，有arraybuffer、blob、document、json、text、stream这6个类型，默认是json类似数据。 responseType: &apos;json&apos;, // default // 用作 xsrf token 值的 cookie 名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // 带有 xsrf token 值 http head 名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // 允许在上传过程中的做一些操作,允许在下载过程中的做一些操作 progress: function(progressEvent) &#123; // Do whatever you want with the native progress event &#125;&#125; 响应的数据结构12345678910111213141516&#123; // 服务器返回的数据 data: &#123;&#125;, // HTTP状态吗 status: 200, // 服务器返回的消息 statusText: &apos;OK&apos;, // 返回头 headers: &#123;&#125;, // 在返回我们的配置 config: &#123;&#125;&#125;]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>http</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router的API学习]]></title>
    <url>%2F2017%2F05%2F24%2FVue-router%E7%9A%84API%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&lt;router-link&gt; 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。自定义属性(props) to 表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。1234&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt; replace重定向 设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。1&lt;router-link :to=&quot;&#123; path: &apos;/abc&apos;&#125;&quot; replace&gt;&lt;/router-link&gt; append 设置 append 属性后，则在当前（相对）路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b tab 有时候想要 渲染成某种标签，例如 。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。123&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;li&gt;foo&lt;/li&gt; exact “是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 也会被设置 CSS 类名。 按照这个规则， 将会点亮各个路由！想要链接使用 “exact 匹配模式”，则使用 exact 属性：12&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt; events 声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。 active-class 设置 链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 将”激活时的CSS类名”应用在外层元素 有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 标签本身，那么可以用 渲染外层元素，包裹着内层的原生 标签： 123&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt; &lt;a&gt;/foo&lt;/a&gt;&lt;/router-link&gt; 在这种情况下， 将作为真实的链接（它会获得正确的 href 的），而 “激活时的CSS类名” 则设置到外层的 。 组件是一个 functional 组件，渲染路径匹配到的视图组件。 渲染的组件还可以内嵌自己的 ，根据嵌套路径，渲染嵌套组件。 属性 name 如果 设置了名称，则会渲染对应的路由配置中 components 下的相应组件。查看 命名视图 中的例子。 行为表现 其他属性（非 router-view 使用的属性）都直接传给渲染的组件， 很多时候，每个路由的数据都是包含在路由参数中。 因为它也是个组件，所以可以配合 和 使用。如果两个结合一起用，要确保在内层使用 ：12345&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 路由信息对象- 一个 route object（路由信息对象） 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的 route records（路由记录）。 - route object 是 immutable（不可变） 的，每次成功的导航后都会产生一个新的对象。 路由信息对象的属性- $route.path - 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 - $route.params - 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。 - $route.query - 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 - $route.hash - 当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 - $route.fullPath - 完成解析后的 URL，包含查询参数和 hash 的完整路径。 - $route.matched - 一个数组，包含当前路由的所有嵌套路径片段的 路由记录 。路由记录就是 routes 配置数组中的对象副本（还有在 children 数组）。 - 当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象（副本）。 - $route.name - 当前路由的名称，如果有的话]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>路由</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router的使用一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-router%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[导航钩子 vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消。有多种方式可以在路由导航发生时执行钩子：全局的, 单个路由独享的, 或者组件级的 全局钩子 可以使用 router.beforeEach 注册一个全局的 before 钩子 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中 钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 某个路由独享的钩子1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内钩子123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当钩子执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; beforeRouteEnter 钩子 不能 访问 this，因为钩子在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 识别路由，为路由设置元信息 定义路由的时候配置meta字段来识别路由 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, children: [ &#123; path: &apos;bar&apos;, component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 访问meta字段来判断路由 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录 路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航钩子中的 route 对象）的 $route.matched 数组 通过遍历 $route.matched 来检查路由记录中的 meta字段,来识别路由12345678910111213141516 router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 123456789101112131415router.beforeEach((to,from,next) =&gt; &#123; //只有配置了meta字段的路由才会判断 if(to.meta.requireAuth) &#123; //判断是不是主代理商 if (authStatus==1) &#123; next(); &#125;else &#123; globStatus=true; next(&#123; path: &apos;/&apos;, &#125;) &#125; &#125;else &#123; next(); &#125; 滚动行为 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。注意: 这个功能只在 HTML5 history 模式下可用 当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法：scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。 如果返回一个布尔假的值，或者是一个空对象，那么不会发生滚动。返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：1234567scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125; 数据获取 导航完成之后获取 当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div class=&quot;post&quot;&gt; &lt;div class=&quot;loading&quot; v-if=&quot;loading&quot;&gt; Loading... &lt;/div&gt; &lt;div v-if=&quot;error&quot; class=&quot;error&quot;&gt; &#123;&#123; error &#125;&#125; &lt;/div&gt; &lt;div v-if=&quot;post&quot; class=&quot;content&quot;&gt; &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; loading: false, post: null, error: null &#125; &#125;, created () &#123; // 组件创建完后获取数据， // 此时 data 已经被 observed 了 this.fetchData() &#125;, watch: &#123; // 如果路由有变化，会再次执行该方法 &apos;$route&apos;: &apos;fetchData&apos; &#125;, methods: &#123; fetchData () &#123; this.error = this.post = null this.loading = true // replace getPost with your data fetching util / API wrapper getPost(this.$route.params.id, (err, post) =&gt; &#123; this.loading = false if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125;) &#125; &#125;&#125; 导航完成之前获取 通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 beforeRouteEnter 钩子中获取数据，当数据获取成功后只调用 next 方法。12345678910111213141516171819202122232425262728293031323334export default &#123; data () &#123; return &#123; post: null, error: null &#125; &#125;, beforeRouteEnter (to, from, next) &#123; getPost(to.params.id, (err, post) =&gt; if (err) &#123; // display some global error message next(false) &#125; else &#123; next(vm =&gt; &#123; vm.post = post &#125;) &#125; &#125;) &#125;, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 watch: &#123; $route () &#123; this.post = null getPost(this.$route.params.id, (err, post) =&gt; &#123; if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>路由</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router的使用一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-router%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80%2F</url>
    <content type="text"><![CDATA[vue-router的使用 javascript部分 1234567891011121314151617181920212223242526272829303132333435// 0. 使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;Vue.use(VueRouter)// 1. 定义（路由）组件。// 可以从其他文件 import 进来import Foo from &apos;@/page/login.vue&apos;import Bar from &apos;@/page/login.vue&apos;// 2. 定义路由// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: &apos;/foo&apos;, component: Foo &#125;, &#123; path: &apos;/bar&apos;, component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount(&apos;#app&apos;)// 现在，应用已经启动了！ html部分 12345678910111213141516&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; vue动态路由的设置 使用场景：例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』 1234567891011const User = &#123; template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: &apos;/user/:id&apos;, component: User &#125; ]&#125;)// /user/foo 和 /user/bar 都将映射到相同的路由 一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用. 1234// 我们可以更新 User 的模板，输出当前用户的 IDconst User = &#123; template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125; 响应路由参数的变化 当使用路由参数时，例如从 /user/foo 导航到 user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。 想对路由参数的变化作出响应的话，你可以简单地 watch（监测变化） $route 对象：12345678const User = &#123; template: &apos;...&apos;, watch: &#123; &apos;$route&apos; (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 路由匹配优先级 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 嵌套路由 使用children配置来设置嵌套路由 注意事项：以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。children 配置就是像 routes 配置一样的路由配置数组 1234567891011121314151617181920const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;profile&apos;, component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;posts&apos;, component: UserPosts &#125; ] &#125; ]&#125;) 基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: &apos;&apos;, component: UserHome &#125;, // ...其他子路由 ] &#125; ]&#125;) 用JS控制导航 router.push(location) 1声明式: &lt;router-link :to=&quot;...&quot;&gt; 编程式: router.push(...) 除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。 当你点击 &lt;router-link&gt; 时，这个方法会在内部调用，所以说，点击 &lt;router-link :to=&quot;...&quot;&gt; 等同于调用 router.push(…)。1234567891011// 字符串router.push(&apos;home&apos;)// 对象router.push(&#123; path: &apos;home&apos; &#125;)// 命名的路由router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;) router.replace(location) 它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录1声明式: &lt;router-link :to=&quot;...&quot; replace&gt; 编程式: router.replace(...) router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 命名路由 通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。123456789const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:userId&apos;, name: &apos;user&apos;, component: User &#125; ]&#125;) 命名视图 使用场景：同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。 123&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）： 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向 和 别名 重定向 重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b： 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: &apos;/b&apos; &#125; ]&#125;) 重定向的目标也可以是一个命名的路由 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125; ]&#125;) 甚至是一个方法，动态返回重定向目标： 12345678const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125;&#125; ]&#125;) 别名 /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125; ]&#125;) HTML5 History 模式 vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。1234const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;)]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>路由</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-js%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[VueJs的单文件组件 vuejs 自定义了一种.vue文件，可以把html, css, js 写到一个文件中，从而实现了对一个组件的封装， 一个.vue 文件就是一个单独的组件。 .vue文件是自定义的，浏览器不认识，所以需要对该文件进行解析，在webpack构建中，需要安装vue-loader 对.vue文件进行解析。 好处：项目更易于维护，代码模块化清晰明了，能够使用构建工具开发更有效率 生产环境的部署 使用vue的脚手架vue-cli来配置 vue的过滤器 过滤器可以用在mustache 插值和 v-bind 表达式即: 12&#123;&#123;message | capitalize&#125;&#125;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 过滤器方法注册在filters函数中 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; vue的计算属性 计算属性方法写在computed函数中12345678data: &#123; message: &apos;Hello&apos; &#125;,computed: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; &#125;, vue基本指令 v-for vue的迭代渲染数据必须使用特定语法item in items 可以为数组索引指定别名(或者用于对象的键)(item, index) in items vueJs推荐提供一个 key 的特殊属性来做提示,以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key 属性v-for=&quot;item in items&quot; :key=&quot;item.id&quot; v-show v-show 是简单地切换元素的 CSS 属性 display,用来显示或者隐藏元素 v-show 必须提供布尔值，不支持 &lt;template&gt; 语法，也不支持 v-else。 v-if 根据表达式的值的真假条件渲染元素 v-else-if 前一兄弟元素必须有 v-if 或 v-else-if v-else 不需要表达式 前一兄弟元素必须有 v-if 或 v-else-if v-text 绑定数据，只能渲染成文本格式&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; v-html 绑定输出真正的HTML格式&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt; v-bind 为元素动态地绑定一个或多个特性，或一个组件 prop 到表达式。 v-bind缩写：例&lt;img v-bind:src=&quot;imageSrc&quot;&gt;等同&lt;img :src=&quot;imageSrc&quot;&gt; class和style的动态绑定 &lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;类active是否起作用取决于属性isActive 是否为真值,isActive必须是布尔值 可以在对象中传入更多属性用来动态切换多个 class v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError } 数组语法v-bind:class=&quot;[{ active: isActive }, errorClass] 绑定内联样式：&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&quot;&gt;&lt;/div&gt; 绑定到一个样式对象：1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0——从环境搭建到发布]]></title>
    <url>%2F2017%2F05%2F23%2FVue2-0%E2%80%94%E2%80%94%E4%BB%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%88%B0%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Vue开发环境的配置 安装Nodejsnpm install nodejs 安装webpacknpm install webpack 安装vue脚手架npm install vue-cli -g 用vue-cli创建模板 vue-cli的模板分为两套 精简版：vue init webpack-simple 工程名字 常规版：vue init webpack 工程名字 初始化设置根据需求来设定，多人开发时开启Project name (vue-test)(语法检测)安装项目依赖 npm install 有可能安装速度会很慢可以使用cnpm 安装淘宝镜像npm install -g cnpm项目启动 cd进入项目中npm run devVue项目组件的使用 组件放在工程目录/src下创建component文件夹,组件都在这个目录下创建使用 组件的使用 引入：import firstcomponent from &#39;./component/firstcomponent.vue 注册：data 代码块后面加上components: { firstcomponent } 使用：在&lt;template&gt;&lt;/template&gt;内加上&lt;firstcomponent&gt;&lt;/firstcomponent&gt; Vue路由 安装vue-routernpm install vue-router --save 在man.js中导入路由模块import VueRouter from &#39;vue-router&#39; 使用：Vue.use(VueRouter) 挂载：new Vue({ el: &#39;#app&#39;, router, template: &#39;&lt;App/&gt;&#39;, components: { App } }) 配置项目路由 在router文件夹的index.js文件中配置 导入路由模块import Router from &#39;vue-router&#39; 引入页面模块:import login from &#39;@/page/login.vue&#39; 路由的配置：export default new Router({ routes: [{path: &apos;/login&apos;,name:&apos;登录&apos;,component:login} ]}) 路由的使用：在视图标签中webpack的配置 在config文件夹下的index.js中改变文件打包后指定到的文件夹 index: path.resolve(__dirname, &#39;../../webapp/index.html&#39;), assetsRoot: path.resolve(__dirname, &#39;../../webapp&#39;), assetsSubDirectory: &#39;static&#39;, assetsPublicPath: &#39;/&#39;,-dev: { port:8888}改变文件的端口号#文件打包 npm run build]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
</search>