<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm,browser-sync,gulp工具的学习]]></title>
    <url>%2F2017%2F06%2F16%2Fnpm-browser-sync-gulp%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[npm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 删除指定包:npm remove jquery --save 卸载一般用 npm uninstall –save jquery 或者 npm remove –save jquery 下载安装package.json中dependencies属性对的文件:npm install --production npm的使用步骤 第一步、npm init创建一个文件夹（注意：不要用中文名,不能以数字开头，不能有空格） 第二步、执行npm init -y 第三步、安装需要的js库 npm install –save jquery browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev -dev安装在本地 之所以在全局安装了一次还有在项目中安装，是为了保证gulp的版本的控制，每次使用的时候重新安装能控制gulp的版本 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 得到gulp对象var gulp = require(&quot;gulp&quot;);//引入gulp-uglify插件 用来压缩jsvar uglify = require(&apos;gulp-uglify&apos;);//引入gulp-concat插件 用来合并代码 js,css都能合并var concat = require(&apos;gulp-concat&apos;);//引入gulp-cssnano插件 用来对css进行压缩var cssnano = require(&apos;gulp-cssnano&apos;);//引入gulp-htmlmin插件 用来对html代码进行压缩var htmlmin = require(&apos;gulp-htmlmin&apos;);//引入gulp-imagemin插件 对图片进行压缩var imagemin = require(&apos;gulp-imagemin&apos;);//引入gulp-spriter插件 合并成精灵图var spriter = require(&apos;gulp-spriter&apos;);&lt;!-- more --&gt;//创建js压缩任务gulp.task(&apos;script&apos;,function()&#123; // 这里写任务具体需要做的事情. // 2.匹配到app.js文件,如果使用多个规则，需要以数组的形式来书写第一个参数，数组中的每一个元素都是一个规则。 gulp.src([&apos;./app.js&apos;,&apos;./signIn.js&apos;]) //合并后生成的文件名 .pipe(concat(&apos;all.js&apos;)) //调用方法 压缩js .pipe(uglify()) //将合格的js文件 输出到指定目录 .pipe(gulp.dest(&apos;./dist&apos;))&#125;);//创建css压缩任务gulp.task(&apos;style&apos;,function()&#123; // 匹配css文件 gulp.src([&apos;./style.css&apos;,&apos;./signIn.css&apos;]) .pipe(concat(&apos;all.css&apos;)) // 需要指定一个名字，作为压缩后文件的文件名 .pipe(cssnano()) .pipe(gulp.dest(&apos;./dist&apos;))&#125;);//创建html压缩任务gulp.task(&apos;htmlmin&apos;,function()&#123; gulp.src(&apos;./index.html&apos;) .pipe(htmlmin(&#123; //collapseWhitespace:清除空格 collapseWhitespace:true, //collapseBooleanAttributes:省略布尔属性的值， collapseBooleanAttributes:true, //removeComments:清除html中注释的部分 removeComments:true, //removeEmptyAttributes:清除所有的空属性 removeEmptyAttributes:true, //removeSciptTypeAttributes:清除所有script标签中的type=&quot;text/javascript&quot;属性。 removeScriptTypeAttributes:true, //removeStyleLinkTypeAttributes:清楚所有Link标签上的type属性 removeStyleLinkTypeAttributes:true, //minifyJS:压缩html中的javascript代码。 minifyJS:true, //minifyCSS:压缩html中的css代码 minifyCSS:true &#125;)) .pipe(gulp.dest(&apos;./dist&apos;));&#125;);//创建合并压缩方法gulp.task(&apos;concat&apos;,function()&#123; // 匹配文件 gulp.src([&apos;./1.js&apos;,&apos;./2.js&apos;]) //调用合并方法 生成新的文件名 .pipe(concat(&apos;index.js&apos;)) //调用压缩方法 .pipe(uglify()) //输出到指定目录 .pipe(gulp.dest(&apos;./build&apos;));&#125;)//创建图片压缩方法gulp.task(&apos;imagemin&apos;,function()&#123; //引入图片地址方法 gulp.src(&apos;./images/*&apos;) //调用图片压缩 .pipe(imagemin()) //输出压缩后图片的存放地址 .pipe(gulp.dest(&apos;dist/images&apos;));&#125;);//创建合并精灵图任务gulp.task(&apos;spriter&apos;,function()&#123; return gulp.src(&apos;./style.css&apos;)//原始的css文件地址 //调用spriter精灵图合并方法 .pipe(spriter(&#123; sprite:&apos;test.png&apos;,//合并后图片的名字 slice:&apos;./slice&apos;,//原始小图片路径 outpath:&apos;build/tests&apos;//合并后的大图的地址 &#125;)) //合并精灵图后的css的文件地址 .pipe(gulp.dest(&apos;./build/css&apos;));&#125;)//创建监视任务gulp.task(&quot;watch&quot;,function()&#123; //调用watch方法 //第一个参数是监视目标文件,第二个参数是执行的任务 gulp.watch([&apos;./app.js&apos;,&apos;./signIn.js&apos;],[&quot;script&quot;]); &#125;) 调用方法直接在控制台输入gulp 任务名 gulp监视文件的改变 监视文件,当文件发生改变时,watch方法就会执行目标文件所绑定的事件 使用：在cmd命令窗口直接调用gulp myWatch方法 第一个参数是监视目标文件,第二个参数是执行的任务12345gulp.task(&quot;myWatch&quot;,function()&#123; gulp.watch([&quot;./a.html&quot;,&quot;./b.html&quot;],function()&#123; console.console.log() &#125;)&#125;) gup 结合browsr-sync使用12345678910111213141516//gulp结合browser-sync一起使用//当你改动html,css,js的时候 --&gt; 合并,压缩我们的html,js,css --&gt; browser-sync刷新浏览器//使用之前要在当前项目安装browser-sync 命令:npm install --save-dev browser-syncvar browserSync = require(&apos;browser-sync&apos;) //得到browserSync对象//创建browserSync任务gulp.task(&quot;browserSync&quot;,function()&#123; // 静态服务器 //第一步先用gulp监视index.html,如果有改动就会执行htmlmin这个任务 gulp.watch([&quot;./index.html&quot;],[&quot;htmlmin&quot;]); //第二步开启browserSyn,一旦html文件夹里面压缩的html有改动，就会刷新浏览器 browserSync(&#123; server:&#123; baseDir:&quot;./html&quot; //创建服务器的文件夹 &#125;, files:[&quot;./html/index.html&quot;] //同步的html代码 &#125;); &#125;) gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin 对图片进行压缩 gulp-imagemin 合并精灵图 gulp-spriter]]></content>
      <categories>
        <category>npm</category>
        <category>browser-sync</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>browser-sync</tag>
        <tag>gulp</tag>
        <tag>前端自动化工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用]]></title>
    <url>%2F2017%2F06%2F16%2FGit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。 分布式，集中式版本管理工具 git属于分布式 svn集中式 git安装git初始化一个仓库 创建一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 对比文件差异 命令: git diff 用来比较暂存区文件内容与工作区文件内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 找到生成的ssh钥匙文件的地址：C盘/用户/用户名/.ssh/id_rsa.pub 找到公钥 在github右上角 –&gt; setting –&gt; ssh设置选项 把我们的公钥拷贝到github当中 以后push代码仓库的时候，使用ssh协议，也就是去使用git开头的那个链接 拉取github服务器上的代码及多人协作冲突处理 从服务器拉取代码的方式 方式一:’git clone git url’ 方式二:’git init’+ &apos;git pull url&apos; git pull和git clone这二种拉取方式的区别： 用git pull的话默认没有设置origin这个变量，必须自己手动设置(git remote add …..),而用了git clone则不需要了，默认origin这个变量就存在了 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 解决拒绝提交代码 执行git pull origin master 手动更改代码，解决冲突 执行:’git add’ 执行:’git commit 执行:’git pull origin master’ 执行:’git push origin master’ 如何避免尽量不会出现冲突？ 在每次push之前执行一次git pull git pull的作用： 更新本地仓库至最新改动，相当于先从远程服务器获取最新代码，接着进行自动合并(merge)，如果有冲突会提示你冲突，让你在本地手动解决掉冲突之后，再推送到服务器上面 多人共同使用同一个github服务器仓库 第一步、建立好一个github上面的仓库 第二步、点击setting 第三步、点击add collaborator，在里面找到你的小伙伴的用户名 第四步、生成一个邀请链接 第五步、把这个链接发给你的小伙伴，他同意之后就可以把自己写的代码提交到这个仓库了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代码提交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习]]></title>
    <url>%2F2017%2F06%2F05%2Fvuex%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[理解Vuex 运用Vue进行多组件开发时，多个组件间的数据通信和状态管理很难维护，使用Vuex将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了。状态管理模式 vuex的状态自管理应用包含以下几个部分 state，驱动应用的数据源; view，以声明方式将state映射到视图； actions，响应在view上的用户输入导致的状态变化]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ES6</tag>
        <tag>Vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扎实基础JS一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80JS%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[扎实基础CSS一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80CSS%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[扎实基础HTML一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80HTML%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6的学习一]]></title>
    <url>%2F2017%2F06%2F03%2FES6%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vue脚手架vue-cli1的学习一]]></title>
    <url>%2F2017%2F06%2F03%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[vue-cli的模板 vue-cli的脚手架项目模板有webpack-simple 和 webpack 两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能 vue-cli的项目结构1234567891011121314151617181920212223242526272829.|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico |-- index.html // 入口页面|-- package.json // 项目基本信息 package.json文件 package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。自定义npm相关命令 在package.json文件里有一个scripts字段。1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125; 在开发环境下，在命令行中运行npm run dev就相当于在执行node build/dev-server.js。所以script字段是用来指定npm相关命令的缩写的。 dependencies字段和devDependencies字段 dependencies字段指定了项目运行时所依赖的模块 devDependencies字段指定了项目开发时所依赖的模块(项目环境依赖) 在命令行中运行npm install命令，会自动安装dependencies和devDependencies字段中的模块。webpack配置相关 详情在webpack相关博客dev-server.js12345678910111213141516......// http-proxy可以实现转发所有请求代理到后端真实API地址，以实现前后端开发完全分离// 在config/index.js中可以对proxyTable想进行配置var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)......// 热加载要使用webpack-dev-middleware在没有webpack-dev-server的时候进行热加载var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)// 当html-webpack-plugin模板改变是强制进行页面重新加载compiler.plugin(&apos;compilation&apos;, function (compilation) &#123; compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) &#123; hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;) cb() &#125;)&#125;) webpack.base.conf.js123456789101112131415161718192021222324252627282930......module.export = &#123; // 编译入口文件 entry: &#123;&#125;, // 编译输出路径 output: &#123;&#125;, // 一些解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js文件用babel转码 &#123; test: /\.js$/, loader: &apos;babel&apos;, include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // vue文件一些相关配置 vue: &#123;&#125;&#125; check-version.js 这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。12345678910111213141516171819202122232425262728293031323334353637// 加载语义化版本测试库var semver = require(&apos;semver&apos;)// 定制控制台日志的输入样式var chalk = require(&apos;chalk&apos;)// 引入package.json文件var packageConfig = require(&apos;../package.json&apos;)var exec = function (cmd) &#123; return require(&apos;child_process&apos;) .execSync(cmd).toString().trim()&#125;// 定义node和npm版本需求所组成的数组var versionRequirements = [ &#123; name: &apos;node&apos;, currentVersion: semver.clean(process.version), versionRequirement: packageConfig.engines.node &#125;, &#123; name: &apos;npm&apos;, currentVersion: exec(&apos;npm --version&apos;), versionRequirement: packageConfig.engines.npm &#125;]module.exports = function () &#123; var warnings = [] // 依次判断版本是否符合要求 for (var i = 0; i &lt; versionRequirements.length; i++) &#123; var mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &apos;: &apos; + chalk.red(mod.currentVersion) + &apos; should be &apos; + chalk.green(mod.versionRequirement) ) &#125; &#125; ...&#125; .babelrc Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码12345// 设定转码规则&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],// 转码的一些插件&quot;plugins&quot;: [&quot;transform-runtime&quot;],&quot;comments&quot;: false .editorconfig 该文件定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要。123456789root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的学习一]]></title>
    <url>%2F2017%2F05%2F24%2Fwebpack%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue与后端的交互--axios的使用]]></title>
    <url>%2F2017%2F05%2F24%2FVue%E4%B8%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E4%BA%A4%E4%BA%92-axios%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[axios 基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 功能特性 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 自动转换 JSON 数据 客户端支持保护安全免受 XSRF 攻击 默认配置 可以为每一个请求指定默认配置。 全局 axios 默认配置123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 自定义实例默认配置1234let axiosIns = axios.create(&#123; baseURL: &apos;https://api.example.com&apos;, timeout: 10 * 1000&#125;); 请求方法别名 axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 例子 发送一个 GET 请求 123456789101112131415161718192021// Make a request for a user with a given IDaxios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;);// Optionally the request above could also be done asaxios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送一个 POST 请求 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求 123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); axios API 可以通过给 axios传递对应的参数来定制请求：axios(config)12345678axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 请求配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; //用来向服务器发送请求的url地址 url: &apos;/user&apos;, //请求方法，默认是GET方法 method: &apos;get&apos;, //基础URL路径，假如url不是绝对路径，如 https://some-domain.com/api/v1/login?name=jack,那么向服务器发送请求的URL将会是baseURL + url baseURL: &apos;https://some-domain.com/api/&apos;, // transformRequest方法允许在请求发送到服务器之前修改该请求，此方法只适用于PUT、POST和PATCH方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。 transformRequest: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], //transformResponse方法允许在数据传递到then/catch之前修改response数据。此方法最后也要返回数据。 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // 发送自定义Headers头文件，头文件中包含了http请求的各种信息。 headers: &#123;&apos;Content-Type&apos;:&apos;application/json&apos;&#125;, // params是发送请求的查询参数对象，对象中的数据会被拼接成url?param1=value1&amp;param2=value2。 params: &#123; ID: 12345 &#125;, //params参数序列化器 paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, //data是在发送POST、PUT或者PATCH请求的数据对象。 data: &#123; firstName: &apos;Fred&apos; &#125;, //请求超时设置，单位为毫秒 timeout: 1000, //表明是否有跨域请求需要用到证书 withCredentials: false, // default //adapter允许用户处理更易于测试的请求。返回一个Promise和一个有效的response adapter: function (resolve, reject, config) &#123; /* ... */ &#125;, //auth表明提供凭证用于完成http的身份验证。这将会在headers中设置一个Authorization授权信息。自定义Authorization授权要设置在headers中。 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125; //表示服务器将返回响应的数据类型，有arraybuffer、blob、document、json、text、stream这6个类型，默认是json类似数据。 responseType: &apos;json&apos;, // default // 用作 xsrf token 值的 cookie 名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // 带有 xsrf token 值 http head 名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // 允许在上传过程中的做一些操作,允许在下载过程中的做一些操作 progress: function(progressEvent) &#123; // Do whatever you want with the native progress event &#125;&#125; 响应的数据结构12345678910111213141516&#123; // 服务器返回的数据 data: &#123;&#125;, // HTTP状态吗 status: 200, // 服务器返回的消息 statusText: &apos;OK&apos;, // 返回头 headers: &#123;&#125;, // 在返回我们的配置 config: &#123;&#125;&#125;]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>ajax</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由vue-route的使用]]></title>
    <url>%2F2017%2F05%2F24%2FVue%E8%B7%AF%E7%94%B1vue-route%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vue-router的使用 javascript部分 1234567891011121314151617181920212223242526272829303132333435// 0. 使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;Vue.use(VueRouter)// 1. 定义（路由）组件。// 可以从其他文件 import 进来import Foo from &apos;@/page/login.vue&apos;import Bar from &apos;@/page/login.vue&apos;// 2. 定义路由// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: &apos;/foo&apos;, component: Foo &#125;, &#123; path: &apos;/bar&apos;, component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount(&apos;#app&apos;)// 现在，应用已经启动了！ html部分 12345678910111213141516&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>路由</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-js%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[VueJs的单文件组件 vuejs 自定义了一种.vue文件，可以把html, css, js 写到一个文件中，从而实现了对一个组件的封装， 一个.vue 文件就是一个单独的组件。 .vue文件是自定义的，浏览器不认识，所以需要对该文件进行解析，在webpack构建中，需要安装vue-loader 对.vue文件进行解析。 好处：项目更易于维护，代码模块化清晰明了，能够使用构建工具开发更有效率生产环境的部署 vue基本指令 v-for vue的迭代渲染数据必须使用特定语法item in items 可以为数组索引指定别名(或者用于对象的键)(item, index) in items vueJs推荐提供一个 key 的特殊属性来做提示,以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key 属性v-for=&quot;item in items&quot; :key=&quot;item.id&quot; v-show v-show 是简单地切换元素的 CSS 属性 display,用来显示或者隐藏元素 v-show 必须提供布尔值，不支持 &lt;template&gt; 语法，也不支持 v-else。 v-if 根据表达式的值的真假条件渲染元素 v-else-if 前一兄弟元素必须有 v-if 或 v-else-if v-else 不需要表达式 前一兄弟元素必须有 v-if 或 v-else-if v-text 绑定数据，只能渲染成文本格式&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; v-html 绑定输出真正的HTML格式&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt; v-bind 为元素动态地绑定一个或多个特性，或一个组件 prop 到表达式。 v-bind缩写：例&lt;img v-bind:src=&quot;imageSrc&quot;&gt;等同&lt;img :src=&quot;imageSrc&quot;&gt; class和style的动态绑定 &lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;类active是否起作用取决于属性isActive 是否为真值,isActive必须是布尔值 可以在对象中传入更多属性用来动态切换多个 class v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError } 数组语法v-bind:class=&quot;[{ active: isActive }, errorClass] 绑定内联样式：&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&quot;&gt;&lt;/div&gt; 绑定到一个样式对象：1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>框架</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0——从环境搭建到发布]]></title>
    <url>%2F2017%2F05%2F23%2FVue2-0%E2%80%94%E2%80%94%E4%BB%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%88%B0%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Vue开发环境的配置 安装Nodejsnpm install nodejs 安装webpacknpm install webpack 安装vue脚手架npm install vue-cli -g 用vue-cli创建模板 vue-cli的模板分为两套 精简版：vue init webpack-simple 工程名字 常规版：vue init webpack 工程名字 初始化设置根据需求来设定，多人开发时开启Project name (vue-test)(语法检测)安装项目依赖 npm install 有可能安装速度会很慢可以使用cnpm 安装淘宝镜像npm install -g cnpm项目启动 cd进入项目中npm run devVue项目组件的使用 组件放在工程目录/src下创建component文件夹,组件都在这个目录下创建使用 组件的使用 引入：import firstcomponent from &#39;./component/firstcomponent.vue 注册：data 代码块后面加上components: { firstcomponent } 使用：在&lt;template&gt;&lt;/template&gt;内加上&lt;firstcomponent&gt;&lt;/firstcomponent&gt; Vue路由 安装vue-routernpm install vue-router --save 在man.js中导入路由模块import VueRouter from &#39;vue-router&#39; 使用：Vue.use(VueRouter) 挂载：new Vue({ el: &#39;#app&#39;, router, template: &#39;&lt;App/&gt;&#39;, components: { App } }) 配置项目路由 在router文件夹的index.js文件中配置 导入路由模块import Router from &#39;vue-router&#39; 引入页面模块:import login from &#39;@/page/login.vue&#39; 路由的配置：export default new Router({ routes: [{path: &apos;/login&apos;,name:&apos;登录&apos;,component:login} ]}) 路由的使用：在视图标签中webpack的配置 在config文件夹下的index.js中改变文件打包后指定到的文件夹 index: path.resolve(__dirname, &#39;../../webapp/index.html&#39;), assetsRoot: path.resolve(__dirname, &#39;../../webapp&#39;), assetsSubDirectory: &#39;static&#39;, assetsPublicPath: &#39;/&#39;,-dev: { port:8888}改变文件的端口号#文件打包 npm run build]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2017%2F05%2F23%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装hexo 第一步、执行npm install hexo-cli -g 安装hexo 第二部、找到你想写博客的文件夹，执行hexo init blog生成文件 第三步、在生成的文件blog中执行hexo server，访问http://localhost:4000/安装和配置Next主题 在hexo目录下右键Git bash通过命令git clone https://github.com/iissnan/hexo-theme-next themes/nextnext主题自动下载到themes目录下 在blog文件下的站点配置文件_config.yml,找到 theme 字段，并将其值更改为 nexttheme:next hexo s验证主题配置是否成功，浏览器输入 http://localhost:4000hexo书写博客 在source文件夹的_posts里面,通过hexo new 博客标题命令生成markdown文件 文章写好后，执行hexo generate命令生成静态的html文件发送博客到github上 我们之哟啊把public里面的文件发布到github上面 在创建github仓库是取名一定要去[github用户名].github.io 例子:saber-tgb.github.io 用git发送到githoub是一定要发送到master分支 不用更改生成的博客html文件的css，js的路径 传上去后路径就会正确 next主题的配置和优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat:#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>