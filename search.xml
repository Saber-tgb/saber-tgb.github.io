<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Vue.js讲解]]></title>
      <url>/2018/04/16/Vue.js%E8%AE%B2%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="1-框架使用前期准备"><a href="#1-框架使用前期准备" class="headerlink" title="1.框架使用前期准备"></a>1.框架使用前期准备</h1><h3 id="1-1-Node-js安装"><a href="#1-1-Node-js安装" class="headerlink" title="1.1 Node.js安装"></a>1.1 Node.js安装</h3><ul>
<li>直接去nodejs官网下载最新版本对应操作系统的nodejs进行安装，nodejs安装程序会自己设置环境变量，所以打开命令行输出<code>node -v</code>就能查看安装信息了，就说明安装成功了</li>
<li>npm就是nodejs的包管理工具，在安装nodejs的时候我们就会默认把npm安装了,并且已经配置到系统的环境变量Path中去，在控制台输出<code>npm -v</code>就能看到npm的版本</li>
<li>由于一些众所周知原因,有时候使用npm下载包的时候会非常慢，可以使用淘宝的镜像安装使用cnpm替代npm<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="1-2-ES6的使用"><a href="#1-2-ES6的使用" class="headerlink" title="1.2 ES6的使用"></a>1.2 ES6的使用</h3><ul>
<li>ECMAScript 2015（以下简称 ES6）是 JavaScript 语言的新标准，使用babel可以将es6语法转换成浏览器可以识别的es5语法，在<code>vue-cli</code>脚手架搭建的项目中已集成bable,所以在vue项目我们可以使用ES6进行开发。</li>
<li><p>ES6常用的语法</p>
<ul>
<li>新增let、const声明</li>
<li><p>解构赋值 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;name: &apos;alex&apos;, age: 20&#125;;</div><div class="line">let &#123;name, age&#125; = obj;</div><div class="line">console.log(name);</div><div class="line">console.log(age);</div></pre></td></tr></table></figure>
</li>
<li><p>模版字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;name: &apos;alex&apos;, age: 20&#125;;</div><div class="line">let str = `用户名：$&#123;obj.name&#125;，年龄:$&#123;obj.age&#125;`;</div><div class="line">console.log(str);</div></pre></td></tr></table></figure>
</li>
<li><p>模块化：模块是js能规模化、工程化最大的基础，但之前js对定一块的支持有限，所以当前端使用多个框架或类库时很容易出现冲突等问题。当然了出了一大堆AMD解决方案如seajs,commonjs.reqiruejs…现在在ES6中，已经增加了对模块的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &#123;ajaxreq&#125; from &quot;./ajax&quot;</div><div class="line"></div><div class="line">function httpget(url, pars) &#123;</div><div class="line">    console.log(&apos;http get &apos;)</div><div class="line">    ajaxreq(url, pars)</div><div class="line">&#125;</div><div class="line"></div><div class="line">export &#123;httpget&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1-3Webpack"><a href="#1-3Webpack" class="headerlink" title="1.3Webpack"></a>1.3Webpack</h3><ul>
<li><p>webpack当然是现在最为流行的js打包构建工具，非常强大。相关的配置以及使用三天三夜都要讲完。推荐文档<a href="https://doc.webpack-china.org/" target="_blank" rel="external">https://doc.webpack-china.org/</a></p>
</li>
<li><p>大家需要去明白的webpack的作是：把js项目以及相关依赖都打成一个可真正在浏览器运行的包（尽管babel能把es6转es5,事实上webpack中js的转换也是依靠babel完成的),所以这里不仅包括js转版本，还包含样式(less,sass)、前端构建(vue,react)，以及脚本去注释、压缩、混淆，甚至样式的压缩。都是通过webpack调度各类loadder和插件来完成的。</p>
</li>
</ul>
<h1 id="2-Vue-js基本语法介绍"><a href="#2-Vue-js基本语法介绍" class="headerlink" title="2.Vue.js基本语法介绍"></a>2.Vue.js基本语法介绍</h1><h4 id="什么是vue-vue能帮我们解决什么实际问题"><a href="#什么是vue-vue能帮我们解决什么实际问题" class="headerlink" title="什么是vue,vue能帮我们解决什么实际问题"></a>什么是vue,vue能帮我们解决什么实际问题</h4><ul>
<li>vue简单来说就是一个MVVM框架。</li>
<li>所以在说vue之前，我们先谈谈什么是MVVM(Model-View-ViewModel)。在我们的web前端开发过程中，需要经常做的三个工作就是渲染、交互以及提交，简单的来说就是需要把服务器响应的数据，呈现给浏览器让用户看得到可以交互的基本性东西，由于渲染的内容用户可以做比如点击、输入甚至拖动的各类交互操作，交互完成后又最终需要把用户交互处理后的结果（比如：表单提交）再提交到服务器。</li>
<li>这看起来当然没什么问题，但是有一点点麻烦就是首先需要写大量的代码进行渲染，然后需要写大量的代码来适应用户的各类交互，最终又通过大量的代码来获取用户最终交互的数据，这三个过程其实是分裂的。</li>
<li>那有没有什么更好的办法呢，当然有了，我们的MVVM就是来解决这个问题的。想象一下，如果我们根据某些数据进行渲染完成后，当数据当生改变后与之相关的UI也会重新渲染，更厉害的是当数据绑定的UI由于用户交互发生改变时，我们的数据也会自动更新。</li>
<li>这想想就很激动，没错MVVM框架已经完整的帮我们实现了这一个过程操作，让我们重点去关注数据本身，剩下的就全部将由mvvm框架处理就好了。vue既然是一个mvvm框架，当然这些也就都能做到。简单的界面当然可能感觉不到这种变化带来的前端开发质的飞跃，但当界面越来越复杂、交互越来越多的时候，这种模式的优势就非常明显了。</li>
</ul>
<h4 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h4><ul>
<li>引用vuejs,指定一个vue呈现的Dom元素,声明一个Vue对象，并且挂载指定的Dom元素，指定显示数据,这里需要关注的是Vue初始化对象的el表示该Vue渲染的Dom对象，data则是显示的内容对象,使用Vue模板{{mesasge}}来显示数据的message属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line"> &#123;&#123;message&#125;&#125;</div><div class="line"></div><div class="line">    &lt;hr&gt;</div><div class="line">    &lt;a v-for=&quot;item in navlist&quot;  class=&quot;nav-item&quot;  :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var app = new Vue(&#123;</div><div class="line">        el: &apos;#app&apos;,</div><div class="line">        data: &#123;</div><div class="line">            title:&apos;第一个vue&apos;,</div><div class="line">            message: &apos;Hi,Vue!!!&apos;,</div><div class="line">            navlist:window.pages</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h4 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h4><ul>
<li>在开发过程中，进行数据渲染时我们使用最多的就是根据数据显示或隐藏内容，或者循环显示列表，话不多说看代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line"></div><div class="line">    &lt;div v-if=&quot;seen&quot;&gt;设置能看见我了...&lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;div v-show=&quot;show&quot;&gt;就算我不显示我也还是存在的&lt;/div&gt;  </div><div class="line">    &lt;div v-for=&quot;item in forlist&quot;&gt;name: &#123;&#123;item.name&#125;&#125;,age:&#123;&#123;item.age&#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;hr&gt;</div><div class="line">    &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var app = new Vue(&#123;</div><div class="line">        el: &apos;#app&apos;,</div><div class="line">        data: &#123;</div><div class="line">            seen: true,</div><div class="line">            show: true,</div><div class="line">            forlist: [&#123;</div><div class="line">                name: &apos;alex&apos;,</div><div class="line">                age: 20</div><div class="line">            &#125;, &#123;</div><div class="line">                name: &apos;luke&apos;,</div><div class="line">                age: 30</div><div class="line">            &#125;],</div><div class="line">            title: &apos;条件与循环&apos;,</div><div class="line">            navlist: window.pages</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在元素中使用v-show或者v-if标签是，当指定的变量值为false时，则整个元素块不会显示，但v-show只是把该元素隐藏，而v-if则不显示。如果变量值为true,则效果一致。 v-for就是更简单了，看代码就明白，不多解释。</li>
</ul>
<h4 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h4><ul>
<li>使用vue需要着重关注的点就是，数据、方法与元素的关联关系，如怎么使一个元素的属性为数据的值，或者怎么指定一个方法为元素的事件执行方法，先看代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line"></div><div class="line">    &#123;&#123;message&#125;&#125;</div><div class="line">    &lt;button @click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;</div><div class="line">    &lt;hr&gt;</div><div class="line"></div><div class="line">    &lt;table&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;用户名:&lt;/th&gt;</div><div class="line">            &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;&lt;/td&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;职业:&lt;/th&gt;</div><div class="line">            &lt;td&gt;</div><div class="line">                &lt;select v-model=&quot;user.occupation&quot;&gt;</div><div class="line">                    &lt;option&gt;老师&lt;/option&gt;</div><div class="line">                    &lt;option&gt;医生&lt;/option&gt;</div><div class="line">                    &lt;option&gt;程序员&lt;/option&gt;</div><div class="line">                &lt;/select&gt;</div><div class="line">            &lt;/td&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;性别:&lt;/th&gt;</div><div class="line">            &lt;td&gt;</div><div class="line">                &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;radioMan&quot; value=&quot;男&quot; v-model=&quot;user.sex&quot;&gt;&lt;label</div><div class="line">                    for=&quot;radioMan&quot;&gt;男&lt;/label&gt;</div><div class="line">                &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;radioWoman&quot; value=&quot;女&quot; v-model=&quot;user.sex&quot;&gt;&lt;label</div><div class="line">                    for=&quot;radioWoman&quot;&gt;女&lt;/label&gt;</div><div class="line">            &lt;/td&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;td colspan=&quot;2&quot;&gt;</div><div class="line">                表单结果,用户名：&#123;&#123;user.name&#125;&#125;,职业：&#123;&#123;user.occupation&#125;&#125;,性别：&#123;&#123;user.sex&#125;&#125;</div><div class="line">                &lt;br&gt;</div><div class="line">                &lt;button @click=&quot;getFormVal&quot;&gt;表单值&lt;/button&gt;</div><div class="line"></div><div class="line">            &lt;/td&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">    &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;hr&gt;</div><div class="line">    &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //文本绑定使用&#123;&#123;message&#125;&#125;,事件绑定使用@如@click，属性绑定</div><div class="line">    /**</div><div class="line">     * 各种绑定</div><div class="line">     1.文本绑定使用&#123;&#123;message&#125;&#125;</div><div class="line">     2.属性绑定使用:class,:title=&quot;className&quot;,</div><div class="line">     3.事件绑定，使用@,@click...</div><div class="line">     4.表单绑定使用v-model=&#123;&#125;</div><div class="line">     */</div><div class="line">    var app = new Vue(&#123;</div><div class="line">        el: &apos;#app&apos;,</div><div class="line">        data: &#123;</div><div class="line">            message: &apos;这个是测试的内容文字啊@!!&apos;,</div><div class="line">            navlist: window.pages,</div><div class="line">            user: &#123;</div><div class="line">                name: &apos;tgb&apos;,</div><div class="line">                occupation: &apos;程序员&apos;,</div><div class="line">                sex: &apos;男&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            reverseMessage: function () &#123;</div><div class="line">                this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">            &#125;,</div><div class="line">            getFormVal: function () &#123;</div><div class="line">                console.log(this.user);</div><div class="line"></div><div class="line">                alert(&apos;  表单结果,用户名：&apos; + this.user.name + &apos;,职业：： &apos; + this.user.occupation + &apos;,性别：： &apos; + this.user.sex);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><ul>
<li>vue组件是非常强大重要的功能之一，通过简单的组件封装就能在元素中使用特定功能的标签。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;input v-model=&quot;message&quot;&gt;</div><div class="line">    &lt;br&gt;</div><div class="line">    &lt;child1 :my-message=&quot;message&quot;&gt;&lt;/child1&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;child2 v-for=&quot;item in userlist&quot; :user=&apos;item&apos;&gt;&lt;/child2&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line"></div><div class="line">    &lt;p&gt;总数&#123;&#123;total&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;button1 v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button1&gt;</div><div class="line">    &lt;button2 v-on:reduction=&quot;reductionTotal&quot;&gt;&lt;/button2&gt;</div><div class="line"></div><div class="line">    &lt;hr&gt;</div><div class="line">    &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    Vue.component(&apos;child1&apos;, &#123;</div><div class="line">        props: [&apos;myMessage&apos;],</div><div class="line">        template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    Vue.component(&apos;child2&apos;, &#123;</div><div class="line">        props: [&apos;user&apos;],</div><div class="line">        template: &apos;&lt;li&gt;名字:&#123;&#123; user.name &#125;&#125;,年龄:&#123;&#123;user.age&#125;&#125;&lt;/li&gt;&apos;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    Vue.component(&apos;button1&apos;,&#123;</div><div class="line">        template:&apos;&lt;button v-on:click=&quot;incrementHandler&quot;&gt;+&lt;/button&gt;&apos;,</div><div class="line">        methods: &#123;</div><div class="line">            incrementHandler: function () &#123;</div><div class="line">                this.$emit(&apos;increment&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    Vue.component(&apos;button2&apos;,&#123;</div><div class="line">        template:&apos;&lt;button v-on:click=&quot;reductionHandler&quot;&gt;-&lt;/button&gt;&apos;,</div><div class="line">        methods: &#123;</div><div class="line">            reductionHandler: function () &#123;</div><div class="line">                this.$emit(&apos;reduction&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#app&apos;,</div><div class="line">        data: &#123;</div><div class="line">            message:&apos;测试的文字&apos;,</div><div class="line">            navlist: window.pages,</div><div class="line">            userinfo:&#123;name:&apos;alex&apos;,age:18&#125;,</div><div class="line">            userlist:[</div><div class="line">                &#123;name:&apos;tonme&apos;,age:18&#125;,</div><div class="line">                &#123;name:&apos;luke&apos;,age:22&#125;,</div><div class="line">            ],</div><div class="line">            total: 0</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            reverseMessage: function () &#123;</div><div class="line">                this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">            &#125;,</div><div class="line">            incrementTotal: function () &#123;</div><div class="line">                this.total += 1</div><div class="line">            &#125;,</div><div class="line">            reductionTotal: function () &#123;</div><div class="line">                this.total -= 1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h1 id="3-Vue组件化开发"><a href="#3-Vue组件化开发" class="headerlink" title="3. Vue组件化开发"></a>3. Vue组件化开发</h1><h2 id="3-1vue-cli-脚手架工具"><a href="#3-1vue-cli-脚手架工具" class="headerlink" title="3.1vue-cli 脚手架工具"></a>3.1vue-cli 脚手架工具</h2><ul>
<li>现在前端使用的技术、框架以及工具是非常多非常麻烦的，配置对于一个新手可以说是绝望的。不过还好有一些辅助工具已经把这些工具给封装了，我们只需要简单的几个命令就可以快速把项目跑起来。</li>
</ul>
<h4 id="3-1-1-安装vue-cli"><a href="#3-1-1-安装vue-cli" class="headerlink" title="3.1.1 安装vue-cli"></a>3.1.1 安装vue-cli</h4><ul>
<li>全局安装<code>npm install -g vue-cli</code></li>
<li>安装成功后，使用vue -V检测版本是否已经安装成功<h4 id="3-1-2-搭建项目"><a href="#3-1-2-搭建项目" class="headerlink" title="3.1.2 搭建项目"></a>3.1.2 搭建项目</h4></li>
<li><code>vue init webpack my-projectname</code><h4 id="3-1-3-还原依赖并运行项目"><a href="#3-1-3-还原依赖并运行项目" class="headerlink" title="3.1.3 还原依赖并运行项目"></a>3.1.3 还原依赖并运行项目</h4></li>
<li>cd my-projectname</li>
<li>npm run dev</li>
</ul>
<h4 id="3-1-4-默认项目结构简单介绍"><a href="#3-1-4-默认项目结构简单介绍" class="headerlink" title="3.1.4 默认项目结构简单介绍"></a>3.1.4 默认项目结构简单介绍</h4><ul>
<li>-build 构建相关的脚本目录，开发过程中几乎不需要改更</li>
<li>-config 构建相关的配置目录，没特殊要求也不需要修改</li>
<li>|—index.js 基本的配置脚本，这里可以配置启动的端口，代理等。极少用</li>
<li>node_modules 引用的模块目录，如果太慢可以把该目录排除，不进行索引打描。</li>
<li>-src 源代码开发目录，非常重要，要写的代码都在这里</li>
<li>|—assets 引用资源目录如图片、字体素材等.</li>
<li>|—components 组件类库</li>
<li>|—router vue-router配置目录，如果需要新增router页面需要在这里进行添加</li>
<li>|—App.vue Vue首页</li>
<li>|—main.js Vue入口文件</li>
<li>-index.html 程序入口文件</li>
<li>-package.json nodejs 工程配置文件</li>
</ul>
<h4 id="3-1-5-Vue单文件介绍"><a href="#3-1-5-Vue单文件介绍" class="headerlink" title="3.1.5 Vue单文件介绍"></a>3.1.5 Vue单文件介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;hello&quot;&gt;</div><div class="line">  &#123;&#123;msg&#125;&#125;</div><div class="line">    &lt;br/&gt;</div><div class="line"></div><div class="line">    &lt;button @click=&quot;userclick&quot;&gt;处理一下事件吧&lt;/button&gt;</div><div class="line">    &lt;hr&gt;</div><div class="line">    UI组件：</div><div class="line">    &lt;el-switch</div><div class="line">      v-model=&quot;isselected&quot;</div><div class="line">      active-color=&quot;#13ce66&quot;</div><div class="line">      inactive-color=&quot;#ff4949&quot;&gt;</div><div class="line">    &lt;/el-switch&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  import axios from &quot;axios&quot;;</div><div class="line">export default &#123;</div><div class="line">  name: &apos;HelloWorld&apos;,</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      msg:&apos;&apos;,</div><div class="line">      isselected:true</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods:&#123;</div><div class="line">    userclick:function () &#123;</div><div class="line">      this.msg = `改变了值...$&#123;new Date().getTime()&#125;`</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  mounted()&#123;</div><div class="line">      let that = this;</div><div class="line">      axios.get(&apos;/api/getmsg&apos;).then(res=&gt;&#123;</div><div class="line">          console.log(res);</div><div class="line">          that.msg = res.data.msg;</div><div class="line">      &#125;);</div><div class="line">    console.log(&apos;hw loadding&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</div><div class="line">&lt;style scoped&gt;</div><div class="line">h1, h2 &#123;</div><div class="line">  font-weight: normal;</div><div class="line">&#125;</div><div class="line">ul &#123;</div><div class="line">  list-style-type: none;</div><div class="line">  padding: 0;</div><div class="line">&#125;</div><div class="line">li &#123;</div><div class="line">  display: inline-block;</div><div class="line">  margin: 0 10px;</div><div class="line">&#125;</div><div class="line">a &#123;</div><div class="line">  color: #42b983;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<ul>
<li>template.该部分包含我们最终的vue前端模板</li>
<li>script部分为脚本编写模块 export default 为初始化vue的参数，一般采用了简写最重要的三个部分是 data 函数返回当前对象默认的数据，methods为处理绑定的方法，mounted则为页面加载时执行行回调方法，在这里我们可以向服务器发出请求获取列表，加载数据行装</li>
<li>stytle 就是样式了没什么好说了。</li>
</ul>
<h2 id="3-2-vue-router"><a href="#3-2-vue-router" class="headerlink" title="3.2 vue-router"></a>3.2 vue-router</h2><ul>
<li>vue-router是vue生态最重要的一部分，简单来说用router后使得我们可以进行单个页面开发，控制页面的路由跳转</li>
<li>创建一个vue页面src\components\Profile.vue</li>
<li>在src/router/index.js 脚本中注册路由</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import Router from &apos;vue-router&apos;</div><div class="line">import HelloWorld from &apos;@/components/HelloWorld&apos; </div><div class="line"></div><div class="line">import Profile from &apos;@/components/Profile&apos;</div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line">export default new Router(&#123;</div><div class="line">    routes: [</div><div class="line">        &#123;</div><div class="line">            path: &apos;/&apos;,</div><div class="line">            name: &apos;HelloWorld&apos;,</div><div class="line">            component: HelloWorld</div><div class="line">        &#125;, &#123;</div><div class="line">            path: &apos;/profile&apos;,</div><div class="line">            name: &apos;Profile&apos;,</div><div class="line">            component: Profile</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>使用路由在入口App.Vue中增加代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  &lt;template&gt;</div><div class="line">    &lt;div id=&quot;app&quot;&gt;</div><div class="line">        &lt;img src=&quot;./assets/logo.png&quot;&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;</div><div class="line">            &lt;router-link to=&quot;/profile&quot;&gt;用户中心&lt;/router-link&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;router-view/&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure>
<h1 id="4-aixos使用和配置代理跨域"><a href="#4-aixos使用和配置代理跨域" class="headerlink" title="4. aixos使用和配置代理跨域"></a>4. aixos使用和配置代理跨域</h1><ul>
<li><p>安装axios<code>npm install axios -S</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//基本使用</div><div class="line">mounted()&#123;</div><div class="line">    let that = this;</div><div class="line">    axios.get(&apos;/api/getmsg&apos;).then(res=&gt;&#123;</div><div class="line">        console.log(res);</div><div class="line">        that.msg = res.data.msg;</div><div class="line">    &#125;);</div><div class="line">  console.log(&apos;hw loadding&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>配置代理跨域：在config、index.js文件修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">proxyTable: &#123;</div><div class="line">      &apos;/api&apos;: &#123;</div><div class="line">        target: &apos;http://localhost:8839/&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用vw适配移动端]]></title>
      <url>/2018/04/16/%E4%BD%BF%E7%94%A8vw%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h1 id="1-vw原理解析"><a href="#1-vw原理解析" class="headerlink" title="1.vw原理解析"></a>1.vw原理解析</h1><ul>
<li>vw是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小。</li>
<li>Viewport相关的单位有四个，分别为vw、vh、vmin和vmax:<ul>
<li>vw：是Viewport’s width的简写,1vw等于window.innerWidth的1%</li>
<li>vh：和vw类似，是Viewport’s height的简写，1vh等于window.innerHeihgt的1%</li>
<li>vmin：vmin的值是当前vw和vh中较小的值</li>
<li>vmax：vmax的值是当前vw和vh中较大的值</li>
<li>vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。</li>
</ul>
</li>
<li>如果设计稿的宽度是750px，那么100vw=750px,1vw=7.5px</li>
</ul>
<h1 id="2-Vue项目中使用vw实现移动端适配"><a href="#2-Vue项目中使用vw实现移动端适配" class="headerlink" title="2.Vue项目中使用vw实现移动端适配"></a>2.Vue项目中使用vw实现移动端适配</h1><ul>
<li>安装PostCSS插件<ul>
<li>在.postcssrc.js使用postcss</li>
<li>已经装好有postcss-import、postcss-url、autoprefixer</li>
<li>新增插件：<code>npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano --S</code><a id="more"></a></li>
</ul>
</li>
<li><p>在.postcssrc.js文件对新安装的PostCSS插件进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  &quot;plugins&quot;: &#123;</div><div class="line">    &quot;postcss-import&quot;: &#123;&#125;,</div><div class="line">    &quot;postcss-url&quot;: &#123;&#125;,</div><div class="line">    // 使用postcss的插件实现vw适配移动端</div><div class="line">    // 由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false</div><div class="line">    &apos;postcss-aspect-ratio-mini&apos;: &#123;&#125;, // 用来处理元素容器宽高比</div><div class="line">    &apos;postcss-write-svg&apos;: &#123; // 用来处理移动端1px的解决方案</div><div class="line">      uft8:false</div><div class="line">    &#125;,</div><div class="line">    &apos;postcss-cssnext&apos;: &#123;&#125;, // 让项目使用CSS未来特性 并对其做兼容性处理</div><div class="line">    &apos;postcss-px-to-viewport&apos;: &#123;</div><div class="line">      viewportWidth: 750, // 视窗的宽度，对应我们设计稿的宽度，一般是750</div><div class="line">      viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置</div><div class="line">      unitPrecision: 3, // 指定&apos;px&apos;转换为视窗单位值得小数位数（很多时候无法整除）</div><div class="line">      viewportUnit:&apos;vw&apos;, // 指定需要转换成的视窗单位,建议使用vw</div><div class="line">      selectorBlackList: [&apos;.ignore&apos;,&apos;.hairliness&apos;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名</div><div class="line">      minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值。</div><div class="line">      mediaQuery: false // 允许在媒体查询中转换`px`</div><div class="line">    &#125;,</div><div class="line">    &apos;postcss-viewport-units&apos;: &#123;&#125;, // 给CSS的属性添加content的属性 配合viewport-units-buggyfill解决个别手机不支持vw</div><div class="line">    &apos;cssnano&apos;: &#123; // 压缩和清理CSS代码</div><div class="line">      preset: &apos;advanced&apos;,</div><div class="line">      autoprefixer: false,</div><div class="line">      &apos;postcss-zindex&apos;: false</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>vw兼容方案: 兼容个别手机</p>
<ul>
<li>主要使用viewport-units-buggyfill.js和viewport-units-buggyfill.hacks.js，只需要在你的HTML文件中引入这两个文件。比如在Vue项目中的index.html引入它们</li>
<li><code>&lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt;</code></li>
<li><p>在HTML文件中调用<code>viewport-units-buggyfill</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!--使用viewport-units-buggyfill解决个别手机不支持vw--&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  window.onload = function () &#123;</div><div class="line">    window.viewportUnitsBuggyfill.init(&#123;</div><div class="line">      hacks: window.viewportUnitsBuggyfillHacks</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>前面配置的postcss-viewport-units插件。这个插件将让你无需关注content的内容，插件会自动帮你处理。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -移动端适配 vw </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pc端密码控件的使用]]></title>
      <url>/2018/04/11/pc%E7%AB%AF%E5%AF%86%E7%A0%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="密码控件-PassGuard介绍"><a href="#密码控件-PassGuard介绍" class="headerlink" title="密码控件 PassGuard介绍"></a>密码控件 PassGuard介绍</h1><ul>
<li>使用的密码控件是北京微通新成的</li>
<li>控件集成了<code>crypto-js.js</code>、<code>PassGuardCtrl.js</code>、<code>jQuery.js</code>、AESWithJCE.jar(解密jar);</li>
</ul>
<h1 id="前端初始化控件"><a href="#前端初始化控件" class="headerlink" title="前端初始化控件"></a>前端初始化控件</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        //第一步 向后台发送ajax请求获取sKey,enStr;</div><div class="line">        //第二步初始化控件</div><div class="line">        //初始化控件时注意 pageEdittype必须设置为0 星号 不然会造成input框输入卡</div><div class="line">        var pgeditor = new $.pge(&#123;</div><div class="line">            pgePath : &quot;./ocx/&quot;,//控件下载目录，可以指定绝对路径，如&quot;http://www.baidu.com/download/&quot;</div><div class="line">            pgeId : &quot;_ocx_password&quot;,//控件id</div><div class="line">            pgeEdittype : 0,//控件显示类型,0(星号),1(明文) </div><div class="line">            pgeEreg1 : &quot;[\\s\\S]*&quot;,//输入过程中字符类型限制，如&quot;[0-9]*&quot;表示只能输入数字</div><div class="line">            pgeEreg2 : &quot;[\\s\\S]&#123;6,12&#125;&quot;,//输入完毕后字符类型判断条件，与pgeditor.pwdValid()方法对应</div><div class="line">            pgeMaxlength : 12,//允许最大输入长度</div><div class="line">            pgeTabindex : 2,//tab键顺序</div><div class="line">            pgeClass : &quot;ocx_style&quot;,//控件css样式</div><div class="line">            pgeInstallClass : &quot;ocx_style&quot;,//针对安装或升级的css样式</div><div class="line">            pgeOnkeydown :&quot;FormSubmit()&quot;,//回车键响应函数，需焦点在控件中才能响应</div><div class="line">            tabCallback : &quot;input2&quot;,//火狐tab键回调函数,设置要跳转到的对象ID</div><div class="line">            pgeOnfocus:&quot;pgeFocus()&quot;,//监控光标切入密码控件框</div><div class="line">            pgeOnblur:&quot;pgeBlur()&quot;,//监控光标切出密码控件框</div><div class="line">            //windows10 edge&amp;Chrome42+相关</div><div class="line">            pgeWindowID:&quot;password&quot;+new Date().getTime()+1, //设置多个密码输入框是时间戳一定要不同</div><div class="line">            pgeRZRandNum:sKey,</div><div class="line">            pgeRZDataB:enStr</div><div class="line">        &#125;);</div><div class="line">        window.pgeCtrl = pgeditor;</div><div class="line">        var i = 0;</div><div class="line">        //密码控件获得焦点时，提示一下</div><div class="line">        function pgeFocus()&#123;</div><div class="line">            $(&quot;#tishi&quot;).html(&quot;获得焦点&quot;+(i++));</div><div class="line">        &#125;</div><div class="line">        //密码控件失去焦点时获得密码强度，并展示出来</div><div class="line">        function pgeBlur()&#123;</div><div class="line">            $(&quot;#tishi&quot;).html(&quot;失去焦点&quot;+(i++));</div><div class="line">            //显示密码强度</div><div class="line">            GetLevel();</div><div class="line">        &#125;</div><div class="line">        window.onload = function()&#123;</div><div class="line">            $(&quot;#login&quot;).focus();</div><div class="line">            pgeditor.pgInitialize();</div><div class="line">            $(&quot;lic&quot;).html(pgeditor.setLicense());</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line"></div><div class="line">    //第三步 点击提交时</div><div class="line">    function FormSubmit() &#123;</div><div class="line">	var length = pgeditor.pwdLength();//获得密码长度</div><div class="line">	if (length == 0 || length == undefined) &#123;</div><div class="line">		setTimeout(function()&#123;</div><div class="line">			alert(&quot;密码不能为空&quot;);</div><div class="line">			_$(&quot;_ocx_password&quot;).focus();</div><div class="line">		&#125;,0);</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">	if (pgeditor.pwdValid() == 1) &#123;//判断密码是否匹配正则表达式二</div><div class="line">		setTimeout(function()&#123;</div><div class="line">			alert(&quot;密码不符合要求&quot;);</div><div class="line">			_$(&quot;_ocx_password&quot;).focus();</div><div class="line">		&#125;,0);</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">    // 一定要再次请求获取随机因子并设置</div><div class="line">    // 后台保存此次的sKey</div><div class="line">    //pgeditor.pwdResult()是提交给后台的 加了AES密文的密码</div><div class="line">	$.ajax( &#123;</div><div class="line">		url : &quot;./srand_num.jsp?&quot; + get_time(),//get_time()防止缓存</div><div class="line">		type : &quot;GET&quot;,</div><div class="line">		async : false,</div><div class="line">		success : function(srand_num) &#123;</div><div class="line">			pgeditor.pwdSetSk(srand_num);//给控件设置随机因子</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	var pwdResult = pgeditor.pwdResult();//获取密码AES密文</div><div class="line">	var machineNetwork = pgeditor.machineNetwork();//获取网卡信息密文</div><div class="line">	var machineDisk = pgeditor.machineDisk();//获取硬盘信息密文</div><div class="line">	var machineCPU = pgeditor.machineCPU();//获取CPU信息密文</div><div class="line">	_$(&quot;password&quot;).value = pwdResult;//将密码密文赋值给表单</div><div class="line">	_$(&quot;local_network&quot;).value = machineNetwork;//将网卡和MAC信息密文赋值给表单</div><div class="line">	_$(&quot;local_disk&quot;).value = machineDisk;//将硬盘信息密文赋值给表单</div><div class="line">	_$(&quot;local_cpu&quot;).value = machineCPU;//将CPU信息密文赋值给表单</div><div class="line">	document.form1.submit();</div><div class="line">&#125;</div><div class="line">    第四步 服务器端调用安全控件解密接口进行解密</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码控件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS调试的5个debug技巧]]></title>
      <url>/2018/03/01/JS%E8%B0%83%E8%AF%95%E7%9A%845%E4%B8%AAdebug%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h1 id="1-debugger"><a href="#1-debugger" class="headerlink" title="1.debugger"></a>1.debugger</h1><ul>
<li>直接在javaScript代码中加入一句<code>debugger</code>手工造成一个断点效果</li>
<li>带有条件的断点吗？你只需要用if语句包围它<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (somethingHappens) &#123;</div><div class="line">  debugger;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2-设置在DOM-node发生变化时触发断点"><a href="#2-设置在DOM-node发生变化时触发断点" class="headerlink" title="2.设置在DOM node发生变化时触发断点"></a>2.设置在DOM node发生变化时触发断点</h1><ul>
<li>DOM不受你的控制，自己会发生一些奇怪的变化，让你很难找出问题的根源</li>
</ul>
<h1 id="3-Ajax-断点"><a href="#3-Ajax-断点" class="headerlink" title="3.Ajax 断点"></a>3.Ajax 断点</h1><a id="more"></a>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6中的类]]></title>
      <url>/2018/03/01/ES6%E4%B8%AD%E7%9A%84%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><ul>
<li><p>基本的类声明语法：要声明一个类，首先编写class关键字，紧跟着的是类的名字，其他部分的语法类似于对象字面量方法的简写形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class PersonClass &#123;</div><div class="line">    //等价于PersonClass构造函数</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name</div><div class="line">    &#125;</div><div class="line">    //等价于PersonType.prototype.sayName</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let person = new PersonClass(&apos;tgb&apos;);</div><div class="line">person.sayName(); //outputs &apos;tgb&apos;</div><div class="line"></div><div class="line">console.log(person instanceof PersonClass); //true</div><div class="line">console.log(person instanceof Object);  true</div><div class="line">console.log(typeof PersonClass);    //&apos;function&apos;</div><div class="line">console.log(typeof PersonClass.prototype.sayName); //&apos;function&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>提升：类声明不会声明提升，你首先需要声明你的类，然后访问它，否则会抛出一个ReferenceError：</p>
</li>
</ul>
<h1 id="类语法的特性"><a href="#类语法的特性" class="headerlink" title="类语法的特性:"></a>类语法的特性:</h1><ol>
<li>类声明与let声明类似，不能被提升，真正执行声明语句之前，他们会一直存在于临时死区中</li>
<li>类声明中的所有代码将自行运行在严格模式下，而且无法强行</li>
<li>类中所有方法都是不可枚举的</li>
<li>每个类都有一个名为[[constructor]]的内部方法,通过关键字new调用那些不含[[constructor]]的方法会导致程序抛出错误</li>
<li>使用除关键字new以外的方式调用类的构造函数会导致程序抛出错误</li>
<li>在类中修改类名会导致程序报错</li>
</ol>
<h1 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h1><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><ul>
<li>一个 Promise 就是一个代表了异步操作最终完成或者失败的对象.  一个promise可以使用它的constructor创建</li>
<li>本质上，一个promise是某个函数返回的对象，你可以把回调函数绑定在这个对象上，而不是把回调函数当作参数传进函数</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS总结]]></title>
      <url>/2018/02/02/CSS%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="CSS介绍"><a href="#CSS介绍" class="headerlink" title="CSS介绍"></a>CSS介绍</h1><ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)，是用来定义HTML元素在页面中如何显示。</li>
<li><p>CSS写法分类</p>
<ol>
<li><p>行内样式：通过标签中style属性来设置只能作用在当前标签之中，出了这个标签就没有作用，使用情况少(特定场合，整个页面只有这个标签出现了这个样式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p style=&apos;font-size:16px;color:#fff&apos;&gt;行内样式&lt;/p&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>内嵌样式：把样式写在<code>&lt;head&gt;</code>标签中的<code>&lt;title&gt;</code>标签下，并用<style>标签去声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    &lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</div><div class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;style type=&apos;text/css&apos;&gt;</div><div class="line">        .p1 &#123;</div><div class="line">            color: red;</div><div class="line">        &#125;</div><div class="line">        .p2 &#123;</div><div class="line">            color: yellow;</div><div class="line">        &#125;</div><div class="line">        .p3 &#123;</div><div class="line">            color: green;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;p class=&quot;p1&quot;&gt;内嵌样式第一行&lt;/p&gt;</div><div class="line">    &lt;p class=&quot;p2&quot;&gt;内嵌样式第二行&lt;/p&gt;</div><div class="line">    &lt;p class=&quot;p3&quot;&gt;内嵌样式第三行行&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>外联样式: 在外部定义CSS样式表并形成以.CSS为扩展名文件，然后在页面中通过<link>链接标记链接到页面中，而且该链接语句必须放在页面的<head>标记区。为了结构样式分离，推荐写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</div><div class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;link type=&apos;text/css&apos; rel=&apos;stylesheet&apos; href=&apos;./base.css&apos;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;p class=&quot;p1&quot;&gt;内嵌样式第一行&lt;/p&gt;</div><div class="line">    &lt;p class=&quot;p2&quot;&gt;内嵌样式第二行&lt;/p&gt;</div><div class="line">    &lt;p class=&quot;p3&quot;&gt;内嵌样式第三行行&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><ol>
<li>基础选择器：<ul>
<li>E：元素选择器（以DOM元素名称来匹配）</li>
<li>.classname ：类选择器（以类名来匹配）</li>
<li>#id ：ID选择器（以唯一标识符id属性匹配）</li>
<li><code>*</code> ：通配选择器（可匹配任意类型的DOM元素）</li>
</ul>
</li>
<li>组合选择器<ul>
<li>A B   ：后代选择器（匹配A元素内的B元素，包含所有匹配的子孙后代）</li>
<li>A &gt; B ：子选择器（匹配A元素内的直接后代B元素，不包含孙辈）</li>
<li>A,B,C: 群组选择器的使用范畴是，多个选择器使用同一个样式或者同一组样式。这在做CSS样式初始化，CSS框架设计以及后期CSS代码优化时会经常使用。多个选择器之间用逗号（,）隔开，其语法形式为：&lt;选择器1&gt;,&lt;选择器2&gt;，&lt;选择器3&gt; { 定义样式 }；</li>
<li>A + B ：相邻兄弟选择器（匹配A元素后的兄弟B元素，B元素必须紧跟着A元素）,“+”只能选择该选择器相邻的下一个选择器<ul>
<li>群组选择器的使用范畴是，多个选择器使用同一个样式或者同一组样式。这在做CSS样式初始化，CSS框架设计以及后期CSS代码优化时会经常使用。多个选择器之间用逗号（,）隔开，其语法形式为：&lt;选择器1&gt;,&lt;选择器2&gt;，&lt;选择器3&gt; { 定义样式 }；</li>
</ul>
</li>
<li>A ~ B ：普通兄弟选择器（匹配A元素后的兄弟B元素，B元素只需在A元素后，不要求紧跟）,能选择该选择器后的所有同级选择器</li>
</ul>
</li>
<li>伪元素选择器<ul>
<li>E::after / E:after  ：两个等价，用来创建已选中元素的一个虚拟的最后子元素（行内元素），必须设置content属性</li>
<li>E::before / E:before ：两个等价，用来创建已选中元素的一个虚拟的第一个子元素（行内元素），必须设置content属性</li>
<li>CSS3新增<ul>
<li>E::first-letter / E:first-letter ： 匹配已选中元素内的文字的第一行的第一个字母（只作用于块元素）</li>
<li>E::selection ： 设置文档被选择时的样式</li>
<li>E::first-line / E:first-line ：设置匹配元素内的第一行文字（只作用于块元素）</li>
<li>E::placeholder ：设置表单输入框占位符</li>
</ul>
</li>
</ul>
</li>
<li>伪类选择器<ul>
<li>E:focus ： 匹配一个成为焦点的元素（该元素的onfocus事件发生）</li>
<li>E:link  ： 设置超链接a在未被访问状态的样式</li>
<li>E:visited：匹配超链接a在其链接地址已被访问过的元素</li>
<li>E:active ： 匹配被用户激活的元素（在鼠标点击与释放之间发生的事件）</li>
<li>E:hover ： 匹配鼠标悬停在其上面的元素</li>
<li>结构伪类选择器(CSS3新增 移动端常用)<ul>
<li>E:nth-child(n)：选择所有在其父元素中第n个位置的匹配E的子元素，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始<ul>
<li>tr:nth-child(3)匹配所有表格中第3排的tr；</li>
<li>tr:nth-child(2n+1)匹配所有表格的奇数行；</li>
<li>tr:nth-child(2n)匹配所有表格的偶数行；</li>
<li>tr:nth-child(odd)匹配所有表格的奇数行；</li>
<li>tr:nth-child(even)匹配所有表格的偶数行；</li>
</ul>
</li>
<li>E:last-child: 选择位于其父元素中最后一个位置，且匹配E的子元素。</li>
<li>E:nth-last-child(n)：选择所有在其父元素中倒数第n个位置的匹配E的子元素</li>
<li>E:nth-of-type(n):匹配同类型中的第n个兄弟元素E</li>
<li>E:nth-last-of-type(n):选择父元素中倒数第n个位置，且匹配E的子元素。</li>
<li>E:first-of-type：选择位于其父元素中且匹配E的第一个同类型的子元素。该选择器的功能类似于 E:nth-of-type(1)</li>
<li>E:last-of-type：选择位于其父元素中且匹配E的最后第一个同类型的子元素。该选择器的功能类似于 E:nth-last-of-type(1)</li>
<li>E:only-child：选择其父元素只包含一个子元素，且该子元素匹配E。</li>
<li>E:only-of-type：选择其父元素只包含一个同类型的子元素，且该子元素匹配E。<br>5.属性选择器</li>
</ul>
</li>
<li>a[href]:a标签中含有href属性的所有标签</li>
<li>a[href=”1.pm4”]:a标签中含有href=”1.mp4”的标签</li>
<li>a[href^=”a”]:a标签中有href属性并且以a字母开头的所有标签</li>
<li>a[href$=”d”]:a标签中有href属性并且以d字母结束的所有标签</li>
<li>a[href*=”g”]:a标签中有href属性并且g字母的所有标签 </li>
</ul>
</li>
</ol>
<h1 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h1><ol>
<li>继承性<ul>
<li>子元素可以继承父元素的样式，</li>
<li>(字体)text-，(字体大小)font-，(行高)line-这些开头的属性都可以继承，以及(颜色)color属性</li>
</ul>
</li>
<li>优先级<ul>
<li>选择器是有优先级，其划分是根据权重来的;</li>
<li>权重<ul>
<li>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</li>
<li>算法：（0，0，0，0）==》第一个0对应的是important的个数，第二个0对应的是id选择器的个数，第三个0对应的类选择器的个数，第四个0对应的是标签选择器的个数，</li>
<li>先从第一个0开始比较，如果第一个0大，那么说明这个选择器的权重高，如果第一个相同，比较第二个，依次类推</li>
</ul>
</li>
</ul>
</li>
<li>层叠性<ul>
<li>如果两个相同的属性作用于同一标签，它们会发生层叠。如果多个复合选择器，同时作用于我们的同一标签，优先级就不好计算了，就要计算权重，通过比较权重，来先出优先级最高的选择器</li>
<li>浏览器的渲染机制是从上到下的，当有冲突的时候就采用权重最高的,权重相同则后面覆盖前面</li>
</ul>
</li>
</ol>
<h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><h2 id="内外边距（margin、padding），边框-border"><a href="#内外边距（margin、padding），边框-border" class="headerlink" title="内外边距（margin、padding），边框(border)"></a>内外边距（margin、padding），边框(border)</h2><ol>
<li><p>css盒子模型概念</p>
<ul>
<li><p>在CSS中，所有的网页元素都被看作一个矩形框，或者是元素框。盒子模型描述了元素在网页布局中所占的空间和位置，盒子模型包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素，在写CSS时可以理解成’万物皆盒子’。</p>
<p><img src="http://ojvil4eq9.bkt.clouddn.com/18-2-2/74990554.jpg" alt=""></p>
</li>
<li>图中最内部的框是元素的实际内容，也就是元素框，紧挨着元素框外部的是内边距padding，其次是边框（border），然后最外层是外边距（margin），整个构成了框模型。通常我们设置的背景显示区域，就是内容、内边距、边框这一块范围。而外边距margin是透明的，不会遮挡周边的其他元素。</li>
<li>元素框的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度；</li>
<li>元素框的总高度 = 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度</li>
</ul>
</li>
<li><p>css 外边距合并（叠加）</p>
<ul>
<li><p>两个上下方向相邻的元素框垂直相遇时，外边距会合并，合并后的外边距的高度等于两个发生合并的外边距中较高的那个边距值，如图：</p>
<p>  <img src="http://ojvil4eq9.bkt.clouddn.com/18-2-2/90378467.jpg" alt=""></p>
</li>
<li>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并</li>
<li>在CSS重置时,经常用到.</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">margin : 0;</div><div class="line">padding : 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>开发技巧<ul>
<li><code>margin</code>塌陷<ul>
<li>当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象</li>
<li>解决方法<ul>
<li>给父元素加边框border （副作用）</li>
<li>给父元素设置padding值  （副作用）</li>
<li>父元素添加 overflow：hidden （副作用）</li>
<li>父元素加前置内容生成(::before)。（推荐）</li>
</ul>
</li>
</ul>
</li>
<li>常用：<code>margin: 0 auto</code>实现水平居中</li>
</ul>
</li>
<li><p>box-sizing属性介绍(CSS3新增)</p>
<ul>
<li>box-sizing : content-box|border-box|inherit;</li>
<li>content-box ,默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的width只包含内容。总宽度=margin+border+padding+width</li>
<li>border-box , 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容，即总宽度=margin+width</li>
<li>inherit , 规定应从父元素继承 box-sizing 属性的值</li>
<li>border-box的使用<ul>
<li>一个box宽度为100%，又想要两边有内间距，这时候用就比较好</li>
<li>全局设置 border-box 更符合我们通常对一个「盒子」尺寸的认知，可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度，在写移动端重置css时全局写</li>
</ul>
</li>
</ul>
</li>
<li><p>边框(border)</p>
<ul>
<li>border：设置元素的边框（width style color）</li>
<li>border-width：设置元素边框的宽度</li>
<li>border-style：设置元素边框的样式</li>
<li>border-color：设置元素边框的颜色</li>
<li>单独设置元素边框<ul>
<li>border-top|right|bottom|left</li>
<li>border-top-width</li>
<li>border-top-style</li>
<li>border-top-color</li>
</ul>
</li>
<li>使用<code>border</code>画三角形<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.triangle &#123;</div><div class="line">            width : 0;</div><div class="line">            height: 0;</div><div class="line">            border : 100px solid transparent;</div><div class="line">            border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul>
<li>position：设置元素的定位方式<ul>
<li>static: 没有定位，元素出现在正常的流中</li>
<li>relative: 生成相对定位的元素，相对于元素本身正常位置进行定位。没有脱离文本流，且会占用该元素在文档中初始的页面空间，即在使用top，bottom，left，right进行移动位置之后依旧不会改变其所占用空间的位置。可以使用z-index进行在z轴方向上的移动</li>
<li>absolute: 绝对定位方式，脱离文档流，不会占用页面空间。以最近的不是static定位的父级元素作为参考进行定位，如果其所有的父级元素都是static定位，那么此元素最终则是以当前窗口作为参考进行定位(body元素)</li>
<li>fixed: 固定定位，直接以浏览器窗口作为参考进行定位</li>
</ul>
</li>
<li><p>开发中使用定位实现盒子上下垂直居中,‘父相子绝’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.father &#123;</div><div class="line">    position:relative;</div><div class="line">    width:500px;</div><div class="line">    height:500px;</div><div class="line">&#125;</div><div class="line">.father .son &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    position:absolute;</div><div class="line">    top:50%;</div><div class="line">    left:50%;</div><div class="line">    margin-top:-100px;</div><div class="line">    margin-left:-100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现水平垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">            width: 400px;</div><div class="line">            height: 400px;</div><div class="line">            background: #000;</div><div class="line">            position: absolute;</div><div class="line">            top:0;</div><div class="line">            right:0;</div><div class="line">            bottom:0;</div><div class="line">            left:0;</div><div class="line">            margin: auto;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>z-index：设置一个元素的堆叠顺序(Z轴)，可为负数（只作用于定义了position为非static的元素）</p>
</li>
</ul>
<h2 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h2><ul>
<li>float：设置元素是否及如何浮动</li>
<li>clear：用来清除浮动</li>
<li>在页面标准流中，块级元素独占一行,自上而下排列，为了实现在一行中显示多个块计元素，就要用到浮动让某个块级元素脱硫标准流，漂浮在标准流上。</li>
<li>visibility：hidden设置元素是否显示（占的位置依旧存在）</li>
<li>overflow：设置元素处理溢出内容的方式</li>
<li>overflow-x：设置元素处理横向溢出内容的方式</li>
<li>overflow-y：设置元素处理纵向溢出内容的方式</li>
<li>overflow-wrap：设置当内容溢出时，是否允许换行（和word-wrap一样）</li>
<li>清除浮动的几种方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*单伪元素法*/</div><div class="line">.clearfix:after &#123;</div><div class="line">            content: &apos;&apos;;</div><div class="line">            clear: both;</div><div class="line">            display: block;</div><div class="line">            height: 0;</div><div class="line">        &#125;</div><div class="line">/*双伪元素法*/</div><div class="line">.clearfix:before,.clearfix:after &#123;</div><div class="line">    content:&apos;&apos;;</div><div class="line">    display:table;</div><div class="line">&#125;</div><div class="line">.clearfix:after &#123;</div><div class="line">    clear:both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="flex布局-弹性布局"><a href="#flex布局-弹性布局" class="headerlink" title="flex布局(弹性布局)"></a>flex布局(弹性布局)</h2><h3 id="flex布局介绍"><a href="#flex布局介绍" class="headerlink" title="flex布局介绍"></a>flex布局介绍</h3><ul>
<li>为什么使用flex布局：布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</li>
<li>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br><img src="http://ojvil4eq9.bkt.clouddn.com/18-2-5/28568613.jpg" alt=""></li>
<li>PC端除了要照顾ie9及以前的用户,移动端已经全面支持,是现在的主流布局方式</li>
<li>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</li>
<li><p>任何一个容器都可以指定为 Flex 布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>行内元素也可以使用 Flex 布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p>
<h3 id="flex布局基本概念"><a href="#flex布局基本概念" class="headerlink" title="flex布局基本概念"></a>flex布局基本概念</h3></li>
<li>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="http://ojvil4eq9.bkt.clouddn.com/18-2-5/76951602.jpg" alt=""></li>
<li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</li>
<li>主要介绍:<a href="https://saber-tgb.github.io/2017/09/12/flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/">https://saber-tgb.github.io/2017/09/12/flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/</a></li>
</ul>
<h2 id="网格布局-Grid布局"><a href="#网格布局-Grid布局" class="headerlink" title="网格布局(Grid布局)"></a>网格布局(Grid布局)</h2><ul>
<li>浏览器兼容性:CSS网格布局从Safari 10.1, Firefox 52, Opera 44, Chrome 57开始收到支持，微软Edge在Edge 15会更新对网格布局的支持。</li>
</ul>
<h1 id="字体、文本、文本装饰、书写模式"><a href="#字体、文本、文本装饰、书写模式" class="headerlink" title="字体、文本、文本装饰、书写模式"></a>字体、文本、文本装饰、书写模式</h1><ol>
<li><p>字体</p>
<ul>
<li>font：设置元素的文本特性（style variant weight size lineHeight family）</li>
<li>font-style：设置文本字体样式</li>
<li>font-variant：设置文本是否为小型的大写字母</li>
<li>font-weight：设置文本的字体粗细</li>
<li>font-size：设置文本的字体大小</li>
<li>font-family：设置文本的字体名称列表</li>
<li>font-stretch：设置文字是否横向拉伸变形</li>
<li>font-size-adjust：设置字体大小取决于小写字母，而不是大写字母</li>
<li>@font-face：设置自定义字体</li>
</ul>
</li>
<li><p>文本</p>
<ul>
<li>text-transform：设置文本的大小写</li>
<li>white-space：设置元素中的空格的处理方式</li>
<li>tab-size：设置制表符的长度</li>
<li>word-break：设置怎样在单词内断行</li>
<li>word-wrap/overflow-wrap：两者等价，设置内容溢出时是否断行</li>
<li>text-align：设置行内内容相对它的块父元素的水平对齐方式</li>
<li>text-align-last：设置内容最后一行的水平对齐方式</li>
<li>text-justify：设置文本怎样对齐及对齐间距</li>
<li>word-spacing：设置字与字之间的间距</li>
<li>letter-spacing：设置字符间的间距</li>
<li>text-indent：设置文本的缩进</li>
<li>vertical-align：设置内联元素在行框内的垂直对齐方式</li>
<li>line-height：设置文本的行高</li>
<li>text-size-adjust：设移动端页面中元素文本的大小调整</li>
<li>开发常用：文本超出显示省略号(…)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">width: 300px //要设置宽度</div><div class="line">overflow: hidden;</div><div class="line">white-space: nowrap;</div><div class="line">text-overflow: ellipsis;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>文本装饰</p>
<ul>
<li>text-decoration：设置文本的排版（line style color）</li>
<li>text-decoration-line：设置文本的排版种类</li>
<li>text-decoration-color：设置文本的排版颜色</li>
<li>text-decoration-style：设置文本的排版样式</li>
<li>text-underline-position：设置文本的下划线的位置（支持度不高）</li>
</ul>
</li>
<li><p>书写模式</p>
<ul>
<li>direction：设置文本流的方向</li>
<li>unicode-bidi：用于同一个页面里存在从不同方向读进的文本显示</li>
<li>writing-mode：设置内容块固有的书写方向</li>
</ul>
</li>
</ol>
<h1 id="背景、颜色"><a href="#背景、颜色" class="headerlink" title="背景、颜色"></a>背景、颜色</h1><ol>
<li>背景<ul>
<li>background：设置背景（属性：color position size repeat origin clip attachment image）（可设置多个背景，每组属性间用逗号分隔）</li>
<li>background-color：设置背景色</li>
<li>background-image：设置背景路径（可设置多个背景，每组属性间用逗号分隔）</li>
<li>background-repeat：设置背景是否平铺及平铺方式</li>
</ul>
</li>
<li>颜色<ul>
<li>color：设置文本颜色</li>
<li>opacity：设置元素的不透明度（0~1）</li>
<li>颜色值<ul>
<li>color name：颜色名称</li>
<li>HEX：十六进制记法</li>
<li>RGB：rgb记法</li>
<li>RGBA：rgba记法</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><ul>
<li>CSS3介绍： 是CSS的第三套标准,CSS3的标准规范还没有确定下来，W3C 仍然在对 CSS3 规范进行开发。所以在pc端的浏览器支持程度差，需要添加私有前缀,移动端浏览器用的都是最新版本所以不存在兼容性。</li>
<li>私有前缀<ul>
<li>更具常用的浏览器内核来划分：chrome firefox IE Safari Opera</li>
<li>WebKit内核　　 css前缀<code>-webkit-</code></li>
<li>Mozilla内核　　 css前缀-moz-</li>
<li>Opera 内核 　　 css前缀 <code>-o-</code></li>
<li>Trident内核　　 css前缀 <code>-ms-</code></li>
</ul>
</li>
<li>开发中使用PostCSS的Autoprefixer插件自动补充前缀</li>
</ul>
<h2 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h2><ul>
<li><code>text-shadow: h-shadow v-shadow blur color</code><ul>
<li>h-shadow    必需。水平阴影的位置。允许负值</li>
<li>v-shadow    必需。垂直阴影的位置。允许负值</li>
<li>blur    可选。模糊的距离</li>
<li>color    可选。阴影的颜色</li>
</ul>
</li>
</ul>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><pre><code>- 边框圆角：`border-radius:200px 200px 200px 200px`
    - 参数：原点、半径1-4个，可以不一样
    - 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ）
- 盒阴影：`box-shadow: h-shadow v-shadow blur spread color inset;`
    - h-shadow    必需。水平阴影的位置。允许负值。
    - v-shadow    必需。垂直阴影的位置。允许负值
    - blur    可选。模糊距离
    - spread    可选。阴影的尺寸。
    - color    可选。阴影的颜色。请参阅 CSS 颜色值。
    - inset    可选。将外部阴影 (outset) 改为内部阴影。
</code></pre><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><pre><code>- 
</code></pre><h1 id="CSS实现响应式布局"><a href="#CSS实现响应式布局" class="headerlink" title="CSS实现响应式布局"></a>CSS实现响应式布局</h1><ul>
<li><p>通过查询screen的宽度来指定某个宽度区间的网页布局。</p>
<ul>
<li>超小屏幕（移动设备） 768px以下</li>
<li>小屏设备 768px-992px</li>
<li>中等屏幕 992px-1200px</li>
<li>宽屏设备 1200px以上<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/*0-768 需要在移动端的时候  显示绿色并且是100%显示*/</div><div class="line"></div><div class="line">/*需要查询当前屏幕下的尺寸 and 之后需要加空格*/</div><div class="line"></div><div class="line">@media screen and (max-width:768px)&#123;</div><div class="line"></div><div class="line">    /*定义我们这个区间内的样式*/</div><div class="line"></div><div class="line">    .container&#123;</div><div class="line"></div><div class="line">        width: 100%;</div><div class="line"></div><div class="line">        background: green;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*768-992 需要在小屏幕设备下  显示黄色并且宽度750px*/</div><div class="line"></div><div class="line">@media screen and (min-width:768px) and (max-width: 992px)&#123;</div><div class="line"></div><div class="line">    /*定义我们这个区间内的样式*/</div><div class="line"></div><div class="line">    .container&#123;</div><div class="line"></div><div class="line">        width: 750px;</div><div class="line"></div><div class="line">        background: yellow;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*992-1200 需要在中等屏幕下  显示蓝色并且 宽度是 970px*/</div><div class="line"></div><div class="line">@media screen and (min-width:992px) and (max-width: 1200px)&#123;</div><div class="line"></div><div class="line">    /*定义我们这个区间内的样式*/</div><div class="line"></div><div class="line">    .container&#123;</div><div class="line"></div><div class="line">        width: 970px;</div><div class="line"></div><div class="line">        background: blue;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*1200 需要在大屏幕下 显示粉红色 宽度1170px*/</div><div class="line"></div><div class="line">@media screen and (min-width:1200px)&#123;</div><div class="line"></div><div class="line">    /*定义我们这个区间内的样式*/</div><div class="line"></div><div class="line">    .container&#123;</div><div class="line"></div><div class="line">        width: 1170px;</div><div class="line"></div><div class="line">        background: pink;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>bootstrap</code>框架用来开发响应式页面</p>
</li>
</ul>
</style></p></li></ol></li></ul>]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js学习--path模块]]></title>
      <url>/2018/01/23/Node-js%E5%AD%A6%E4%B9%A0-path%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="Node中的路径分类"><a href="#Node中的路径分类" class="headerlink" title="Node中的路径分类"></a>Node中的路径分类</h1><ul>
<li>node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径。</li>
<li><p>假设的文件目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">path/</div><div class="line">  - dist/</div><div class="line">  - src/</div><div class="line">      - task.js</div></pre></td></tr></table></figure>
</li>
<li><p>在task.js文件中写入以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">console.log(__dirname);</div><div class="line">console.log(__filename);</div><div class="line">console.log(prcess.cwd()); //返回Node.js 进程当前工作的目录。</div><div class="line">console.log(path.resolve(&apos;./&apos;));</div></pre></td></tr></table></figure>
</li>
<li><p>在editor目录下运行node src/task.js，我们可以看到结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">F:\SelfProject\nodeJS-demo\path\src</div><div class="line">F:\SelfProject\nodeJS-demo\path\src\task.js</div><div class="line">F:\SelfProject\nodeJS-demo\path</div><div class="line">F:\SelfProject\nodeJS-demo\path</div></pre></td></tr></table></figure>
</li>
<li><p>在src目录下运行这个文件，node task.js,运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/laihuamin/Documents/richEditor/editor/src</div><div class="line">/Users/laihuamin/Documents/richEditor/editor/src/task.js</div><div class="line">/Users/laihuamin/Documents/richEditor/editor/src</div><div class="line">/Users/laihuamin/Documents/richEditor/editor/src</div></pre></td></tr></table></figure>
</li>
<li><p>归纳</p>
<ol>
<li>__dirname:返回的是这个文件所在文件夹的位置</li>
<li>__filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件</li>
<li>process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止</li>
</ol>
</li>
</ul>
<h1 id="path的模块"><a href="#path的模块" class="headerlink" title="path的模块"></a>path的模块</h1><h2 id="path-normalize-规范化路径"><a href="#path-normalize-规范化路径" class="headerlink" title="path.normalize(规范化路径)"></a>path.normalize(规范化路径)</h2><ul>
<li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;));</div><div class="line"></div><div class="line">/*  输出结果  */</div><div class="line">/foo/bar/baz/asdf</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h2><ul>
<li><p>用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">console.log(path.join(&apos;src&apos;,&apos;task.js));  //src/task.js</div><div class="line">console.log(path.join(&apos;/foo&apos;,&apos;bar&apos;,&apos;baz/asdf&apos;,&apos;quux&apos;,&apos;..&apos;));   //\foo\bar\baz\asdf</div></pre></td></tr></table></figure>
</li>
<li><p>规则:<br>  1.传入的参数是字符串的路径片段，可以是一个，也可以是多个<br>  2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。<br>  3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。<br>  4.如果传入的参数中有不是字符串的，那就直接会报错</p>
<h2 id="path-parse-string"><a href="#path-parse-string" class="headerlink" title="path.parse(string)"></a>path.parse(string)</h2></li>
<li><p>返回路径字符串的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));</div><div class="line">&#123; </div><div class="line">  root: &apos;/&apos;,</div><div class="line">  dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;,</div><div class="line">  base: &apos;task.js&apos;,</div><div class="line">  ext: &apos;.js&apos;,</div><div class="line">  name: &apos;task&apos; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对象解析:<br>  1.root：代表根目录<br>  2.dir：代表文件所在的文件夹<br>  3.base：代表整一个文件<br>  4.name：代表文件名<br>  5.ext: 代表文件的后缀名</p>
<h2 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h2></li>
<li>返回路径中的最后一个部分</li>
<li>可以接收两个参数，一个是path,还有一个是ext（可选参数）.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));  //task.js</div><div class="line">console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;));  //task</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h2>]]></content>
      
        <categories>
            
            <category> Node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> path模块 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react 项目配置]]></title>
      <url>/2018/01/18/react-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="使用create-react-app创建项目"><a href="#使用create-react-app创建项目" class="headerlink" title="使用create-react-app创建项目"></a>使用create-react-app创建项目</h1><ul>
<li>安装 <code>npm install -g create-react-app</code></li>
<li><code>creact-react-app my-app</code></li>
<li><code>cd my-app</code></li>
<li><code>npm start</code></li>
</ul>
<h1 id="在项目中配置Sass"><a href="#在项目中配置Sass" class="headerlink" title="在项目中配置Sass"></a>在项目中配置Sass</h1><ul>
<li><p>安装依赖</p>
<ul>
<li>npm install sass-loader node-sass –save-dev</li>
</ul>
</li>
<li><p>在<code>node_modules/react-scripts/config</code>下找到 <code>webpack.config.dev.js</code>和<code>webpack.config.prod.js</code>文件，在 exclude 中添加 <code>/.scss$/</code>,</p>
</li>
<li><p>在loaders中添加一项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.scss$/,</div><div class="line">    loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ojvil4eq9.bkt.clouddn.com/18-1-18/8728998.jpg" alt=""></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下使用命令行查看端口号和关闭进程]]></title>
      <url>/2018/01/03/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E5%85%B3%E9%97%AD%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><ul>
<li><code>netstat -nao</code> 查看所有端口</li>
<li><code>netstat -nao | findstr &quot;9010&quot;</code> 只查看9010端口</li>
<li>通过PID查找到相应的进程<ul>
<li><code>tasklist | findstr &quot;3017&quot;</code></li>
</ul>
</li>
<li>通过PID关闭进程<ul>
<li><code>taskkill /pid 3017</code></li>
</ul>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack的学习一]]></title>
      <url>/2017/12/24/webpack%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>使用之前确保安装了 Node.js 的最新版本; </li>
<li>官方推荐本地安装webpack,使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目<ul>
<li><code>npm install --save-dev webpack</code></li>
</ul>
</li>
<li>npm脚本命令: <code>webpack --config webpack.config.js</code></li>
</ul>
<h1 id="webpack概念"><a href="#webpack概念" class="headerlink" title="webpack概念"></a>webpack概念</h1><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><pre><code>- entry属性：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
- 通过在webpack.config.js配置文件中配置`entry`属性，来指定一个入口起点（或多个入口起点）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> module.exports = &#123;</div><div class="line">    entry: &apos;path/to/my/entry/file.js&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="出口"><a href="#出口" class="headerlink" title="出口"></a>出口</h2><ul>
<li>output属性：告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">    module.exports = &#123;</div><div class="line">        entry: &apos;./path/to/my/entry/file.js&apos;,</div><div class="line">     output: &#123;</div><div class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">        filename: &apos;my-first-webpack.bundle.js&apos;</div><div class="line">    &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="loader-装载"><a href="#loader-装载" class="headerlink" title="loader(装载)"></a>loader(装载)</h2><ul>
<li>loader:让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理</li>
<li>weppack的核心思想–“万物皆模块”</li>
<li>loader的目标</li>
<li>识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性)</li>
<li>转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const config = &#123;</div><div class="line">    entry: &apos;./path/to/my/entry/file.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">        filename: &apos;my-first-webpack.bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins(插件)"></a>plugins(插件)</h2><ul>
<li>plugins概念：插件用于loader不能完成的任务，插件可以执行范围更广的任务，从打包优化和压缩，一直到重新定义环境中的变量</li>
<li>插件使用：只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">        const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装</div><div class="line">        const webpack = require(&apos;webpack&apos;); // 用于访问内置插件</div><div class="line">        const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">        const config = &#123;</div><div class="line">            entry: &apos;./path/to/my/entry/file.js&apos;,</div><div class="line">            output: &#123;</div><div class="line">                path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">                filename: &apos;my-first-webpack.bundle.js&apos;</div><div class="line">            &#125;,</div><div class="line">            module: &#123;</div><div class="line">                rules: [</div><div class="line">                    &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            plugins: [</div><div class="line">                new webpack.optimize.UglifyJsPlugin(),</div><div class="line">                new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</div><div class="line">            ]</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h1><h2 id="加载CSS"><a href="#加载CSS" class="headerlink" title="加载CSS"></a>加载CSS</h2><ul>
<li>为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader</li>
<li><p><code>npm install --save-dev style-loader css-loader</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &apos;style-loader,</div><div class="line">                    &apos;css-loader&apos;                </div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>这告诉 webpack 编译器(compiler) 如下信息</p>
<ul>
<li>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”</li>
</ul>
</li>
</ul>
<h2 id="加载Sass"><a href="#加载Sass" class="headerlink" title="加载Sass"></a>加载Sass</h2><ul>
<li><code>npm install --save-dev style-loader css-loader node-sass sass-loader</code></li>
<li>node-sass 和 webpack 是 sass-loader 的 peerDependency，因此能够精确控制它们的版本。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /\.scss$/,</div><div class="line">                use: [</div><div class="line">                    &apos;style-loader, // 将 JS 字符串生成为 style 节点</div><div class="line">                    &apos;css-loader&apos;,  // 将 CSS 转化成 CommonJS 模块</div><div class="line">                    &apos;sass-loader&apos;  // 将 Sass 编译成 CSS          </div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="加载less"><a href="#加载less" class="headerlink" title="加载less"></a>加载less</h2><ul>
<li><code>npm install --save-dev style-loader css-loader less-loader less</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [&#123;</div><div class="line">            test: /\.less$/,</div><div class="line">            use: [&#123;</div><div class="line">                loader: &quot;style-loader&quot; // creates style nodes from JS strings</div><div class="line">            &#125;, </div><div class="line">            &#123;</div><div class="line">                loader: &quot;css-loader&quot; // translates CSS into CommonJS</div><div class="line">            &#125;, </div><div class="line">            &#123;</div><div class="line">                loader: &quot;less-loader&quot; // compiles Less to CSS</div><div class="line">            &#125;]</div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><ul>
<li>使用 file-loader，我们可以将图片混合到 CSS 中</li>
<li><code>npm install --save-dev file-loader</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /\.(png|svg|jpg|gif)$/,</div><div class="line">                use: [</div><div class="line">                    &apos;file-loader&apos;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="加载字体"><a href="#加载字体" class="headerlink" title="加载字体"></a>加载字体</h2><pre><code>- 使用file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /\.(woff|woff2|eot|ttf|otf)$/,</div><div class="line">                use: [</div><div class="line">                    &apos;file-loader&apos;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><ul>
<li>要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">             &#123;</div><div class="line">                test: /\.(csv|tsv)$/,</div><div class="line">                use: [</div><div class="line">                    &apos;csv-loader&apos;</div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.xml$/,</div><div class="line">                use: [</div><div class="line">                    &apos;xml-loader&apos;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h1><h2 id="使用HtmlWebpackPlugin"><a href="#使用HtmlWebpackPlugin" class="headerlink" title="使用HtmlWebpackPlugin"></a>使用HtmlWebpackPlugin</h2><ul>
<li>在webpack.config.js配置时，当我们更改一个入口起点的名称，甚至添加了一个新的名称，生成的包将重命名，但是html文件还是会引用旧的名字，为了解决这种问题,HtmlWebpackPlugin将生成自动引用js包文件名的html文件</li>
<li><code>npm install --save-dev html-webpack-plugin</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">  const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">  module.exports = &#123;</div><div class="line">      entry: &#123;</div><div class="line">          app: &apos;./src/index.js&apos;,</div><div class="line">          print: &apos;./src/print.js&apos;</div><div class="line">      &#125;,</div><div class="line">      plugins: [</div><div class="line">          new HtmlWebpackPlugin(&#123;</div><div class="line">              title: &apos;Output Management&apos;</div><div class="line">          &#125;)</div><div class="line">      ],</div><div class="line">      output: &#123;</div><div class="line">          filename: &apos;[name].bundle.js&apos;,</div><div class="line">          path: path.resolve(__dirname, &apos;dist&apos;)</div><div class="line">      &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="清理上次webpack生成的文件夹-dist文件夹"><a href="#清理上次webpack生成的文件夹-dist文件夹" class="headerlink" title="清理上次webpack生成的文件夹(/dist文件夹)"></a>清理上次webpack生成的文件夹(/dist文件夹)</h2><ul>
<li>由于过去的指南和代码示例遗留下来，导致我们的 /dist 文件夹相当杂乱，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件,使用<code>clean-webpack-plugin</code>插件</li>
<li><code>npm install clean-webpack-plugin --save-dev</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        app: &apos;./src/index.js&apos;,</div><div class="line">        print: &apos;./src/print.js&apos;</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new CleanWebpackPlugin([&apos;dist&apos;]),</div><div class="line">        new HtmlWebpackPlugin(&#123;</div><div class="line">            title: &apos;Output Management&apos;</div><div class="line">        &#125;)</div><div class="line">    ],</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;[name].bundle.js&apos;,</div><div class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端构建生态 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql学习--重置密码]]></title>
      <url>/2017/12/22/Mysql%E5%AD%A6%E4%B9%A0-%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="1-打开mysql-exe和mysqld-exe所在的文件夹-复制路径地址"><a href="#1-打开mysql-exe和mysqld-exe所在的文件夹-复制路径地址" class="headerlink" title="1.打开mysql.exe和mysqld.exe所在的文件夹,复制路径地址"></a>1.打开mysql.exe和mysqld.exe所在的文件夹,复制路径地址</h2><p><img src="http://ojvil4eq9.bkt.clouddn.com/17-12-22/9315294.jpg" alt=""></p>
<h2 id="2-通过cmd命令进入mysql-exe所在的文件夹。"><a href="#2-通过cmd命令进入mysql-exe所在的文件夹。" class="headerlink" title="2.通过cmd命令进入mysql.exe所在的文件夹。"></a>2.通过cmd命令进入mysql.exe所在的文件夹。</h2><ul>
<li><code>cd C:\Program Files\MySQL\MySQL Server 5.5\bin</code></li>
</ul>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2>]]></content>
      
        <categories>
            
            <category> Mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议的学习四]]></title>
      <url>/2017/12/21/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h2 id="web服务器的主要功能"><a href="#web服务器的主要功能" class="headerlink" title="web服务器的主要功能"></a>web服务器的主要功能</h2><ol>
<li>建立连接</li>
<li>接受请求–从网络中读取一条HTTP请求报文</li>
<li>处理请求–对请求报文进行解释，并采取行动</li>
<li>构建响应–创建带有正确首部的HTTP响应报文</li>
<li>发送响应–将响应回送给客服端</li>
<li>记录事务处理过程–将于已完成事务有关的内容记录在一个日志文件中。</li>
</ol>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ul>
<li>web代理服务器是网络的中间实体，代理位于客服端和服务器之间，扮演‘中间人’的角色，在各端点之间来回传送HTTP报文。<a id="more"></a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js学习--module模块]]></title>
      <url>/2017/12/13/Node-js%E5%AD%A6%E4%B9%A0-module%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="exports和module-exports的区别"><a href="#exports和module-exports的区别" class="headerlink" title="exports和module.exports的区别"></a>exports和module.exports的区别</h1><ul>
<li>模块require方只能看到<code>module.exports</code>这个对象，它是看不到exports对象的，而我们在编写模块时用到的exports对象实际上只是对module.exports的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">exports.name = (x) =&gt; &#123;</div><div class="line">    console.log(x);</div><div class="line">&#125;</div><div class="line">//和下面一样，修改的都是同一内存地址里的东西</div><div class="line">module.exports.name = (x) =&gt; &#123;</div><div class="line">    console.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*----------下面这样写就存在区别-------------*/</div><div class="line">//下面的 function是一块新的内存地址，导致exports与module.exports不存在任何关系，而require方能看到的只有module.exports这个对象，看不到exports对象，所以这样写导不出去。</div><div class="line">exports = (x) =&gt; &#123;</div><div class="line">    console.log(x);</div><div class="line">&#125;</div><div class="line">//下面的写法是可以导出,说句题外话，module.exports除了导出对象，函数，还可以导出所有的类型，比如字符串、数值</div><div class="line">module.exports = (x) =&gt; &#123;</div><div class="line">    console.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> module模块 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM操作]]></title>
      <url>/2017/12/08/DOM%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="DOM的定义"><a href="#DOM的定义" class="headerlink" title="DOM的定义"></a>DOM的定义</h1><ul>
<li>文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合</li>
</ul>
<h1 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h1><ol>
<li>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<ul>
<li>整个文档是一个文档节点</li>
<li>每个HTML元素是元素节点</li>
<li>HTML元素内的文本是文本节点</li>
<li>每个HTML属性是属性节点</li>
<li>注释是注释节点</li>
</ul>
</li>
<li>DOM节点树</li>
</ol>
<ul>
<li>HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树：通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-12-8/71429195.jpg" alt=""></li>
</ul>
<ol>
<li>节点的关系</li>
</ol>
<ul>
<li>父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）<ul>
<li>在节点树中，顶端节点被称为根（root）</li>
<li>每个节点都有父节点、除了根（它没有父节点）</li>
<li>一个节点可拥有任意数量的子</li>
<li>同胞是拥有相同父节点的节点</li>
</ul>
</li>
</ul>
<p><img src="http://ojvil4eq9.bkt.clouddn.com/17-12-8/13541114.jpg" alt=""></p>
<h1 id="HTML-DOM方法-元素节点方法"><a href="#HTML-DOM方法-元素节点方法" class="headerlink" title="HTML DOM方法(元素节点方法)"></a>HTML DOM方法(元素节点方法)</h1><ul>
<li>方法是我们可以在节点上执行的动作<h2 id="获取DOM元素方法"><a href="#获取DOM元素方法" class="headerlink" title="获取DOM元素方法"></a>获取DOM元素方法</h2></li>
</ul>
<ol>
<li><p><code>getElementById</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&apos;id&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>getElementsByTagName</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.getElementsByTagName(&apos;li&apos;) //返回数组</div></pre></td></tr></table></figure>
</li>
<li><p><code>getElementsByClassName</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.getElementsByClassName(&apos;class&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>querySelector</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.querySelector(&quot;#myid .myclass&quot;); //返回文档中匹配指定的选择器组的第一个元素</div></pre></td></tr></table></figure>
</li>
<li><p><code>querySelectorAll</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.querySelectorAll(&apos;#myClass&apos;);  //返回的 NodeList 将包含文档中的所有节点，这些都是由特定选择器匹配的</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="获取设置属性接的的方法"><a href="#获取设置属性接的的方法" class="headerlink" title="获取设置属性接的的方法"></a>获取设置属性接的的方法</h2><ol>
<li><code>getAttribute()</code></li>
</ol>
<ul>
<li>返回元素上一个指定的属性值。如果指定的属性不存在，则返回  null 或 “” （空字符串）<br>let div1 = document.getElementById(“div1”);<br>let align = div1.getAttribute(“align”);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let dive = document.getElementById(&apos;div1&apos;);</div><div class="line">let align = div.getAttribute(&apos;align&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><code>setAttribute()</code></li>
</ol>
<ul>
<li>设置指定元素上的一个属性值。如果属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//语法</div><div class="line">element.setAttribute(name, value);</div><div class="line"></div><div class="line">let div1 = document.getElementById(&quot;div1&quot;); </div><div class="line"></div><div class="line">div1.setAttribute(&quot;align&quot;, &quot;center&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><code>removeAttribute()</code>从指定的元素中删除一个属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let div = document.getElementById(&quot;div1&quot;)</div><div class="line"></div><div class="line">div.removeAttribute(&quot;align&quot;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="HTML-DOM属性"><a href="#HTML-DOM属性" class="headerlink" title="HTML DOM属性"></a>HTML DOM属性</h1><ul>
<li>属性是节点（HTML 元素）的值，您能够获取或设置。</li>
</ul>
<ol>
<li><code>Element.innerHTML</code> </li>
</ol>
<ul>
<li>属性设置或获取描述元素后代的HTML语法</li>
</ul>
<ol>
<li><code>Node.nodeName</code></li>
</ol>
<ul>
<li>返回当前节点的节点名称<ul>
<li>nodeName 是只读的</li>
<li>元素节点的 nodeName 与标签名相同</li>
<li>属性节点的 nodeName 与属性名相同</li>
<li>文本节点的 nodeName 始终是 #text</li>
<li>文档节点的 nodeName 始终是 #document</li>
</ul>
</li>
</ul>
<ol>
<li><code>Node.nodeName</code></li>
</ol>
<ul>
<li>返回或设置当前节点的值<ul>
<li>元素节点的 nodeValue 是 undefined 或 null</li>
<li>文本节点的 nodeValue 是文本本身</li>
<li>属性节点的 nodeValue 是属性值</li>
</ul>
</li>
</ul>
<ol>
<li><code>Node.nodeType</code></li>
</ol>
<ul>
<li>只读属性,表示的是该节点的类型。</li>
</ul>
<p>元素类型|NodeType<br>元素|1<br>文本|3<br>注释|8<br>文档(Document)|9<br>5.<code>Node.childNodes</code></p>
<ul>
<li>返回包含指定节点的子节点的集合(NodeList 类型)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DOM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVG Sprites的使用]]></title>
      <url>/2017/12/08/SVG%20Sprites%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="SVG简介"><a href="#SVG简介" class="headerlink" title="SVG简介"></a>SVG简介</h1><ul>
<li>SVG是一种开放标准的矢量图形语言，使用svg格式我们可以直接用代码来描绘图像，可以用任何文字处理工具打开svg图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来浏览。</li>
</ul>
<h1 id="SV优缺点"><a href="#SV优缺点" class="headerlink" title="SV优缺点"></a>SV优缺点</h1><table>
<thead>
<tr>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.缩放无损还原，显示清晰</td>
<td style="text-align:left">1.SVG在绘制的性能上比PNG要差</td>
</tr>
<tr>
<td style="text-align:left">2.语义性良好</td>
<td style="text-align:left">2.局限性，对应单色或普通渐变没什么问题，但对不规则的渐变以及特效叠加效果显示不全</td>
</tr>
<tr>
<td style="text-align:left">3.可用CSS控制图标样式以及动画</td>
<td style="text-align:left">3.兼容性稍差，android4.1才开始支持</td>
</tr>
<tr>
<td style="text-align:left">4.减少http请求</td>
<td style="text-align:left">4.学习应用成本较高</td>
</tr>
</tbody>
</table>
<h1 id="使用-SVG-中的-symbol，use-元素来制作SVG-Sprite"><a href="#使用-SVG-中的-symbol，use-元素来制作SVG-Sprite" class="headerlink" title="使用 SVG 中的 symbol，use 元素来制作SVG Sprite"></a>使用 SVG 中的 symbol，use 元素来制作SVG Sprite</h1><ul>
<li>l;]’SVG Symbols的使用，本质上是对Sprite的进一步优化，通过<code>&lt;symbol&gt;</code>元素来对单个SVG元素进行分组，使用<code>&lt;use&gt;</code>元素引用并进行渲染。这种方法的解决了上述三种方式带来的弊端，少量的http请求，图标能被缓存方便复用，每个SVG图标可以更改大小颜色，整合、使用以及管理起来非常简单</li>
</ul>
<h1 id="Web应用中SVG的使用方式-了解"><a href="#Web应用中SVG的使用方式-了解" class="headerlink" title="Web应用中SVG的使用方式(了解)"></a>Web应用中SVG的使用方式(了解)</h1><ol>
<li>使用img、object、embed 标签直接引用svg</li>
</ol>
<ul>
<li>此方法的缺点主要在于每个图标都需单独保存成一个 SVG 文件，使用时单独请求，增加了HTTP请求数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;./example.svg&quot; alt=&quot;svg图标&quot;&gt;</div><div class="line">&lt;object class=&quot;example&quot; data=&quot;./example.svg&quot; type=&quot;image/svg+xml&quot;&gt;My Example SVG&lt;/object&gt;</div><div class="line">&lt;iframe src=&quot;example.svg&quot; class=&quot;example&quot;&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>直接把SVG写入 HTML 中</li>
</ol>
<ul>
<li>Inline SVG 作为HTML文档的一部分，不需要单独请求。临时需要修改某个图标的形状也比较方便。但是Inline SVG使用上比较繁琐，需要在页面中插入一大块SVG代码不适合手写，图标复用起来也比较麻烦。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;svg width=&quot;300&quot; height=&quot;200&quot; class=&quot;example&quot;&gt;</div><div class="line">        &lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;green&quot;&gt;&lt;/rect&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>SVG Sprite</li>
</ol>
<ul>
<li>这里的Sprite技术，类似于CSS中的Sprite技术。图标图形整合在一起，实际呈现的时候准确显示特定图标。其实基础的SVG Sprite也只是将原来的位图改成了SVG而已，控制SVG大小、颜色需要重新合并SVG文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.icon-bg&#123;</div><div class="line">    display: inline-block;</div><div class="line">    width: 30px;</div><div class="line">    height: 30px;</div><div class="line">    background: url(./res/svg-sprite-background.svg);</div><div class="line">    background-size:100% 100%;</div><div class="line">&#125;</div><div class="line">.icon-facebook-logo&#123;</div><div class="line">    background-position: 0 0;</div><div class="line">&#125;</div><div class="line">.icon-earth&#123;</div><div class="line">    background-position: 0 -30px;</div><div class="line">&#125;</div><div class="line">&lt;span class=&quot;icon-bg icon-facebook-logo&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;span class=&quot;icon-bg icon-earth&quot;&gt;&lt;/span&gt;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> SVG </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SVG </tag>
            
            <tag> SVG Sprites </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript语句]]></title>
      <url>/2017/12/04/JavaScript%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="一、条件语句"><a href="#一、条件语句" class="headerlink" title="一、条件语句"></a>一、条件语句</h1><h2 id="1-if"><a href="#1-if" class="headerlink" title="1.if"></a>1.if</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (表达式) &#123;</div><div class="line">    //表达式为真执行</div><div class="line">&#125; else &#123;</div><div class="line">    //否则</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>只有<code>false</code>,<code>null</code>,’undefined’,空字符串,数字0,数字NaN的值为假，其他所有值都是真<h2 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2.switch语句"></a>2.switch语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">switch (i) &#123;</div><div class="line">    case 25:</div><div class="line">        alert(25);</div><div class="line">        break;</div><div class="line">    case 36:</div><div class="line">        alert(36);</div><div class="line">        bresk;</div><div class="line">    default:</div><div class="line">        alert(11);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-while语句"><a href="#3-while语句" class="headerlink" title="3.while语句"></a>3.while语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var i = 0;</div><div class="line">while(i&lt;10) &#123;</div><div class="line">    alert(i);</div><div class="line">    i+=1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二、循环语句"><a href="#二、循环语句" class="headerlink" title="二、循环语句"></a>二、循环语句</h1><h2 id="1-for语句"><a href="#1-for语句" class="headerlink" title="1.for语句"></a>1.for语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0;i&lt;10; i++) &#123;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-for-in-语句"><a href="#2-for-in-语句" class="headerlink" title="2.for in 语句"></a>2.for in 语句</h2><ul>
<li>判断对象是否有属性<code>myvar</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (myvar in obj) &#123;</div><div class="line">    if(obj.hasOwnProperty(myvar)) &#123;</div><div class="line">        console.log(&apos;有&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="三、强制跳转语句"><a href="#三、强制跳转语句" class="headerlink" title="三、强制跳转语句"></a>三、强制跳转语句</h1><h2 id="1-break语句立即退出循环，-循环结束-强制执行循环后的语句"><a href="#1-break语句立即退出循环，-循环结束-强制执行循环后的语句" class="headerlink" title="1.break语句立即退出循环，(循环结束)强制执行循环后的语句"></a>1.<code>break</code>语句立即退出循环，(循环结束)强制执行循环后的语句</h2><h2 id="2-continue语句只退出当前循环，退出循环后会从循环的顶部继续执行。"><a href="#2-continue语句只退出当前循环，退出循环后会从循环的顶部继续执行。" class="headerlink" title="2.continue语句只退出当前循环，退出循环后会从循环的顶部继续执行。"></a>2.<code>continue</code>语句只退出当前循环，退出循环后会从循环的顶部继续执行。</h2>]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 条件语句 </tag>
            
            <tag> 循环语句 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo常用命令笔记]]></title>
      <url>/2017/11/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h1><ul>
<li><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章</li>
<li><code>hexo p</code> == <code>hexo publish</code></li>
<li><code>hexo g</code> == <code>hexo generate</code>#生成</li>
<li><code>hexo s</code> == <code>hexo server</code> #启动服务预览</li>
<li><code>hexo d</code> == <code>hexo deploy</code>#部署</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><ul>
<li><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。</li>
<li><code>hexo server</code> -s #静态模式</li>
<li><code>hexo server -p 5000</code> #更改端口</li>
<li><code>hexo server -i 192.168.1.1</code> #自定义 IP</li>
<li><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令</li>
<li><code>hexo g</code> #生成静态网页</li>
<li><code>hexo d</code> #开始部署</li>
<li><code>hexo server -o</code> #开启服务打开页面</li>
</ul>
<h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><ul>
<li><code>hexo generate</code> #使用 Hexo 生成静态文件快速而且简单</li>
<li><code>hexo generate --watch</code> #监视文件变动</li>
</ul>
<h1 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h1><ul>
<li><code>hexo deploy -g</code></li>
<li><code>hexo server -g</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js--Express框架的学习]]></title>
      <url>/2017/10/12/Node.js--Express%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="Express框架安装"><a href="#Express框架安装" class="headerlink" title="Express框架安装"></a>Express框架安装</h1><ul>
<li><code>npm install -g express</code></li>
<li><code>npm install -g express-generator</code>安装Express项目生成器</li>
</ul>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><ul>
<li>创建文件名为demo的项目<ul>
<li><code>express --view=ejs demo</code></li>
<li>cd demo</li>
<li>npm install</li>
</ul>
</li>
</ul>
<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><ul>
<li><code>npm start</code></li>
<li>启动文件是/bin/www，默认端口：3000</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Node.js </category>
            
            <category> Express </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Express </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js学习--HTTP模块]]></title>
      <url>/2017/10/12/Node.js%E5%AD%A6%E4%B9%A0--HTTP%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h1><ul>
<li>什么是I/O?<ul>
<li>指的的是磁盘的读入和读出input/output</li>
</ul>
</li>
<li>什么是单线程/多线程<ul>
<li>单线程：只有一个线程，代码顺序执行，容易出现代码阻塞</li>
<li>多线程：有多个线程，线程间独立运行，能有效地避免代码阻塞，并且提高程序的运行性能，但是要注意资源分配</li>
</ul>
</li>
<li>什么是阻塞/非阻塞<ul>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。做某件事情，直到完成，除非超时</li>
<li>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。尝试做，如果不能做，就不做（直接返回），如果能做，就做。</li>
</ul>
</li>
<li>什么是事件驱动<ul>
<li>为某个事件注册了函数，但是这个函数不是马上执行，只有事件发生才会调用该函数，这种函数的执行方式就叫做事件驱动。</li>
</ul>
</li>
<li>什么是基于事件驱动的回调<ul>
<li>注册的回调函数的执行方式是事件驱动</li>
</ul>
</li>
<li>执行上下文<ul>
<li>this的指向问题，当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文就构成了一个执行上下文栈</li>
<li><code>call</code>和<code>apply</code>方法能改变上下文，改变了this的指向。</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> HTTP模块 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chrome浏览器的命令]]></title>
      <url>/2017/10/11/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="Chrome浏览器的命令"><a href="#Chrome浏览器的命令" class="headerlink" title="Chrome浏览器的命令"></a>Chrome浏览器的命令</h1><ul>
<li><code>chrome://about</code>显示所有的命令</li>
<li><code>chrome://net-internals</code>抓保工具和DNS管理</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Chrome浏览器 </tag>
            
            <tag> Chrome浏览器命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js学习--URL模块]]></title>
      <url>/2017/10/11/Node.js%E5%AD%A6%E4%B9%A0-URL%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="URL模块"><a href="#URL模块" class="headerlink" title="URL模块"></a>URL模块</h1><ul>
<li>url模块提供了两套API处理URL，一套是NOde.js特有的API，另一个是WHATWG URL 规范提供的API,Node.js官方推荐使用WHATWG URLAPI</li>
</ul>
<h2 id="WHATWG-URL规范API解析url字符串"><a href="#WHATWG-URL规范API解析url字符串" class="headerlink" title="WHATWG URL规范API解析url字符串"></a>WHATWG URL规范API解析url字符串</h2><ul>
<li>在浏览器中，WHATWG URL在全局总是可用的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const &#123;URL&#125; = require(&apos;url);</div><div class="line">let myURL = new URL(&apos;https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;);</div><div class="line">console.log(myURL);</div><div class="line">//得到结果</div><div class="line">URL &#123;</div><div class="line">  href: &apos;https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;,</div><div class="line">  origin: &apos;https://sub.host.com:8080&apos;,</div><div class="line">  protocol: &apos;https:&apos;,</div><div class="line">  username: &apos;user&apos;,</div><div class="line">  password: &apos;pass&apos;,</div><div class="line">  host: &apos;sub.host.com:8080&apos;,</div><div class="line">  hostname: &apos;sub.host.com&apos;,</div><div class="line">  port: &apos;8080&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  search: &apos;?query=string&apos;,</div><div class="line">  searchParams: URLSearchParams &#123; &apos;query&apos; =&gt; &apos;string&apos; &#125;,</div><div class="line">  hash: &apos;#hash&apos; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="URL-parse-解析网址"><a href="#URL-parse-解析网址" class="headerlink" title="URL.parse()解析网址"></a>URL.parse()解析网址</h2><ul>
<li>在Node.js中，任何情况下打开 或使用一个链接都必须事先引用’url’模块：<code>require(&#39;url&#39;).URL</code>，通过Node.js提供的API解析一个URL:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const url require(&apos;url&apos;);</div><div class="line">let myURL = url.parse(&apos;http://www.imooc.com:8080/video/6710?from=scott&amp;course=node#floor1&apos;)</div><div class="line">console.log(myURL);</div><div class="line">//得到结果</div><div class="line">Url &#123;</div><div class="line">  protocol: &apos;http:&apos;,             //使用的协议</div><div class="line">  slashes: true,                 //是否有协议的双斜线</div><div class="line">  auth: null,                    //</div><div class="line">  host: &apos;www.imooc.com:8080&apos;,    //ip地址(域名)</div><div class="line">  port: &apos;8080&apos;,                  //端口</div><div class="line">  hostname: &apos;www.imooc.com&apos;,     //主机名</div><div class="line">  hash: &apos;#floor1&apos;,               //锚点内容</div><div class="line">  search: &apos;?from=scott&amp;course=node&apos;,   //查询字符串参数</div><div class="line">  query: &apos;from=scott&amp;course=node&apos;,     //发送给服务器的数据，参数</div><div class="line">  pathname: &apos;/video/6710&apos;,             //访问资源的路径名 </div><div class="line">  path: &apos;/video/6710?from=scott&amp;course=node&apos;, //路径</div><div class="line">  href: &apos;http://www.imooc.com:8080/video/6710?from=scott&amp; course=node#floor1&apos;  //完整的超链接统一资源定位符</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="URLSearchParams-API接口"><a href="#URLSearchParams-API接口" class="headerlink" title="URLSearchParams API接口"></a>URLSearchParams API接口</h2><ul>
<li>接口提供对URLquery(查询字符串)部分的读写权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const &#123; URL, URLSearchParams &#125; = require(&apos;url&apos;);</div><div class="line">const myURL = new URL(&apos;https://example.org/?abc=123&apos;);</div><div class="line"></div><div class="line">const newSeachParams =  new URLSearchParams(myURL.searchParams);</div><div class="line"></div><div class="line">//实例化成URLSearchParams对象</div><div class="line">console.log(newSeachParams); //URLSearchParams &#123; &apos;abc&apos; =&gt; &apos;123&apos; &#125;</div><div class="line"></div><div class="line">newSeachParams.append(&apos;a&apos;,&apos;c&apos;);</div><div class="line">console.log(newSeachParams); //URLSearchParams &#123; &apos;abc&apos; =&gt; &apos;123&apos;, &apos;a&apos; =&gt; &apos;c&apos; &#125;</div><div class="line">console.log(newSeachParams.toString()); //abc=123&amp;a=c</div><div class="line"></div><div class="line">newSeachParams.delete(&apos;a&apos;);</div><div class="line">console.log(newSeachParams); //URLSearchParams &#123; &apos;abc&apos; =&gt; &apos;123&apos; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="url-domainToASCII-domain"><a href="#url-domainToASCII-domain" class="headerlink" title="url.domainToASCII(domain)"></a>url.domainToASCII(domain)</h2><ul>
<li>返回Punycode ASCII序列化的域名，如果domain是无效域名，将返回空字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const url = require(&apos;url&apos;);</div><div class="line">console.log(url.domainToUnicode(&apos;汤国斌.com&apos;)); //xn--vcss25ae8e.com</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="url-domainToUnicode-domain"><a href="#url-domainToUnicode-domain" class="headerlink" title="url.domainToUnicode(domain)"></a>url.domainToUnicode(domain)</h2><ul>
<li>返回Unicode序列化的domain. 如果domain是无效域名，将返回空字符串。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> URL模块 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm包的开发及发布]]></title>
      <url>/2017/10/10/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h1><ul>
<li>这是一个ES5的方法，可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</li>
<li><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。</p>
<ul>
<li><p>数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的；即设置了value属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;name:&apos;vue&apos;&#125;;</div><div class="line">Object.defineProperty(obj,&apos;age&apos;,&#123;</div><div class="line">    value:3,</div><div class="line">    writable:true,</div><div class="line">    enumerable:true,</div><div class="line">    configurable:true</div><div class="line">&#125;)</div><div class="line">o.age = 4;</div><div class="line">console.log(o.age); //4</div></pre></td></tr></table></figure>
</li>
<li><p>存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;name:&apos;vue&apos;&#125;;</div><div class="line">let bValue;</div><div class="line">Object.defineProperty(obj,&apos;b&apos;,&#123;</div><div class="line">    get:function() &#123;</div><div class="line">        console.log(&apos;获取&apos;);</div><div class="line">        return bValue;</div><div class="line">    &#125;,</div><div class="line">    set:function (newValue) &#123;</div><div class="line">        console.log(&apos;设置&apos;);</div><div class="line">        bValue = newValue</div><div class="line">    &#125;,</div><div class="line">    enumerable:true,</div><div class="line">    configruable:true</div><div class="line">&#125;)</div><div class="line">0.b = &apos;something&apos;;</div><div class="line">console.log(o.b);</div><div class="line">console.log(bValue);</div><div class="line">// 4</div><div class="line">//设置</div><div class="line">//获取</div><div class="line">//something</div><div class="line">//something</div></pre></td></tr></table></figure>
</li>
<li><p>设置了value属性就不能设置getter-setter函数</p>
</li>
</ul>
</li>
<li>数据描述符和存取描述符均具有以下可选键值<ul>
<li>configurable<ul>
<li>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</li>
</ul>
</li>
<li>enumerable<ul>
<li>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</li>
</ul>
</li>
<li>value<ul>
<li>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</li>
</ul>
</li>
<li>writable<ul>
<li>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</li>
</ul>
</li>
</ul>
</li>
<li>存取描述符同时具有以下可选键值<ul>
<li>get<ul>
<li>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</li>
</ul>
</li>
<li>set<ul>
<li>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm包的开发及发布]]></title>
      <url>/2017/10/10/npm%E5%8C%85%E7%9A%84%E5%BC%80%E5%8F%91%E5%8F%8A%E5%8F%91%E5%B8%83/</url>
      <content type="html"><![CDATA[<h2 id="npm创建"><a href="#npm创建" class="headerlink" title="npm创建"></a>npm创建</h2><ul>
<li><code>npm init</code><ul>
<li>name：填写你这个包的名字，默认是你这个文件夹的名字。不过这里要着重说一下，最好先去npm上找一下有没有同名的包。最好的测试方式就是，在命令行里面输入npm install 你要取的名字，如果报错，那么很好，npm上没有跟你同名的包，你可以放心大胆地把包发布出去.</li>
<li>version：你这个包的版本，默认是1.0.0，以后要在package.json文件中更改版本号才能重新发布npm包</li>
<li>description：用一句话描述你的包是干嘛用的。</li>
<li>entry point：入口文件，默认是Index.js，你也可以自己填写你自己的文件名</li>
<li>test command：测试命令，这个直接回车就好了，因为目前还不需要这个。</li>
<li>git repository：这个是git仓库地址，如果你的包是先放到github上或者其他git仓库里，这时候你的文件夹里面会存在一个隐藏的.git目录，npm会读到这个目录作为这一项的默认值。如果没有的话，直接回车继续。</li>
<li>keyword：这个是一个重点，这个关系到有多少人会搜到你的npm包。尽量使用贴切的关键字作为这个包的索引。</li>
<li>author：写你的账号或者你的github账号吧</li>
<li>license：开源文件<a id="more"></a>
<h2 id="npm包的开发"><a href="#npm包的开发" class="headerlink" title="npm包的开发"></a>npm包的开发</h2></li>
</ul>
</li>
</ul>
<h2 id="npm包的发布"><a href="#npm包的发布" class="headerlink" title="npm包的发布"></a>npm包的发布</h2><ul>
<li>本地登录npm账号<code>npm login</code>,输入账户，密码，邮箱</li>
<li>发布<code>npm publish</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端构建生态 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Stylus的使用]]></title>
      <url>/2017/09/25/Stylus%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="Less安装"><a href="#Less安装" class="headerlink" title="Less安装"></a>Less安装</h1><ul>
<li><code>npm install less -g</code>全局安装less,webStorm编辑器的插件会将less编译为css</li>
<li><p>浏览器直接使用less</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//.less 样式表的链接，并将 rel 属性设置为 &quot;stylesheet/less&quot; 在 less.js 之前加载样式表。</div><div class="line">&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;./index.less&quot;&gt;</div><div class="line">// 使用`less.js`插件解析less</div><div class="line">&lt;script src=&quot;http://cdn.bootcss.com/less.js/1.7.0/less.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在vue框架中使用less,安装npm包<code>npm install --save-dev less less-loader</code></p>
</li>
</ul>
<h1 id="Less的语法"><a href="#Less的语法" class="headerlink" title="Less的语法"></a>Less的语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>将常用的值定义在一个地方</li>
<li>定义常用选择器<code>@mySelector:banner;</code></li>
<li></li>
</ul>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
            <category> CSS预处理器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Stylus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sass的使用]]></title>
      <url>/2017/09/25/Sass%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> CSS </category>
            
            <category> CSS预处理器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Sass </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Less的使用]]></title>
      <url>/2017/09/25/Less%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> CSS </category>
            
            <category> CSS预处理器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Less </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序开发]]></title>
      <url>/2017/09/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="小程序的基本文件功能"><a href="#小程序的基本文件功能" class="headerlink" title="小程序的基本文件功能"></a>小程序的基本文件功能</h1><ul>
<li><code>.js</code>后缀的是脚本文件,<code>.json</code>后缀的文件是配置文件,<code>.wxss</code>后缀的是样式表文件</li>
<li>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量</li>
<li>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</li>
<li>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则</li>
</ul>
<h1 id="小程序模板的使用"><a href="#小程序模板的使用" class="headerlink" title="小程序模板的使用"></a>小程序模板的使用</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><ul>
<li>在template文件目录下定义<code>template.wxml</code>文件</li>
<li><p>使用 name 属性，作为模板的名字。然后在<code>&lt;template/&gt;</code>内定义代码片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template name=&quot;msgItem&quot;&gt;</div><div class="line">  &lt;view&gt;</div><div class="line">    &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;</div><div class="line">    &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;</div><div class="line">  &lt;/view&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>使用模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 引入模板</div><div class="line">&lt;import src=&apos;./template/template.wxml&apos;&gt;</div><div class="line"></div><div class="line">&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="小程序请求用户的信息"><a href="#小程序请求用户的信息" class="headerlink" title="小程序请求用户的信息"></a>小程序请求用户的信息</h1><h1 id="小程序开发遇到的坑"><a href="#小程序开发遇到的坑" class="headerlink" title="小程序开发遇到的坑"></a>小程序开发遇到的坑</h1><h2 id="小程序request请求不支持cookie，所以使用cookie储存登录状态的方案不可行"><a href="#小程序request请求不支持cookie，所以使用cookie储存登录状态的方案不可行" class="headerlink" title="小程序request请求不支持cookie，所以使用cookie储存登录状态的方案不可行"></a>小程序<code>request</code>请求不支持cookie，所以使用cookie储存登录状态的方案不可行</h2><ul>
<li>造成的问题： http请求header不携带设备信息，服务器无法获取。服务器通过session来识别客服端,小程序<code>request</code>请求不能使用cookie,导致每次请求的session都不同。</li>
<li>解决：小程序支持自定义cookie，通过后台服务器与小程序的关联的接口，获取一次session，之后封装小程序的<code>request</code>请求，在session有效期内每次请求发送给后台的session都一至。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">request: function(url, meth, data, cb) &#123;</div><div class="line">    let that = this;</div><div class="line">    wx.request(&#123;</div><div class="line">      url: url,</div><div class="line">      method: meth,</div><div class="line">      data: data,</div><div class="line">      header: &#123;</div><div class="line">        &quot;Cookie&quot;: that.globalData.Cookie,</div><div class="line">      &#125;,</div><div class="line">      success: function (res) &#123;</div><div class="line">        //session过期</div><div class="line">        if (res.data.code == 403) &#123;</div><div class="line">          wx.login(&#123;</div><div class="line">            success: res =&gt; &#123;</div><div class="line">              if (res.code) &#123;</div><div class="line">                wx.request(&#123;</div><div class="line">                  url: that.globalData.baseUrl + that.globalData.api.getSession,</div><div class="line">                  method: &apos;GET&apos;,</div><div class="line">                  data: &#123;</div><div class="line">                    code: res.code</div><div class="line">                  &#125;,</div><div class="line">                  header: &#123;</div><div class="line">                    &quot;Cookie&quot;: that.globalData.Cookie,</div><div class="line">                  &#125;,</div><div class="line">                  success: function (res) &#123;</div><div class="line">                    //重新获取session</div><div class="line">                    that.globalData.Cookie = &apos;JSESSIONID=&apos; + res.data.sessionId;</div><div class="line">                    that.request();</div><div class="line">                  &#125;,</div><div class="line">                &#125;);</div><div class="line">              &#125; else &#123;</div><div class="line">                console.log(&apos;获取用户登录态失败！&apos; + res.errMsg)</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;)</div><div class="line">          return false;</div><div class="line">        &#125; else if (res.data.code == 500) &#123;</div><div class="line">          wx.showModal(&#123;</div><div class="line">            content: &apos;服务器繁忙, 请稍后再试&apos;,</div><div class="line">          &#125;)</div><div class="line">          console.log(res.data.msg||&apos;&apos;);</div><div class="line">          return false;</div><div class="line">        &#125;</div><div class="line">        cb(res);</div><div class="line">      &#125;,</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="小程序地图"><a href="#小程序地图" class="headerlink" title="小程序地图"></a>小程序地图</h2><ul>
<li>遇到的问题:根据地址名称在小程序地图上展示该位置</li>
<li>使用微信小程序JavaScript SDK<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 引入SDK核心类</div><div class="line">var QQMapWX = require(&apos;xxx/qqmap-wx.js&apos;);</div><div class="line"> </div><div class="line">// 实例化API核心类</div><div class="line">var demo = new QQMapWX(&#123;</div><div class="line">    key: &apos;开发密钥（key）&apos; // 必填</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 调用接口</div><div class="line">demo.geocoder(&#123;</div><div class="line">    address: &apos;北京市海淀区彩和坊路海淀西大街74号&apos;,</div><div class="line">    success: function(res) &#123;</div><div class="line">        console.log(res);</div><div class="line">    &#125;,</div><div class="line">    fail: function(res) &#123;</div><div class="line">        console.log(res);</div><div class="line">    &#125;,</div><div class="line">    complete: function(res) &#123;</div><div class="line">        console.log(res);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
            <category> 微信小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信公众号网页开发]]></title>
      <url>/2017/09/21/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
            <category> 微信公众号 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 微信公众号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript--作用域]]></title>
      <url>/2017/09/18/ECMAScript-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[微信JS-SDK的使用]]></title>
      <url>/2017/09/18/%E5%BE%AE%E4%BF%A1JS-SDK%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>微信JS-SDK是微信提供的一套调用微信内部API功能的的插件</li>
</ul>
<h2 id="JS-SDK使用"><a href="#JS-SDK使用" class="headerlink" title="JS-SDK使用"></a>JS-SDK使用</h2><ol>
<li>域名绑定</li>
<li>引入JS<ul>
<li><code>html</code>文件中直接引入JS文件<code>http://res.wx.qq.com/open/js/jweixin-1.2.0.js</code></li>
<li>vue单页面项目使用：<ul>
<li>安装<code>npm install --save weixin-js-sdk</code></li>
<li>组件中使用<code>import wx from &#39;weixin-js-sdk&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>通过config接口注入权限验证配置</p>
<ul>
<li>通过后台提供的接口设置<code>config</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wx.config(&#123;</div><div class="line">    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</div><div class="line">    appId: &apos;&apos;, // 必填，公众号的唯一标识</div><div class="line">    timestamp: , // 必填，生成签名的时间戳</div><div class="line">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串</div><div class="line">    signature: &apos;&apos;,// 必填，签名，见附录1</div><div class="line">    jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过ready接口处理成功验证<code>wx.ready(function(){})</code></p>
<ul>
<li>vue单页面项目<code>wx.ready</code>写在主组件里面</li>
</ul>
</li>
<li><p>通过error接口处理失败验证<code>wx.error(function(res){})</code></p>
</li>
</ol>
<p>##接口调用说明</p>
<ul>
<li>所有接口通过wx对象(也可使用jWeixin对象)来调用，参数是一个对象，除了每个接口本身需要传的参数之外，还有以下通用参数<ol>
<li>success：接口调用成功时执行的回调函数。</li>
<li>fail：接口调用失败时执行的回调函数。</li>
<li>complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。</li>
<li>cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。</li>
<li>trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。<code>备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回</code></li>
</ol>
</li>
</ul>
<h2 id="基础接口的使用"><a href="#基础接口的使用" class="headerlink" title="基础接口的使用"></a>基础接口的使用</h2><ol>
<li><p>图片上传</p>
<ul>
<li>调用<code>wx.chooseImage</code>选择图片或拍照,再调用上传图片接口<code>wx.uploadImage</code>上传到微信服务器获取到<code>serverId</code>，最后调用后台接口上传到公司服务器，根据后台返回的<code>imgURl</code>在页面显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//示例</div><div class="line">wx.chooseImage(&#123;</div><div class="line">        count: 1,</div><div class="line">        sizeType: [&apos;original&apos;, &apos;compressed&apos;],</div><div class="line">        sourceType: [&apos;album&apos;, &apos;camera&apos;],</div><div class="line">        success: function (res) &#123;</div><div class="line">          let localId = res.localIds.toString();</div><div class="line">          wx.uploadImage(&#123;</div><div class="line">            localId: localId,</div><div class="line">            isShowProgressTips: 1,</div><div class="line">            success: function (res) &#123;</div><div class="line">              var serverId = res.serverId; // 返回图片的服务器端ID</div><div class="line">              let parms = &#123;</div><div class="line">                mediaid:serverId</div><div class="line">              &#125;</div><div class="line">              that.imgBoxWrapShow = true;</div><div class="line">              imgUpload(parms).then( res =&gt; &#123;</div><div class="line">                let &#123;code,msg,data&#125; = res;</div><div class="line">                if(code!==0) &#123;</div><div class="line">                  alert(msg);</div><div class="line">                  that.imgBoxWrapShow = false;</div><div class="line">                  return false;</div><div class="line">                &#125;</div><div class="line">                that.imgArr.push(data);</div><div class="line">                if(that.imgArr.length&gt;=4) &#123;</div><div class="line">                  that.uploadImgShow=false;</div><div class="line">                &#125;</div><div class="line">                that.imgBoxWrapShow = false;</div><div class="line">              &#125;)</div><div class="line">            &#125;,</div><div class="line">            fail: function() &#123;</div><div class="line">              alert(&apos;上传失败&apos;);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;,</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>禁止微信的功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//隐藏微信的功能</div><div class="line">      wx.hideMenuItems(&#123;</div><div class="line">        menuList: [</div><div class="line">          &apos;menuItem:share:qq&apos;,</div><div class="line">          &apos;menuItem:share:weiboApp&apos;,</div><div class="line">          &apos;menuItem:favorite&apos;,</div><div class="line">          &apos;menuItem:share:facebook&apos;,</div><div class="line">          &apos;menuItem:share:QZone&apos;,</div><div class="line">          &apos;menuItem:editTag&apos;,</div><div class="line">          &apos;menuItem:delete&apos;,</div><div class="line">          &apos;menuItem:copyUrl&apos;,</div><div class="line">          &apos;menuItem:originPage&apos;,</div><div class="line">          &apos;menuItem:readMode&apos;,</div><div class="line">          &apos;menuItem:openWithQQBrowser&apos;,</div><div class="line">          &apos;menuItem:openWithSafari&apos;,</div><div class="line">          &apos;menuItem:share:email&apos;,</div><div class="line">          &apos;menuItem:share:brand&apos;,</div><div class="line">          &apos;menuItem:share:appMessage&apos;,</div><div class="line">          &apos;menuItem:share:timeline&apos;</div><div class="line">        ]</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 微信公众号 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信公众号 </tag>
            
            <tag> 微信JS-SDK </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS数组的使用]]></title>
      <url>/2017/09/18/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="一、数组的基本方法"><a href="#一、数组的基本方法" class="headerlink" title="一、数组的基本方法"></a>一、数组的基本方法</h1><h2 id="arr-concat-item…"><a href="#arr-concat-item…" class="headerlink" title="arr.concat(item…)"></a>arr.concat(item…)</h2><ul>
<li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];</div><div class="line">var b = [1,2,3,4,5];</div><div class="line">var c = a.concat(b) // c变成[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,1,2,3,4,5];</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="arr-join-separator"><a href="#arr-join-separator" class="headerlink" title="arr.join(separator);"></a>arr.join(separator);</h2><ul>
<li><code>join()</code> 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中,默认的separator是逗号’,’,如果separator是空字符串(“”)，则所有元素之间都没有任何字符。join() 方法，不会改变数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let a = [&apos;Wind&apos;, &apos;Rain&apos;, &apos;Fire&apos;];</div><div class="line"></div><div class="line">a.join(); </div><div class="line">// 默认为 &quot;,&quot;</div><div class="line">// &apos;Wind,Rain,Fire&apos;</div><div class="line"></div><div class="line">a.join(&quot;&quot;); </div><div class="line">// 分隔符 === 空字符串 &quot;&quot;</div><div class="line">// &quot;WindRainFire&quot;</div><div class="line"></div><div class="line">a.join(&quot;-&quot;); </div><div class="line">// 分隔符 &quot;-&quot;</div><div class="line">// &apos;Wind-Rain-Fire&apos;</div><div class="line"></div><div class="line">console.log(a);</div><div class="line">// [&apos;Wind&apos;, &apos;Rain&apos;, &apos;Fire&apos;]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-pop"><a href="#array-pop" class="headerlink" title="array.pop()"></a>array.pop()</h2><ul>
<li><code>pop()</code>方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3];</div><div class="line">a.length; // 3</div><div class="line"></div><div class="line">a.pop(); // 3</div><div class="line"></div><div class="line">console.log(a); // [1, 2]</div><div class="line">a.length; // 2</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-push-item…"><a href="#array-push-item…" class="headerlink" title="array.push(item…)"></a>array.push(item…)</h2><ul>
<li><code>push()</code> 方法将一个或多个元素添加到数组的末尾，并返回新数组的长度,如果参数item是一个数组，它会把参数组作为单个元素整个添加到数组中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 2, 3];</div><div class="line">numbers.push(4);</div><div class="line"></div><div class="line">console.log(numbers); </div><div class="line">// [1, 2, 3, 4]</div><div class="line"></div><div class="line">numbers.push([5, 6, 7]);</div><div class="line"></div><div class="line">console.log(numbers); </div><div class="line">// [1, 2, 3, 4, [5, 6, 7]]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array.reverse()"></a>array.reverse()</h2><ul>
<li><code>reverse</code>方法反转array里的元素的顺序，并返回array本身<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a =[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var b = a.reverse();</div><div class="line">console.log(a)  //[&apos;c&apos;,&apos;b&apos;,&apos;a&apos;]</div><div class="line">console.log(b)  //[&apos;c&apos;,&apos;b&apos;,&apos;a&apos;]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-shift"><a href="#array-shift" class="headerlink" title="array.shift()"></a>array.shift()</h2><ul>
<li><code>shift()</code> 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3];</div><div class="line">let b = a.shift();</div><div class="line"></div><div class="line">console.log(a); </div><div class="line">// [2, 3]</div><div class="line"></div><div class="line">console.log(b); </div><div class="line">// 1</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-unshift-item…"><a href="#array-unshift-item…" class="headerlink" title="array.unshift(item…)"></a>array.unshift(item…)</h2><ul>
<li><code>unshift</code> 方法将一个或多个元素添加到数组的开头，并返回新数组的长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3];</div><div class="line">a.unshift(4, 5);</div><div class="line"></div><div class="line">console.log(a);</div><div class="line">// [4, 5, 1, 2, 3]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-slice-begin-end"><a href="#array-slice-begin-end" class="headerlink" title="array.slice(begin,end)"></a>array.slice(begin,end)</h2><ul>
<li><code>slice()</code> 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，原始数组不会被修改。</li>
<li>参数begin(可选)：从该索引处开始提取原数组中的元素，如果该参数是负数，则表示从原数组中的倒数第几位元素开始提取(slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素，包含最后一个元素),如果省略begin则索引从0开始</li>
<li><p>参数end(可选)：如果 end 被省略，则slice 会一直提取到原数组末尾,如果 end 大于数组长度，slice 也会一直提取到原数组末尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arr.slice();</div><div class="line">// [0, end]</div><div class="line"></div><div class="line">arr.slice(begin);</div><div class="line">// [begin, end]</div><div class="line"></div><div class="line">arr.slice(begin, end);</div><div class="line">// [begin, end)</div></pre></td></tr></table></figure>
</li>
<li><p>slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组,如<code>arguments</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function list() &#123;</div><div class="line">  return Array.prototype.slice.call(arguments); // return [].slice.call(arguments);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="array-splice-start"><a href="#array-splice-start" class="headerlink" title="array.splice(start)"></a>array.splice(start)</h2><ul>
<li><code>splice()</code> 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。返回一个包含被移除元素的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.splice(start)</div><div class="line"></div><div class="line">array.splice(start, deleteCount) </div><div class="line"></div><div class="line">array.splice(start, deleteCount, item1, item2, ...)</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;sturgeon&apos;];</div><div class="line"></div><div class="line">myFish.splice(2, 0, &apos;drum&apos;); // 在索引为2的位置插入&apos;drum&apos;</div><div class="line">// myFish 变为 [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]</div><div class="line"></div><div class="line">myFish.splice(2, 1); // 从索引为2的位置删除一项（也就是&apos;drum&apos;这一项）</div><div class="line">// myFish 变为 [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]</div></pre></td></tr></table></figure>
<h2 id="array-sort-comparefn"><a href="#array-sort-comparefn" class="headerlink" title="array.sort(comparefn)"></a>array.sort(comparefn)</h2><ul>
<li><code>sort</code>方法 默认排序顺序是根据字符串Unicode码点，如果指明了<code>comparefn</code>，那么数组会按照调用该函数的返回值排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 比较数组数组</div><div class="line">var numbers = [4, 2, 5, 1, 3];</div><div class="line">numbers.sort(function(a, b) &#123;</div><div class="line">  return a - b;</div><div class="line">&#125;);</div><div class="line">console.log(numbers);</div><div class="line"></div><div class="line">// [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、ES5数组方法"><a href="#二、ES5数组方法" class="headerlink" title="二、ES5数组方法"></a>二、ES5数组方法</h2><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><ul>
<li><p>forEach() 方法对数组的每个元素执行一次提供的函数,遍历数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line"></div><div class="line">arr.forEach(function(item,index) &#123;</div><div class="line">    console.log(item) //数组的每一项</div><div class="line">    console.log(index) //数组的索引</div><div class="line">&#125;)</div><div class="line">arr.forEach( (item,index) =&gt; console.log(index+&apos;:&apos;+item));</div><div class="line"></div><div class="line">// 0:a</div><div class="line">// 1:b</div><div class="line">// 2:c</div></pre></td></tr></table></figure>
</li>
<li><p>语法：</p>
<ul>
<li><code>callback</code>:为数组中每个元素执行的函数，该函数接收三个参数</li>
<li><code>currentValue</code>(当前值):数组中正在处理的当前元素</li>
<li><code>index(索引)</code>:数组中正在处理的当前元素的索引</li>
<li><code>array</code>:forEach()方法正在操作的数组</li>
<li><code>thisArg</code>(可选):可选参数。当执行回调 函数时用作this的值(参考对象)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, this)</div><div class="line"></div><div class="line">array.forEach(callback[, thisArg])</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用thisArg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    this.sum = 0;</div><div class="line">    this.count = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Counter.prototype.add = function(array) &#123;</div><div class="line">    array.forEach(function(entry) &#123;</div><div class="line">        this.sum += entry;</div><div class="line">        ++this.count;</div><div class="line">    &#125;, this);</div><div class="line">    //console.log(this);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var obj = new Counter();</div><div class="line">obj.add([1, 3, 5, 7]);</div><div class="line"></div><div class="line">obj.count; </div><div class="line">// 4 === (1+1+1+1)</div><div class="line">obj.sum;</div><div class="line">// 16 === (1+3+5+7)</div></pre></td></tr></table></figure>
</li>
<li><p>forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2></li>
<li><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回一个新数组，每个元素都是回调函数的结果。map 不修改调用它的原数组本身<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">let numbers = [1, 5, 10, 15];</div><div class="line">let doubles = numbers.map( x =&gt; x ** 2);</div><div class="line"></div><div class="line">// doubles is now [1, 25, 100, 225]</div><div class="line">// numbers is still [1, 5, 10, 15]</div><div class="line"></div><div class="line"></div><div class="line">const numbers = [2, 4, 8, 10];</div><div class="line">let halves = numbers.map(x =&gt; x / 2);</div><div class="line"></div><div class="line">let numbers = [1, 4, 9];</div><div class="line">let roots = numbers.map(Math.sqrt);</div><div class="line">// roots is now [1, 2, 3]</div><div class="line">// numbers is still [1, 4, 9]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><ul>
<li><code>filter()</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素,filter不会改变原数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(value) &#123;</div><div class="line">  return value &gt;= 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);</div><div class="line"></div><div class="line">// filtered is [12, 130, 44]</div><div class="line"></div><div class="line">// ES6 way</div><div class="line"></div><div class="line">const isBigEnough = value =&gt; value &gt;= 10;</div><div class="line"></div><div class="line">let [...spraed]= [12, 5, 8, 130, 44];</div><div class="line"></div><div class="line">let filtered = spraed.filter(isBigEnough);</div><div class="line"></div><div class="line">// filtered is [12, 130, 44]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><ul>
<li><code>some()</code> 方法测试数组中的某些元素是否通过由提供的函数实现的测试(即寻找数组中是否有符合条件的值),返回布尔值(符合ture,否则false),不会改变原数组。</li>
<li>some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const isBiggerThan10 = (element, index, array) =&gt; &#123;</div><div class="line">  return element &gt; 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[2, 5, 8, 1, 4].some(isBiggerThan10);  </div><div class="line">// false</div><div class="line"></div><div class="line">[12, 5, 8, 1, 4].some(isBiggerThan10); </div><div class="line">// true</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><ul>
<li><code>every()</code> 方法测试数组的所有元素是否都通过了指定函数的测试</li>
<li>为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//检测数组中的所有元素是否都大于 10</div><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [12, 5, 8, 130, 44].every(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 54, 18, 130, 44].every(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><ul>
<li><code>indexOf()</code>方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9];</div><div class="line">array.indexOf(2);     // 0</div><div class="line">array.indexOf(7);     // -1</div><div class="line">array.indexOf(9, 2);  // 2</div><div class="line">array.indexOf(2, -1); // -1</div><div class="line">array.indexOf(2, -3); // 0</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h2><ul>
<li>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9, 2];</div><div class="line">var index = array.lastIndexOf(2);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(7);</div><div class="line">// index is -1</div><div class="line">index = array.lastIndexOf(2, 3);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(2, 2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -1);</div><div class="line">// index is 3</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="isArray"><a href="#isArray" class="headerlink" title="isArray()"></a>isArray()</h2><ul>
<li><code>Array.isArray()</code> 用于确定传递的值是否是一个 Array。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 下面的函数调用都返回 true</div><div class="line">Array.isArray([]);</div><div class="line">Array.isArray([1]);</div><div class="line">Array.isArray(new Array());</div><div class="line">// 鲜为人知的事实：其实 Array.prototype 也是一个数组。</div><div class="line">Array.isArray(Array.prototype); </div><div class="line"></div><div class="line">// 下面的函数调用都返回 false</div><div class="line">Array.isArray();</div><div class="line">Array.isArray(&#123;&#125;);</div><div class="line">Array.isArray(null);</div><div class="line">Array.isArray(undefined);</div><div class="line">Array.isArray(17);</div><div class="line">Array.isArray(&apos;Array&apos;);</div><div class="line">Array.isArray(true);</div><div class="line">Array.isArray(false);</div><div class="line">Array.isArray(&#123; __proto__: Array.prototype &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>#三、ES6新增数组方法</p>
<h2 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike, mapFn, thisArg)"></a>Array.from(arrayLike, mapFn, thisArg)</h2><ul>
<li><p><code>Array.from()</code> 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const bar = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</div><div class="line">Array.from(bar);</div><div class="line">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line"></div><div class="line">Array.from(&apos;foo&apos;);</div><div class="line">// [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</div></pre></td></tr></table></figure>
</li>
<li><p><code>Array.from(arguments)</code> 可以代替<code>Array.prototype.slice.call(arguments)</code>将类数组转换成一个数组</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mockServer的搭建]]></title>
      <url>/2017/09/18/mockServer%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="使用json-server模拟服务器"><a href="#使用json-server模拟服务器" class="headerlink" title="使用json-server模拟服务器"></a>使用json-server模拟服务器</h1><h3 id="mockServer的思路"><a href="#mockServer的思路" class="headerlink" title="mockServer的思路"></a>mockServer的思路</h3><ul>
<li>以 <code>json-server</code> 作为 mock 服务器， <code>mock.js</code> 生成 mock 数据，以此达到 <code>mock-server</code> 要求。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>全局安装<code>npm install -g json-server</code></li>
<li>项目安装<code>npm install --save-dev json-server</code></li>
<li>安装<code>mock.js</code>快速创建模拟接口 <code>npm install --save-dev mock.js</code></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>在项目根目录下创建mock文件夹</li>
<li>再分别创建<code>db.js</code>作为 mock 数据源、<code>router.js</code>作为 mock 服务、<code>server.js</code>重写路由表</li>
<li><code>db.js</code>配置接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// db.js</div><div class="line">var Mock = require(&apos;mockjs&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">  getComment: Mock.mock(&#123;</div><div class="line">    &quot;error&quot;: 0,</div><div class="line">    &quot;message&quot;: &quot;success&quot;,</div><div class="line">    &quot;result|40&quot;: [&#123;</div><div class="line">      &quot;author&quot;: &quot;@name&quot;,</div><div class="line">      &quot;comment&quot;: &quot;@cparagraph&quot;,</div><div class="line">      &quot;date&quot;: &quot;@datetime&quot;</div><div class="line">    &#125;]</div><div class="line">  &#125;),</div><div class="line">  addComment: Mock.mock(&#123;</div><div class="line">    &quot;error&quot;: 0,</div><div class="line">    &quot;message&quot;: &quot;success&quot;,</div><div class="line">    &quot;result&quot;: []</div><div class="line">  &#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>通过路由表<code>routes.js</code>实现路由配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  &quot;/comment/get.action&quot;: &quot;/getComment&quot;,</div><div class="line">  &quot;/comment/add.action&quot;: &quot;/addComment&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>server.js</code>正式使用<code>json-server</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// server.js</div><div class="line">const jsonServer = require(&apos;json-server&apos;)</div><div class="line">const db = require(&apos;./db.js&apos;)</div><div class="line">const routes = require(&apos;./router.js&apos;)</div><div class="line">const port = 3000;</div><div class="line">const opn = require(&apos;opn&apos;)</div><div class="line"></div><div class="line">const server = jsonServer.create()</div><div class="line">const router = jsonServer.router(db)</div><div class="line">const middlewares = jsonServer.defaults()</div><div class="line">const rewriter = jsonServer.rewriter(routes)</div><div class="line"></div><div class="line">let url = &apos;http://localhost:&apos; + port</div><div class="line"></div><div class="line">server.use(middlewares)</div><div class="line">// 将 POST 请求转为 GET</div><div class="line">server.use((request, res, next) =&gt; &#123;</div><div class="line">  request.method = &apos;GET&apos;;</div><div class="line">  next();</div><div class="line">&#125;)</div><div class="line"></div><div class="line">server.use(rewriter) // 注意：rewriter 的设置一定要在 router 设置之前</div><div class="line">server.use(router)</div><div class="line"></div><div class="line">server.listen(port, () =&gt; &#123;</div><div class="line">  console.log(&apos;open mock server at localhost:&apos; + port)</div><div class="line">  opn(url);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>在<code>package.json</code>中配置命令<ul>
<li>配置mockServer启动<code>&quot;mockServer&quot;: &quot;node mock/server.js&quot;</code></li>
<li>配置mockServer和项目一起启动<code>&quot;mock&quot;: &quot;npm run mockServer | npm run dev&quot;</code></li>
</ul>
</li>
<li>调用命令启动项目和mockServer<code>npm run mock</code></li>
</ol>
<h3 id="端口代理"><a href="#端口代理" class="headerlink" title="端口代理"></a>端口代理</h3><ul>
<li><p>通过 Webpack 配置 proxy 代理,vue-cli创建的项目在<code>config/index.js</code>中配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//配置代理</div><div class="line">proxyTable: &#123;</div><div class="line">  &apos;/api/&apos;: &#123;</div><div class="line">    target: &apos;http://localhost:3000&apos;,</div><div class="line">    changeOrigin: true,</div><div class="line">    pathRewrite: &#123;</div><div class="line">      &apos;^/api&apos;: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
<li><p>接口请求案例,以 axios 为例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function getComments () &#123;</div><div class="line">  axios.get(&apos;api/comment/get.action&apos;, &#123;&#125;).then((res) =&gt; &#123;</div><div class="line">    console.log(res.data)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端构建生态 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mockServer </tag>
            
            <tag> mock.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PS技能学习]]></title>
      <url>/2017/09/14/PS%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><ul>
<li>选中图层，通过裁剪工具裁剪指定像素，按住回车键裁剪图片，按住<code>ctrl</code>键+<code>shift</code>键+<code>alt</code>键+<code>s</code>存储为web格式</li>
</ul>
<h2 id="Photoshop界面设置"><a href="#Photoshop界面设置" class="headerlink" title="Photoshop界面设置"></a>Photoshop界面设置</h2><ul>
<li>窗口只显示字符、信息、图层、历史记录</li>
<li>视图&gt;显示勾选上智能参考线，视图 勾选上标尺</li>
</ul>
<h2 id="Photoshop基本工具操作"><a href="#Photoshop基本工具操作" class="headerlink" title="Photoshop基本工具操作"></a>Photoshop基本工具操作</h2><h3 id="移动工具设置"><a href="#移动工具设置" class="headerlink" title="移动工具设置"></a>移动工具设置</h3><ul>
<li>快捷键<code>V</code> 快速获取移动工具</li>
<li>通过<code>Ctrl</code>键+鼠标左键获取图层<h3 id="选区工具"><a href="#选区工具" class="headerlink" title="选区工具"></a>选区工具</h3></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Photoshop与切图 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PS切图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Next主体配置]]></title>
      <url>/2017/09/13/Next%E4%B8%BB%E4%BD%93%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。</p>
<p>hexo的next主题个性化配置教程: <a href="https://segmentfault.com/a/1190000009544924#articleHeader19" target="_blank" rel="external">https://segmentfault.com/a/1190000009544924#articleHeader19</a></p>
<h2 id="NexT主题安装"><a href="#NexT主题安装" class="headerlink" title="NexT主题安装"></a>NexT主题安装</h2><h3 id="下载NexT主题"><a href="#下载NexT主题" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd your-hexo-site`</div><div class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><p>修改站点配置文件_config.yml，找到以下部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line">theme: landscape</div></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line"># theme: landscape</div><div class="line">theme: next`</div></pre></td></tr></table></figure></p>
<p>至此，NexT主题就安装好了，非常方便，在Hexo中切换主题只需修改站点配置文件中theme属性来配置，想换就换。</p>
<h3 id="选择Scheme"><a href="#选择Scheme" class="headerlink" title="选择Scheme"></a>选择Scheme</h3><p>NexT 通过 Scheme 提供主题中的主题。Mist是NexT主题自带的主题，可以通过修改主题配置文件中的scheme属性获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">scheme: Mist  #去掉默认的注释即可切换为Mist主题</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h2><p>NexT主题菜单设置，用于设置博客上方导航栏，在主题配置文件中修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /                       #主页</div><div class="line">  categories: /categories	#分类页（需手动创建）</div><div class="line">  #about: /about		#关于页面（需手动创建）</div><div class="line">  archives: /archives		#归档页</div><div class="line">  tags: /tags			#标签页（需手动创建）</div><div class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</div></pre></td></tr></table></figure></p>
<p>只是在menu选项中设置还不能让标签页面、分类页面生效，需要我们手动创建</p>
<h3 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h3><ol>
<li>运行以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page &quot;tags&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>同时，在/source目录下会生成一个tags文件夹，里面包含一个index.md文件</p>
<ol>
<li><p>修改/source/tags目录下的index.md文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: tags</div><div class="line">date: 2015-09-29 14:37:02</div><div class="line">type: &quot;tags&quot;</div><div class="line">---</div></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件<br>去掉tags的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /                       #主页</div><div class="line">  categories: /categories	#分类页（需手动创建）</div><div class="line">  #about: /about		#关于页面（需手动创建）</div><div class="line">  archives: /archives		#归档页</div><div class="line">  tags: /tags			#标签页（需手动创建）</div><div class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分类页面"><a href="#分类页面" class="headerlink" title="分类页面"></a>分类页面</h3><ol>
<li><p>运行以下命令 <code>hexo new page &quot;categories&quot;</code><br>同时，在/source目录下会生成一个categories文件夹，里面包含一个index.md文件</p>
</li>
<li><p>修改/source/categories目录下的index.md文件</p>
</li>
<li><p>修改主题配置文件:去掉categories的注释</p>
</li>
</ol>
<h3 id="侧边栏头像设置"><a href="#侧边栏头像设置" class="headerlink" title="侧边栏头像设置"></a>侧边栏头像设置</h3><p>编辑站点配置文件，增加avatar字段</p>
<h1 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h1><p>avatar: /images/avatar.png<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">头像图片须放置在主题的/source/images/目录下</div><div class="line">### 搜索</div><div class="line">使用Sitemap插件 可方便管理员通知搜索引擎他们网站上有哪些可供抓取的网页，有助于让别人更好地通过搜索到自己的博客。</div><div class="line">1. sitemap安装配置 `npm install hexo-generator-sitemap --save`</div><div class="line"></div><div class="line">2. 修改站点配置文件</div></pre></td></tr></table></figure></p>
<h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><p>plugins:</p>
<ul>
<li>hexo-generator-sitemap<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用以下命令后，你可以在站点的/public目录下找到一个sitemap.xml文件，这个文件就是你的站点地图，里面包含你的站点的网页地址。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>hexo clean<br>hexo g<br>```<br>提交sitemap到google参考如何向google提交sitemap</p>
]]></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Next </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[flex布局学习]]></title>
      <url>/2017/09/12/flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="flex布局基础知识"><a href="#flex布局基础知识" class="headerlink" title="flex布局基础知识"></a>flex布局基础知识</h2><p><img src="http://ojvil4eq9.bkt.clouddn.com/17-9-12/53121912.jpg" alt=""></p>
<ul>
<li>main axis(主轴): Flex容器的主轴主要用来配置Flex项目。它不一定是水平，这主要取决于flex-direction属性</li>
<li>main-start|main-end(主轴起点|主轴终点): Flex项目的配置从容器的主轴起点开始,往主轴终点结束</li>
<li>main size(主轴方向长度):Flex项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。</li>
<li>cross axis(侧轴):与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li>
<li>cross-start | cross-end(侧轴起点|侧轴终点):伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li>
<li>cross size(侧轴方向长度):Flex项目的在侧轴方向的宽度或高度就是项目的侧轴长度，Flex项目的侧轴长度属性是width或height属性，由哪一个对着侧轴方向决定。</li>
</ul>
<h2 id="Flex容器属性-主容器"><a href="#Flex容器属性-主容器" class="headerlink" title="Flex容器属性(主容器)"></a>Flex容器属性(主容器)</h2><ol>
<li><code>display</code>: 定义一个Flex容器，根据其取的值来决定是内联还是块。Flex容器会为其内容建立新的伸缩格式化上下文。(定义成flex容器不等于定义成块级容器)</li>
<li><code>flex-direction</code>: 定义主轴方向，Flex项目在Flex容器中放置的方向<ul>
<li><code>row</code>(默认值): Flex项目从左向右排列</li>
<li><code>row-reverse</code>: 与row相反，Flex项目从右向左排列</li>
<li><code>column</code>: Flex项目从上向下排列</li>
<li><code>columne-reverse</code>: 与column相反，Flex项目从下向上排列</li>
</ul>
</li>
<li><code>flex-wrap</code>: 定义Flex项目是否多行显示<ul>
<li><code>nowrap</code>(默认值): 单行显示，从左向右排列</li>
<li><code>wrap</code>: 多行显示，从左向右排列</li>
<li><code>wrap-reverse</code>: 多行显示，从右向左排列</li>
</ul>
</li>
<li><code>flex-flow</code>: <code>flex-direction</code>和<code>flex-wrap</code>属性的缩写 默认值是row nowrap<a id="more"></a>  </li>
<li><code>justify-content</code>: 定义主轴方向的对齐方式<ul>
<li><code>flex-start</code>(默认值): Flex项目主轴起点对齐，伸缩项目向一行的起始位置靠齐。该行的第一个伸缩项目在主轴起点边的外边距与该行在主轴起点的边对齐，同时所有后续的伸缩项目与其前一个项目对齐</li>
<li><code>flex-end</code>: Flex项目主轴终点对齐，伸缩项目向一行的结束位置靠齐。该行的最后一个伸缩项目在主轴终点边的外边距与该行在主轴终点的边对齐，同时所有前面的伸缩项目与其后一个项目对齐。</li>
<li><code>center</code>: Flex项目主轴居中对齐，伸缩项目向一行的中间位置靠齐。该行的伸缩项目将相互对齐并在行中居中对齐，同时第一个项目与该行在主轴起点的边的距离等同与最后一个项目与该行在主轴终点的边的距离（如果剩余空间是负数，则保持两端溢出的长度相等）。著作权归作者所有。</li>
<li><code>space-between</code>: Flex项目主轴两端对齐，伸缩项目会平均地分布在行里。如果剩余空间是负数，或该行只有一个伸缩项目，则此值等效于flex-start。在其它情况下，第一个项目在主轴起点边的外边距会与该行在主轴起点的边对齐，同时最后一个项目在主轴终点边的外边距与该行在主轴终点的边对齐，而剩下的伸缩项目在确保两两之间的空白空间相等下平均分布。</li>
<li><code>space-around</code>: Flex项目主轴平均分布对齐，伸缩项目会平均地分布在行里，两端保留一半的空间。如果剩余空间是负数，或该行只有一个伸缩项目，则该值等效于center。在其它情况下，伸缩项目在确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半下平均分布。</li>
</ul>
</li>
<li><code>align-items</code>: 定义侧轴方向的对其方式<ul>
<li><code>flex-start</code>: flex项目侧轴起点对齐，伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边</li>
<li><code>flex-end</code>: flex项目侧轴终点对齐,伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。</li>
<li><code>center</code>: flex项目侧轴居中对齐，伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。</li>
<li><code>baseline</code>: flex项目侧轴基线对齐，如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。</li>
<li><code>stretch</code>: 如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。    </li>
</ul>
</li>
<li><code>align-content</code>: 定义Flex项目多行的对齐方式，本属性在只有一行的伸缩容器上没有效果<ul>
<li><code>flex-start</code>: 各行向伸缩容器的起点位置堆叠。伸缩容器中第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点的边，之后的每一行都紧靠住前面一行。</li>
<li><code>flex-end</code>:各行向伸缩容器的结束位置堆叠。伸缩容器中最后一行在侧轴终点的边会紧靠住该伸缩容器在侧轴终点的边，之前的每一行都紧靠住后面一行。</li>
<li><code>center</code>:各行向伸缩容器的中间位置堆叠。各行两两紧靠住同时在伸缩容器中居中对齐，保持伸缩容器在侧轴起点边的内容边和第一行之间的距离与该容器在侧轴终点边的内容边与第最后一行之间的距离相等。（如果剩下的空间是负数，则行的堆叠会向两个方向溢出的相等距离。）</li>
<li><code>space-between</code>:各行在伸缩容器中平均分布。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于flex-start。在其它情况下，第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点边的内容边，最后一行在侧轴终点的边会紧靠住伸缩容器在侧轴终点的内容边，剩余的行在保持两两之间的空间相等的状况下排列。</li>
<li><code>space-around</code>:各行在伸缩容器中平均分布，在两边各有一半的空间。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于center。在其它情况下，各行会在保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半的状况下排列。</li>
<li><code>stretch</code>(默认值):各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于flex-start。在其它情况下，剩余空间被所有行平分，扩大各行的侧轴尺寸。</li>
</ul>
</li>
</ol>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><ol>
<li><p><code>order</code>:默认值是0，Flex项目是按文档源的流顺序排列,根据order重新排序伸缩项目。有最小（负值最大）order的伸缩项目排在第一个。若有多个项目有相同的order值，这些项目照文件顺序排。这个步骤影响了伸缩项目生盒树成的盒子的顺序，也影响了后面的演算法如何处理各项目。著作权归作者所有。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">    order:&lt;number&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>flex-grow</code>: 定义一个Flex项目的扩大比例。它接受一个没有单位的值作为一个比例。它可以使用Flex项目完全占用Flex容器可用的空间。如果所有Flex项目的flex-grow设置为1时，表示Flex容器中的Flex项目具有相等的尺寸。如果你给其中一个Flex项目设置flex-grow的值为2，那么这个Flex项目的尺寸将是其他Flex项目两倍（其他Flex项目的flex-grow值为1）。flex-grow取负值将失效。</p>
</li>
<li><code>flec-shrink</code>: 可以定义Flex项目的缩小比例,flex-shrink取负值将失效。</li>
<li><code>flex-basis</code>: 定义主轴方向的长度(width|height)。定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸。main-size值使它具有匹配的宽度或高度，不过都需要取决于flex-direction的值。如果设置为0，内容不在考虑周围额外空间。如果设置为auto，额外空间会基于flex-grow值做分布。</li>
<li><code>flex</code>: 是flex-grow，flex-shrink和flex-basis三个属性的缩写。第二个和第三个参数(flex-shrink和flex-basis)是可选值。其默认值是0 1 auto。</li>
<li><code>align-self</code>: 用来在单独的伸缩项目上覆写默认的对齐方式。（对于匿名伸缩项目，align-self的值永远与其关联的伸缩容器的align-items的值相同)。<ul>
<li><code>flex-start</code>: 伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。</li>
<li><code>flex-end</code>: 伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。</li>
<li><code>center</code>: 伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。</li>
<li><code>baseline</code>:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。</li>
<li><code>stretch</code>:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123; </div><div class="line">        align-self: auto | flex-start | flex-end | center | baseline | stretch; </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flex </tag>
            
            <tag> css3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端知识体系整理]]></title>
      <url>/2017/09/12/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="前端知识分类"><a href="#前端知识分类" class="headerlink" title="前端知识分类"></a>前端知识分类</h2><ul>
<li>HTML</li>
<li>CSS</li>
<li>DOM和BOM</li>
<li>ECMAScript</li>
<li>前端构建生态</li>
<li>模块化、框架、组件</li>
<li>Node.js</li>
<li>应用工具学习</li>
<li>canvas</li>
<li>HTTP协议</li>
<li>浏览器基础</li>
<li>Photoshop与切图</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li>meta内容与设置</li>
<li>一般常用标签</li>
<li>HTML5新增语义化标签</li>
<li>HTML常用属性</li>
<li>搜索引擎优化<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2></li>
<li>css常用属性</li>
<li>css层叠概念</li>
<li>css选择器和优先级</li>
<li>盒子模型</li>
<li>css布局方式</li>
<li>编译工具less和sass</li>
<li>css实现响应式：利用媒体查询media query</li>
<li>css移动端开发：rem和em的原理和实现</li>
<li>css动画及动画库的使用</li>
<li>css的UI框架<ul>
<li>bootstrap</li>
<li>基于vue框架-PC端elm框架</li>
<li>基于vue框架-移动端vux框架</li>
</ul>
</li>
</ol>
<h2 id="DOM和BOM"><a href="#DOM和BOM" class="headerlink" title="DOM和BOM"></a>DOM和BOM</h2><ol>
<li>DOM对象document</li>
<li>DOMAPI操作</li>
<li>BOM对象的使用<a id="more"></a>
</li>
</ol>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><ol>
<li>ECMAScript基本语法</li>
<li>内置对象：RegExp、Math、Date、Error、Functio、Arguments、</li>
<li>AJAX原理与实现</li>
<li>面向对象与继承</li>
<li>原型和原型链</li>
<li>作用域和作用域链</li>
<li>执行上下文：由变量对象、this、作用域链组成</li>
<li>函数闭包使用和优缺点</li>
<li>ES6新增语法和特性</li>
</ol>
<h2 id="构建生态"><a href="#构建生态" class="headerlink" title="构建生态"></a>构建生态</h2><ul>
<li>npm、yarm包管理工具</li>
<li>gulp、webpack开发打包工具</li>
</ul>
<h2 id="模块化、框架、组件"><a href="#模块化、框架、组件" class="headerlink" title="模块化、框架、组件"></a>模块化、框架、组件</h2><ul>
<li>JQuery、zepto库的使用原理及插件开发</li>
<li>模块化规范：commonJS、AMD规范(RequireJS)和CMD规范(SeaJS)、ES6模块化规范</li>
<li>MVC、MVVM思想</li>
<li>双向数据绑定</li>
<li>Vue框架的使用原理及组件开发</li>
<li>React框架</li>
</ul>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ol>
<li>HTTP协议内容：HTTP1.0、HTTP1.1、HTTP2.0</li>
<li>HTTP请求过程</li>
<li>HTTP缓存与状态码判断过程</li>
<li>浏览器跨域问题及处理方式</li>
</ol>
<h2 id="浏览器基础"><a href="#浏览器基础" class="headerlink" title="浏览器基础"></a>浏览器基础</h2><ol>
<li>浏览器的组成<ul>
<li>用户界面：用户地址栏、前进后退按钮</li>
<li>浏览器引擎：浏览器指令解析模块</li>
<li>持久化存储：localstorage、webSQL、indexDb、cookie</li>
<li>UI后端：浏览器默认控件库</li>
<li>网络模块： 浏览器向服务器发送请求模块</li>
<li>JS解析引擎</li>
<li>浏览器渲染引擎(内核)</li>
</ul>
</li>
</ol>
<h2 id="Photoshop与切图"><a href="#Photoshop与切图" class="headerlink" title="Photoshop与切图"></a>Photoshop与切图</h2>]]></content>
      
        <categories>
            
            <category> 知识体系 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 知识体系 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6九————JS中的类]]></title>
      <url>/2017/08/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B9%9D%E2%80%94%E2%80%94JS%E4%B8%AD%E7%9A%84%E7%B1%BB/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 类 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue脚手架vue-cli的学习二--自定义模块]]></title>
      <url>/2017/08/22/vue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6十三]]></title>
      <url>/2017/08/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E5%8D%81%E4%B8%89/</url>
      <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul>
<li>模块是自动运行在严格模式下并且没有办法退出运行的Javascript代码，在模块中创建的变量不会自动被添加到全局作用域</li>
<li>模块的两个特性：在模块顶部，this的值是undefined；模块不支持HTML风格的代码注释</li>
</ul>
<h1 id="模块的导入导出语法"><a href="#模块的导入导出语法" class="headerlink" title="模块的导入导出语法"></a>模块的导入导出语法</h1><ul>
<li><p>导出的基本语法：用<code>export</code>关键字将代码暴露给其他模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 导出数据</div><div class="line">export var color = &apos;red&apos;;</div><div class="line">export let name = &apos;tgb&apos;;</div><div class="line">export const magicNumber = 7;</div><div class="line"></div><div class="line">// 导出函数</div><div class="line">export function sum(num1,num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>导入的基本语法：通过<code>import</code>关键字在另一个模块中访问，<code>import</code>语句的两个部分分别是，要导入的标识符和标识符应当从哪个模块导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123;identifierl,identifier2&#125; from &apos;./example.js&apos;//模块说明符</div><div class="line"></div><div class="line">// 导入多个绑定</div><div class="line">import &#123; sum, multiply, magicNumber&#125; from &apos;./example.js&apos;;</div><div class="line"></div><div class="line">// 导入整个模块</div><div class="line">import * as example from &apos;./expmple.js&apos; // 命名空间导入</div></pre></td></tr></table></figure>
</li>
<li><p>模块说明符的注意事项：Node.js遵循文件系统前缀区分本地文件和包的惯例，例如，<code>example</code>是一个包而<code>./example.js</code>是一个本地文件</p>
</li>
<li>从模块中导入绑定时，import后面使用的标识符，在该模块不能再次使用。</li>
<li>不管在<code>import</code>语句中把一个模块写了多少次，该模块只执行一次，导入模块的代码执行后，实例化过的模块被保存在内存中，只要另一个<code>import</code>语句引用它就可以重复使用它。</li>
</ul>
<h1 id="模块语法的限制"><a href="#模块语法的限制" class="headerlink" title="模块语法的限制"></a>模块语法的限制</h1><ul>
<li><code>export</code>和<code>import</code>的一个重要的限制是，它们必须在其他语句和函数之外使用，所以 必须在顶部使用<code>export</code>和<code>import</code>。</li>
<li>导入的绑定标识符是只读的，标识符只有在被导出的模块中可以修改，导入绑定的模块无法改变绑定值。<a id="more"></a>
</li>
</ul>
<h1 id="导出和导入时的重命名"><a href="#导出和导入时的重命名" class="headerlink" title="导出和导入时的重命名"></a>导出和导入时的重命名</h1><ul>
<li><p>可以用<code>as</code>关键字来改变导出时元素的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum (num1,num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">export &#123;sum as add&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>导入时改变名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123;add as sum&#125; from &apos;./example.js&apos;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="模块的默认值"><a href="#模块的默认值" class="headerlink" title="模块的默认值"></a>模块的默认值</h1><ul>
<li>模块的默认值是指通过default关键字指定的单个变量，函数或类，只能为模块设置一个默认的导出值</li>
<li><p>导出默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export default function(num1,num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>导入默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import sum from &apos;./example.js&apos; //导入默认值是不使用大括号</div></pre></td></tr></table></figure>
</li>
<li><p>导出默认值和非默认值:用逗号将默认的本地名称与大括号包裹的非默认值分割开，在import语句中，默认值必须排在非默认值前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export let color = &apos;red&apos;;</div><div class="line"></div><div class="line">export default function(num1,num2) &#123;</div><div class="line">   return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 导入</div><div class="line">import sum, &#123; color &#125; from &apos;./example.js&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="浏览器模块说明符解析"><a href="#浏览器模块说明符解析" class="headerlink" title="浏览器模块说明符解析"></a>浏览器模块说明符解析</h1><ul>
<li>以<code>/</code>开头的解析从根目录开始。</li>
<li>以<code>./</code>开头的解析从当前目录开始。</li>
<li>以<code>../</code>开头的解析从父目录开始。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 模块化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> ES6模块化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[国际化——Vue-i18n的使用]]></title>
      <url>/2017/08/12/%E5%9B%BD%E9%99%85%E5%8C%96%E2%80%94%E2%80%94Vue-i18n%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="Vue-i18n安装"><a href="#Vue-i18n安装" class="headerlink" title="Vue-i18n安装"></a>Vue-i18n安装</h2><ul>
<li><code>npm install vue-i18n --save</code></li>
</ul>
<h2 id="Vue-i18n的使用"><a href="#Vue-i18n的使用" class="headerlink" title="Vue-i18n的使用"></a>Vue-i18n的使用</h2><ul>
<li>在入口<code>main.js</code>文件配置使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import VueI18n from &apos;vue-i18n&apos;</div><div class="line"></div><div class="line">Vue.use(VueI18n);</div><div class="line">/*---------基本使用-----------*/</div><div class="line">const i18n = new VueI18n(&#123;</div><div class="line">  locale: &apos;CN&apos;,    // 语言标识</div><div class="line">  messages : &#123;</div><div class="line">    en: &#123;</div><div class="line">      message: &#123;</div><div class="line">        hello: &apos;hello world&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    cn: &#123;</div><div class="line">      message: &#123;</div><div class="line">        hello: &apos;你好、世界&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">/*---------使用语言包-----------*/</div><div class="line">const i18n = new VueI18n(&#123;</div><div class="line">  locale: &apos;CN&apos;,    // 语言标识</div><div class="line">  messages: &#123;</div><div class="line">    &apos;CN&apos;: require(&apos;./assets/common/lang/cn&apos;),   // 中文语言包</div><div class="line">    &apos;EN&apos;: require(&apos;./assets/common/lang/en&apos;)    // 英文语言包</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">/*---------语言包内部语法star-----------*/</div><div class="line">export const  message = &#123;</div><div class="line">      language:&apos;语言&apos;,</div><div class="line">      hello: &apos;你好,世界&apos;</div><div class="line">&#125;</div><div class="line">/*---------语言包内部语法end-----------*/</div><div class="line"></div><div class="line">/*---------挂载全局使用-----------*/</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  i18n,</div><div class="line">  router,</div><div class="line">  template: &apos;&lt;App/&gt;&apos;,</div><div class="line">  components: &#123; App &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">/*---------vue组件模板的使用-----------*/</div><div class="line"> &lt;template&gt;</div><div class="line">        &lt;p&gt;&#123;&#123; $t(&quot;message.hello&quot;) &#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;/template&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="单独组件的使用"><a href="#单独组件的使用" class="headerlink" title="单独组件的使用"></a>单独组件的使用</h2><ul>
<li>在单个vue组件中使用，要用到i18n自定义块，需要配置webpack文件<code>webpack.base.conf.js</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.vue$/,</div><div class="line">        loader: &apos;vue-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          loaders: &#123;</div><div class="line">            // you need to specify `i18n` loaders key with `vue-i18n-loader` (https://github.com/kazupon/vue-i18n-loader)</div><div class="line">            i18n: &apos;@kazupon/vue-i18n-loader&apos;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      // ...</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;i18n&gt;</div><div class="line">&#123;</div><div class="line">  &quot;en&quot;: &#123;</div><div class="line">    &quot;hello&quot;: &quot;hello world!&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;ja&quot;: &#123;</div><div class="line">    &quot;hello&quot;: &quot;你好,世界！&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/i18n&gt;</div><div class="line"></div><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;label for=&quot;locale&quot;&gt;locale&lt;/label&gt;</div><div class="line">    &lt;select v-model=&quot;locale&quot;&gt;</div><div class="line">      &lt;option&gt;en&lt;/option&gt;</div><div class="line">      &lt;option&gt;ja&lt;/option&gt;</div><div class="line">    &lt;/select&gt;</div><div class="line">    &lt;p&gt;message: &#123;&#123; $t(&apos;hello&apos;) &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">export default &#123;</div><div class="line">  name: &apos;app&apos;,</div><div class="line">  data () &#123; return &#123; locale: &apos;en&apos; &#125; &#125;,</div><div class="line">  watch: &#123;</div><div class="line">    locale (val) &#123;</div><div class="line">      this.$i18n.locale = val</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
            <category> 组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue-i18 </tag>
            
            <tag> 国际化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6六]]></title>
      <url>/2017/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E5%85%AD/</url>
      <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul>
<li>ES6新增的数据类型<code>Symbol</code></li>
<li><p>创建Symbol：通过去全局的<code>Symbol</code>函数创建一个<code>Symbol</code>，<code>Symbol</code>函数接受一个可选参数，用于添加一段文本描述即将创建的<code>Symbol</code>,方便阅读和调试Symbol程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let firstName = Symbol(&apos;first name&apos;);</div><div class="line">    let person = &#123;&#125;;</div><div class="line"></div><div class="line">    person[firstName] = &apos;Nicholas&apos;;</div><div class="line"></div><div class="line">    console.log(&apos;first name&apos; in person); //false</div><div class="line">    console.log(person[firstName]); //&apos;Nicholas&apos;</div><div class="line">    console.log(firstName); //&apos;Symbol(first name)&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>ES6扩展了<code>typeof</code>操作符，支持返回<code>Symbol</code>,可以用typeof来检测变量是否为<code>Symbol</code>类型.</p>
</li>
</ul>
<h2 id="Symbol共享体系"><a href="#Symbol共享体系" class="headerlink" title="Symbol共享体系"></a>Symbol共享体系</h2><ul>
<li><p>ES6提供了一个可以随时访问的全局Symbol注册表,如果要创建一个可共享的Symbol,要使用Symbol.for()方法，该方法只接受一个参数，就是即将创建的Symbol的字符串标识符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&apos;uid&apos;);</div><div class="line">let object = &#123;&#125;;</div><div class="line"></div><div class="line">object[uid]=&apos;12345&apos;;</div><div class="line"></div><div class="line">console.log(ojbect[uid]);</div><div class="line">console.log(uid);</div></pre></td></tr></table></figure>
</li>
<li><p>Symbol.for()方法首先在全局Symbol注册表中搜索键为’uid’的Symbol是否存在，如果存在，直接返回已有的Symbol；否则创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol</p>
<a id="more"></a></li>
<li>可以使用<code>Symbol.keyFor()</code>方法在Symbol全局注册表中检索与Symbol有关的键<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&apos;uid&apos;);</div><div class="line">console.log(Symbol.keyFor(uid)); //&apos;uid&apos;</div><div class="line"></div><div class="line">let uid3 = Symbol(&apos;uid&apos;);</div><div class="line">console.log(Symbol.keyFor(uid3)) //undefined</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Symbol属性检索"><a href="#Symbol属性检索" class="headerlink" title="Symbol属性检索"></a>Symbol属性检索</h2><ul>
<li>ES6中新增<code>Object.getOwnPropertySymbols()</code>方法来检索对象中的Symbol属性，返回值是一个包含所有Symbol自由属性的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&apos;uid&apos;);</div><div class="line">let object = &#123;</div><div class="line">    [uid]: &apos;12345&apos;</div><div class="line">&#125;;</div><div class="line">let symbols = object.getOwnPropertySymbols(object);</div><div class="line"></div><div class="line">console.log(symbols.length);               //1</div><div class="line">console.log(symbols[0]);                   //&apos;Symbol(uid)&apos;</div><div class="line">console.log(object[symbols[0]])            //&apos;12345&apos;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Symbol </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6五]]></title>
      <url>/2017/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%BA%94/</url>
      <content type="html"><![CDATA[<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><ul>
<li><p>对象解构的语法：在赋值操作符(=)左边放置一个对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type:&apos;Indet&apos;,</div><div class="line">    name:&apos;noo&apos;</div><div class="line">&#125;</div><div class="line">let &#123; type, name&#125; = node;</div><div class="line">console.log(type);</div><div class="line">console.log(name);</div></pre></td></tr></table></figure>
</li>
<li><p>对象的解构赋值：由于代码块语句不允许出现在赋值语句左侧，所以必须添加小括号将其转换为一个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type:&apos;Indet&apos;,</div><div class="line">    name:&apos;noo&apos;</div><div class="line">&#125;,</div><div class="line">    type = &apos;Literal&apos;,</div><div class="line">    name = &apos;sss&apos;;</div><div class="line"></div><div class="line">    (&#123; type, name &#125; = node);</div><div class="line">    console.log(type); //&apos;Indet&apos;</div><div class="line">    console.log(name); //&apos;noo&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>函数中也可以传入解构表达式</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type:&apos;Indet&apos;,</div><div class="line">    name:&apos;noo&apos;</div><div class="line">&#125;,</div><div class="line">    type = &apos;Literal&apos;,</div><div class="line">    name = &apos;sss&apos;;</div><div class="line"></div><div class="line">    function outPut(value) &#123;</div><div class="line">        console.log(value === node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    outPut(&#123; type, name &#125; = node);</div><div class="line"></div><div class="line">    console.log(type); //&apos;Indet&apos;</div><div class="line">    console.log(name); //&apos;noo&apos;</div></pre></td></tr></table></figure>
<ul>
<li><p>解构赋值表达式可以设置默认值：在属性名称后面添加一个等号和相应的默认值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type:&apos;Indet&apos;,</div><div class="line">    name:&apos;noo&apos;</div><div class="line">&#125;;</div><div class="line">let &#123; type, name, value = true&#125; = node;</div><div class="line"></div><div class="line">console.log(type); //&apos;Indet&apos;</div><div class="line">console.log(name); //&apos;noo&apos;</div><div class="line">console.log(value); //true</div></pre></td></tr></table></figure>
</li>
<li><p>为非同名局部变量赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type:&apos;Indet&apos;,</div><div class="line">    name:&apos;noo&apos;</div><div class="line">&#125;;</div><div class="line">// type:localType语法的含义是读取名为type的属性并将其值存储在变量localType中</div><div class="line">let &#123; type:localType, name:localName&#125; = node;</div><div class="line"></div><div class="line">console.log(localType); //&apos;Indet&apos;</div><div class="line">console.log(localName); //&apos;noo&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>嵌套对象解构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type:&apos;Identifier&apos;,</div><div class="line">    name:&apos;noo&apos;,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: 1,</div><div class="line">            column:1</div><div class="line">        &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: 1,</div><div class="line">            column: 4</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let &#123; loc: &#123;start &#125;&#125; = node;</div><div class="line"></div><div class="line">console.log(start.line); //1</div><div class="line">console.log(start.column); //1</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><ul>
<li><p>数组解构语法：使用数组字面量，解构操作全部在数组内完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [&apos;red&apos;, &apos;grren&apos;, &apos;blue&apos;];</div><div class="line">let [first, second] = colors;</div><div class="line">console.log(first);   //&apos;red&apos;</div><div class="line">console.log(second);   //&apos;grren&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>数组解构赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let colors = [&apos;red&apos;, &apos;grren&apos;, &apos;blue&apos;],</div><div class="line">    first = &apos;111&apos;,</div><div class="line">    second = &apos;222&apos;;</div><div class="line">[first,second] = colors;</div><div class="line"></div><div class="line">console.log(first);</div><div class="line">console.log(second);</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 解构 </tag>
            
            <tag> 解构赋值 </tag>
            
            <tag> 对象解构 </tag>
            
            <tag> 数组解构 </tag>
            
            <tag> 不定元素 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编程语言分类]]></title>
      <url>/2017/08/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="一、看图区分语言类型"><a href="#一、看图区分语言类型" class="headerlink" title="一、看图区分语言类型"></a>一、看图区分语言类型</h1><p><img src="http://ojvil4eq9.bkt.clouddn.com/17-11-26/57660205.jpg" alt=""></p>
<h1 id="二、语法角度的文字表述"><a href="#二、语法角度的文字表述" class="headerlink" title="二、语法角度的文字表述"></a>二、语法角度的文字表述</h1><h2 id="1-动态类型语言"><a href="#1-动态类型语言" class="headerlink" title="1. 动态类型语言"></a>1. 动态类型语言</h2><ul>
<li>运行期间才做数据类型检查的语言，即动态类型语言编程时，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。</li>
<li>优点：方便阅读，不需要写非常多的类型相关的代码；</li>
<li>缺点：不方便调试，命名不规范时会造成读不懂，不利于理解等<h2 id="2-静态类型语言"><a href="#2-静态类型语言" class="headerlink" title="2. 静态类型语言"></a>2. 静态类型语言</h2></li>
<li>编译期间做检查数据类型的语言，即写程序时要声明所有变量的数据类型，是固定的。使用数据之前，必须先声明数据类型（int ,float,double等）。相当于使用之前，首先要为它们分配好内存空间。</li>
<li>优点：结构非常规范，便于调试，方便类型安全</li>
<li>缺点：为此需要写更多类型相关代码，不便于阅读、不清晰明了<h2 id="3-强类型定义语言（Explicit-type-conversion，强制数据类型定义语言，类型安全的语言）："><a href="#3-强类型定义语言（Explicit-type-conversion，强制数据类型定义语言，类型安全的语言）：" class="headerlink" title="3. 强类型定义语言（Explicit type conversion，强制数据类型定义语言，类型安全的语言）："></a>3. 强类型定义语言（Explicit type conversion，强制数据类型定义语言，类型安全的语言）：</h2></li>
<li>一旦变量被指定某个数据类型，如果不经强制转换，即永远是此数据类型。</li>
<li>举例：若定义了一个整型变量a，若不进行显示转换，不能将a当作字符串类型处理</li>
<li>强类型语言是指需要进行变量/对象类型声明的语言，一般情况下需要编译执行。例如C/C++/Java/C#<h2 id="4-弱类型定义语言（Implicit-type-conversion，类型不安全的语言）："><a href="#4-弱类型定义语言（Implicit-type-conversion，类型不安全的语言）：" class="headerlink" title="4. 弱类型定义语言（Implicit type conversion，类型不安全的语言）："></a>4. 弱类型定义语言（Implicit type conversion，类型不安全的语言）：</h2></li>
<li>数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。</li>
</ul>
<h1 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h1><ul>
<li>javaScript是动态语言，是弱类型定义语言（类型不安全的语言）;</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 语言类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6四]]></title>
      <url>/2017/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h2 id="ES6规范清晰的定义了对象的类别"><a href="#ES6规范清晰的定义了对象的类别" class="headerlink" title="ES6规范清晰的定义了对象的类别"></a>ES6规范清晰的定义了对象的类别</h2><ul>
<li>普通对象 具有JavaScript对象所有的默认内部行为</li>
<li>特异对象 具有某些与默认行为不符的内部行为</li>
<li>标准对象 ES6中规范定义的对象</li>
<li>内建对象 脚本开始执行时存在于JavaScript执行环境中的对象，所有标准对象都是内建对象</li>
</ul>
<h2 id="对象字面量语法的扩展"><a href="#对象字面量语法的扩展" class="headerlink" title="对象字面量语法的扩展"></a>对象字面量语法的扩展</h2><ul>
<li><p>属性初始化简写语法：当一个对象的属性与本地变量同名时，不必要再写冒号和值，简单地只写属性名即可。当对象字面量里只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找其同名变量，如果找到，则该变量的值被复赋值给对象字面量里的同名属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;</div><div class="line">    reutrn &#123;</div><div class="line">        name,</div><div class="line">        age</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对象方法的简写语法：消除了冒号和关键字<code>function</code>,与传统对象方法的区别是简写方法可以使用super关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    name:&apos;tgb&apos;,</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>可计算属性名：在ES6中可以在对象字面量中使用可计算属性名称，对象字面中使用方括号表示该属性名称时可计算的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let suffix = &apos;name&apos;</div><div class="line">let person = &#123;</div><div class="line">    [&apos;first&apos;+suffix]: &apos;Nicholas&apos;,</div><div class="line">    [&apos;last&apos;+suffix]:&apos;Zakas&apos;</div><div class="line">&#125;</div><div class="line">console.log(person[&apos;first name&apos;]);</div><div class="line">console.log(person[&apos;last name&apos;]);</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="ES6新增方法"><a href="#ES6新增方法" class="headerlink" title="ES6新增方法"></a>ES6新增方法</h2><ul>
<li><p>Object.is()方法：这个方法接受两个参数，如果两个参数的类型相同且具有相同的值，则返回true。用来弥补全等运算符的不准确运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(+0 === -0)  //true;</div><div class="line">console.log(Object.is(+0,-0)); //false</div><div class="line"></div><div class="line">console.log(NaN === Nan); //false</div><div class="line">console.log(Object.is(NaN,NaN)) //true</div></pre></td></tr></table></figure>
</li>
<li><p>Object.assign()方法：混入方法，这个方法接受一个对象和任意数量的源对象，最终返回接受对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;&#125;;</div><div class="line">Object.assign(obj,</div><div class="line">    &#123;</div><div class="line">        type:&apos;js&apos;;</div><div class="line">        name:&apos;file.js&apos;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        type:&apos;css  //如果多个源对象具有同名的属性则排位靠后的源对象会覆盖排位靠前的</div><div class="line">    &#125;</div><div class="line">)</div><div class="line">console.log(obj.type); //&apos;css&apos;</div><div class="line">console.log(obj.name); //&apos;file.js&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="增强对象原型"><a href="#增强对象原型" class="headerlink" title="增强对象原型"></a>增强对象原型</h2><ul>
<li><p>ES6新增<code>Object.setPrototypeOf()方法</code>：这个方法可以改变任意指定对象的原型，它接受两个参数；被改变的对象原型的对象以及要替代第一个参数原型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &apos;Hello&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let dog = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &apos;Woof&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let friend = Object.create(person);</div><div class="line">console.log(Object.getPrototypeOf(firend)===person); //true</div><div class="line"></div><div class="line">Object.setPrototypeOf(friend,dog);</div><div class="line">console.log(Object.getPrototypeOf(friend)===dog); //true</div></pre></td></tr></table></figure>
</li>
<li><p>简化原型访问的Super引用</p>
<ul>
<li>Super引用相当于指向对象原型的指针，就是Object.getPrototypeOf(this)的值</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 对象字面量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6三]]></title>
      <url>/2017/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><p>ES6简化了为形式参数提供默认值的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function makeRequest(rul,timeout = 2000,callback) &#123;</div><div class="line">    //函数其余部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面的函数只有当不为第二个参数传入值或者主动为第二个参数传入undefined时才会使用timeout的默认值</p>
</li>
<li><p>在ES6中一个函数使用了默认参数值，会使得arguments对象保持与命名参数的分离，无论参数如何变化，arguments对象不再随之改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function mix(first,second=&apos;b&apos;) &#123;</div><div class="line">    console.log(arguments.length);  // 1 之传入了一个参数</div><div class="line">    console.log(first === arguments[0])  // true</div><div class="line">    console.log(second === aruments[1])  // false //arguments[1]是undefined</div><div class="line">&#125;</div><div class="line">mix(&apos;a&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>默认参数表达式</p>
<ul>
<li>ES6中可以使用先定义的参数作为后定义参数的默认值，但是后定义的参数不能作为先定义参数的默认值。</li>
<li>默认参数也存在临时死区，定义参数时会为每个参数创建一个新的标识符绑定，该绑定在初始化之前不可被引用，如果访问会导致程序错误</li>
</ul>
</li>
</ul>
<h2 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h2><ul>
<li>在函数的命名参数钱添加三个点(…)就表明这是一个不定参数，该参数为一个数组，包含着自它之后出入的所有参数，通过这个数组名即可逐一访问里面的参数。</li>
<li>不定参数的使用限制：1.每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾。2.不定参数不能用于对象字面量setter中</li>
<li>arguments对象包含不定参数，无论是否使用不定参数，argumetns对象总是包含所有传入函数的参数</li>
</ul>
<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><pre><code>- 展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数
- 展开运算符的使用：例如`Math.max()`方法可以接受任意数量的参数并返回值最大的一个，但是该方法不允许传入数组。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES5使用</div><div class="line">let values = [25,50,75,100];</div><div class="line">console.log(Math.max.apply(Math,values)); //100</div><div class="line"></div><div class="line">// Es6使用</div><div class="line">console.log(Math.max(...values)); //100</div></pre></td></tr></table></figure>
</code></pre><a id="more"></a>
<h2 id="判断函数被调用的方法"><a href="#判断函数被调用的方法" class="headerlink" title="判断函数被调用的方法"></a>判断函数被调用的方法</h2><ul>
<li>在ES5中判断一个函数是否通过new关键字被调用(或者说，判断该函数是否作为构造函数被调用)，最常使用的是instanceof</li>
<li>instanceof语法：<code>Object instanceof constructor;</code> <code>instanceof</code>运算符用来检测<code>constructor.prototype</code>是否存在于参数<code>Object</code>的原型链上</li>
<li>ES6引入了<code>new.target</code>这个元属性，元属性市值非对象的属性，其可以提供非对象目标的补充信息，当调用函数的<a href="构造器">[construct]</a>方法时，new.target被赋值new操作符的目标，通常是新创建的对象实例。如果用[[call]]方法，则new.target的值为undefined。</li>
</ul>
<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><ul>
<li><p>ES6中允许在代码块中声明函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(true) &#123;</div><div class="line">    function doSomething() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>块级函数的声明提升</p>
<ul>
<li>函数声明的块级函数会被提升至块的顶部而用let定义的函数表达式不会被提升</li>
<li>ES6严格模式下块级函数只会提升至块的顶部，但是在非严格模式下函数会被提升至外围函数或全局作用域的顶部。</li>
</ul>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li>箭头函数是一种使用箭头(=&gt;)定义函数的新语法</li>
<li>与传统函数的不同：<ol>
<li>没有this、super、arguments和new.target绑定 这些值由外围一层非箭头函数决定</li>
<li>不能通过new关键字调用 箭头函数没有[[constructor]]方法，如果通过new关键字调用箭头函数，程序会抛出错误。</li>
<li>没有原型 不存在<code>prototype</code>这个属性</li>
<li>不可以改变<code>this</code>的绑定 在函数的生命周期内始终保持一致</li>
<li>不支持arguments对象</li>
<li>不支持重复命名的参数</li>
</ol>
</li>
<li><p>箭头函数的语法</p>
<ol>
<li><p>当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧额表达式被求值后便立即返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let reflect = value =&gt; value;</div></pre></td></tr></table></figure>
</li>
<li><p>如果要传入两个或两个以上的参数，要在参数的两侧添加一对小括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let sum = (num1,num2) =&gt; num1+num2;</div></pre></td></tr></table></figure>
</li>
<li><p>如果函数没有参数，也要在声明的时候写一组没有内容的小括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let getName = () =&gt; &apos;Tgb&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>可以有函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let sum = (num1,num2) =&gt; &#123;</div><div class="line">    return num1+num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>箭头函数返回对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let getTempItem = id =&gt; (&#123; id: id,name: &apos;temp&apos; &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>箭头函数的自调用 沙箱模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let person = ((name) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        getName: function() &#123;</div><div class="line">            retrun name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)(&apos;tgb&apos;);</div></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 不定参数 </tag>
            
            <tag> 展开运算符 </tag>
            
            <tag> 块级函数 </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6二]]></title>
      <url>/2017/07/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="模板字面量的主要功能"><a href="#模板字面量的主要功能" class="headerlink" title="模板字面量的主要功能"></a>模板字面量的主要功能</h1><ul>
<li>多行字符串：一个正式的多行字符串的概念</li>
<li>基本的字符串格式化：将变量的值嵌入字符串的能力</li>
<li>HTML转义 向HTML插入经过安全转换后的字符串的能力</li>
</ul>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let message = `Hello world`;</div></pre></td></tr></table></figure>
<ul>
<li><p>模板字面量可以使用反斜杠(/),在模板字面量中不需要转义单,双引号</p>
</li>
<li><p>模板字面量可以很简洁的使用多行字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let message = `Hello</div><div class="line">world`</div></pre></td></tr></table></figure>
</li>
<li><p>在模板字面量中，可以把任何合法的javascript表达式嵌入到占位符中并将其作为字符串的一部分输出到结果中。<br>占位符有一个左侧的${和右侧的}符号组成，中间可以包含任意的javascript表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let name = &apos;Nicholas&apos;,</div><div class="line">    message = `Hello $&#123;name&#125;`</div></pre></td></tr></table></figure>
</li>
</ul>
<p>#注意事项</p>
<ul>
<li><p>模板字面量可以访问作用域中所有可访问的变量，而嵌入未定义的变量会抛出错误</p>
</li>
<li><p>可以在模板字面量中嵌入另外一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let name = &apos;Nicholas&apos;,</div><div class="line">    message = &apos;Hello, $&#123;</div><div class="line">        `my name is $&#123;name&#125;`</div><div class="line">    &#125;.`;</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h1 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h1><ul>
<li><p>标签模板是在模板字面量第一个反撇号(`)前方标注的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let message = tag`Hello world`</div></pre></td></tr></table></figure>
</li>
<li><p>标签是一个函数，第一个参数是一个数组，包含JavaScript解释过后的字面量字符串，它之后的所有参数都是每一个站位符的解释值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function tag(literals,...substitutions) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">    let a = 5,b = 10;</div><div class="line">    let tag = (s,v1,v2)=&gt;&#123;</div><div class="line">        console.log(s);</div><div class="line">        console.log(v1);</div><div class="line">        console.log(v2);</div><div class="line">    &#125;</div><div class="line">    tag`Hello $&#123;a+b&#125; world $&#123;a*b&#125;`;  //[&apos;Hello &apos;,&apos; world &apos;,&apos;&apos;]</div><div class="line">                                     //15</div><div class="line">                                     //50</div></pre></td></tr></table></figure>
</li>
<li><p>通过String.raw()标签可以访问到字符转义被转换成等价字符前的原声字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let message1 = `Multiline\nstring`;</div><div class="line">let message2 = String.raw`Multiline\nstring`;</div><div class="line">console.log(message1); //&apos;Multiline</div><div class="line">                       //string&apos;</div><div class="line">console.log(message2); //&apos;Multiline\nstring&apos;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 模板字面量 </tag>
            
            <tag> 标签模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5基础标签的掌握]]></title>
      <url>/2017/07/20/HTML5%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE%E7%9A%84%E6%8E%8C%E6%8F%A1/</url>
      <content type="html"><![CDATA[<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a><abbr>标签</abbr></h2><ul>
<li><code>&lt;abbr&gt;</code> 标签表示简称或缩写，比如 “WWW” 或 “NATO”</li>
<li><code>&lt;abbr&gt;</code> 标签中使用全局的 title 属性，这样就能够在鼠标指针移动到 <abbr> 元素上时显示出简称/缩写的完整版本。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The &lt;abbr title=&quot;People&apos;s Republic of China&quot;&gt;PRC&lt;/abbr&gt; was founded in 1949.</div></pre></td></tr></table></figure>
</abbr></li>
</ul>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
            <tag> 标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ES6一]]></title>
      <url>/2017/07/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h1><ol>
<li>Es6中引入块级声明，<code>let</code>声明的变量作用域限制在代码块中；</li>
<li><code>let</code>声明不会被提升;</li>
<li>在同一作用域中不能用<code>let</code>重复定义已经存在的标识符，会抛出错误。</li>
</ol>
<h1 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h1><ol>
<li><code>const</code>声明的变量作用域也会限制在代码块中；</li>
<li><code>const</code>声明的是常量，其值一旦被设定后不可更改，每个通过const声明的常量必须进行初始化(赋值)</li>
<li><code>const</code>声明不允许修改绑定，但允许修改值；例如<code>const</code>声明对象，对象的值是可以修改的</li>
</ol>
<h1 id="临时死区的存在"><a href="#临时死区的存在" class="headerlink" title="临时死区的存在"></a>临时死区的存在</h1><ul>
<li>临时死区(temporal dead zone)TDZ用来描述<code>let</code>和<code>const</code>的不提升效果；</li>
<li>与<code>var</code>声明不同，<code>let</code>和<code>const</code>声明的变量不会被提升到作用域的顶部，在<code>javascript</code>引擎扫描代码的时候会将<code>let</code>和<code>const</code>的声明放到临时死区中</li>
</ul>
<h1 id="循环中的块级作用域"><a href="#循环中的块级作用域" class="headerlink" title="循环中的块级作用域"></a>循环中的块级作用域</h1><ul>
<li>常见的循环错误；<code>var</code>声明是全局变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for(var i=0;i&lt;10;i++) &#123;</div><div class="line">    funcs.push(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">funcs.forEach(funcion(func) &#123;</div><div class="line">    func(); //输出10次10 </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>使用闭包解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for(var i=0;i&lt;10;i++) &#123;</div><div class="line">    funcs.push((function(value)&#123;</div><div class="line">        // 变量i的值在传递到这个作用域是被赋值给了value;</div><div class="line">        // 此时这个值就不会随外部变量而变化了；</div><div class="line">        return function() &#123;</div><div class="line">            console.log(value);</div><div class="line">        &#125;</div><div class="line">    &#125;)(i));</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func(); //输出0，然后是1,2直到9</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>使用let声明简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var funcs=[];</div><div class="line">for(let i=0;i&lt;10;i++) &#123;</div><div class="line">    funcs.push(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func(); //输出0，然后是1,2直到9</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="全局作用域的绑定"><a href="#全局作用域的绑定" class="headerlink" title="全局作用域的绑定"></a>全局作用域的绑定</h1><ul>
<li>当<code>var</code>被用于全局作用域时，它会创建一个新的全局变量作为全局对象(浏览器环境中的window对象)的属性</li>
<li>当在全局作用域中使用<code>let</code>和<code>const</code>,会在全局作用域下创建一个新的绑定，但是该绑定不会添加为全局对象的属性。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> let </tag>
            
            <tag> const </tag>
            
            <tag> 块级作用域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器缓存]]></title>
      <url>/2017/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h2 id="缓存的定义"><a href="#缓存的定义" class="headerlink" title="缓存的定义"></a>缓存的定义</h2><ul>
<li>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。</li>
</ul>
<h2 id="缓存的命中和未命中"><a href="#缓存的命中和未命中" class="headerlink" title="缓存的命中和未命中"></a>缓存的命中和未命中</h2><ul>
<li>304 的标准解释：<ul>
<li>Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</li>
</ul>
</li>
<li>HTTP在验证<a id="more"></a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> http </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议的学习三]]></title>
      <url>/2017/07/17/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> HTTP协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> URL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工作中遇到的问题——对象的拷贝]]></title>
      <url>/2017/07/13/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ul>
<li>将对象赋值给一个变量时，当我改变变量的值，发现原来的对象也跟着改变。<h1 id="发现原因："><a href="#发现原因：" class="headerlink" title="发现原因："></a>发现原因：</h1></li>
<li>因为对象是应用类型，存放在堆内存中；当我们用变量保存一个对象时，实际上保存的是该对象指针，这个指针指向对象的位置，所以当我们改变变量的时候，会从指针找到对象的位置，从而改变了对象。<h1 id="解决方法：将对象拷贝再赋值给变量"><a href="#解决方法：将对象拷贝再赋值给变量" class="headerlink" title="解决方法：将对象拷贝再赋值给变量"></a>解决方法：将对象拷贝再赋值给变量</h1></li>
</ul>
<ol>
<li><p>浅拷贝</p>
<ul>
<li><p>简单的引用复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function shallowClone(copyObj) &#123;</div><div class="line">    var obj = &#123;&#125;;</div><div class="line">    for ( var i in copyObj) &#123;</div><div class="line">        obj[i] = copyObj[i];</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">var x = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</div><div class="line">    c: [ 1, 2, 3 ]</div><div class="line">&#125;;</div><div class="line">var y = shallowClone(x);</div><div class="line">console.log(y.b.f === x.b.f);     // true</div></pre></td></tr></table></figure>
<a id="more"></a></li>
<li>ES6新方法<code>Object.assign()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</div><div class="line">    c: [ 1, 2, 3 ]</div><div class="line">&#125;;</div><div class="line">var y = Object.assign(&#123;&#125;, x);</div><div class="line">console.log(y.b.f === x.b.f);     // true</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>深度拷贝</p>
<ul>
<li><p>Array的slice和concat方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    var array = [1,2,3];</div><div class="line">var array_shallow = array;</div><div class="line">var array_concat = array.concat();</div><div class="line">var array_slice = array.slice(0);</div><div class="line">console.log(array === array_shallow); //true</div><div class="line">console.log(array === array_slice); //false，“看起来”像深拷贝</div><div class="line">console.log(array === array_concat); //false，“看起来”像深拷贝</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;];</div><div class="line">var array_concat = array.concat();</div><div class="line">var array_slice = array.slice(0);</div><div class="line">array_concat[1][0] = 5;  //改变array_concat中数组元素的值</div><div class="line">console.log(array[1]); //[5,2,3]</div><div class="line">console.log(array_slice[1]); //[5,2,3]</div><div class="line">array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值</div><div class="line">console.log(array[2].name); //array_slice</div><div class="line">console.log(array_concat[2].name); //array_slice</div></pre></td></tr></table></figure>
</li>
<li><p>JSON对象的parse和stringify</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    //例1</div><div class="line">var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125;</div><div class="line">var target = JSON.parse(JSON.stringify(source));</div><div class="line">target.name = &quot;target&quot;;  //改变target的name属性</div><div class="line">console.log(source.name); //source</div><div class="line">console.log(target.name); //target</div><div class="line">target.child.name = &quot;target child&quot;; //改变target的child</div><div class="line">console.log(source.child.name); //child</div><div class="line">console.log(target.child.name); //target child</div><div class="line">//例2</div><div class="line">var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125;</div><div class="line">var target = JSON.parse(JSON.stringify(source));</div><div class="line">console.log(target.name); //undefined</div><div class="line">//例3</div><div class="line">var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;</div><div class="line">var target = JSON.parse(JSON.stringify(source));</div><div class="line">console.log(target.name); //undefined</div><div class="line">console.log(target.child); //Object &#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="完整的拷贝方法"><a href="#完整的拷贝方法" class="headerlink" title="完整的拷贝方法"></a>完整的拷贝方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var $ = (function()&#123;</div><div class="line">  var types = &apos;Array Object String Date RegExp Function Boolean Number Null Undefined&apos;.split(&apos; &apos;);</div><div class="line">  function type() &#123;</div><div class="line">    return Object.prototype.toString.call(this).slice(8, -1);</div><div class="line">  &#125;</div><div class="line">  for (var i = types.length; i--;) &#123;</div><div class="line">     $[&apos;is&apos; + types[i]] = (function (self) &#123;</div><div class="line">        return function (elem) &#123;</div><div class="line">           return type.call(elem) === self;</div><div class="line">        &#125;;</div><div class="line">    &#125;)(types[i]);</div><div class="line">  &#125;</div><div class="line">  return $;</div><div class="line">&#125;)();//类型判断</div><div class="line"></div><div class="line"> function copy(obj,deep)&#123;</div><div class="line">  if(obj === null || (!$.isObject(obj) &amp;&amp; !$.isFunction(obj)))&#123;</div><div class="line">    return obj;</div><div class="line">      &#125;</div><div class="line">  if($.isFunction(obj))&#123;</div><div class="line">     return new Function(&quot;return &quot; + obj.toString())();</div><div class="line">  &#125;else&#123;</div><div class="line">         var name, target = $.isArray(obj) ? [] : &#123;&#125;, value;</div><div class="line">         for(name in obj)&#123;</div><div class="line">            value = obj[name];</div><div class="line">            if(value === obj) &#123;</div><div class="line">              continue;</div><div class="line">            &#125;</div><div class="line">            if(deep &amp;&amp; ($.isArray(value) || $.isObject(value)))&#123;</div><div class="line">              target[name] = copy(value,deep);</div><div class="line">            &#125;else&#123;</div><div class="line">              target[name] = value;</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">       return target;</div><div class="line">     &#125;　</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 对象 </tag>
            
            <tag> 对象复制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chrome开发工具指南]]></title>
      <url>/2017/07/12/Chrome%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="谷歌浏览器开发工具综述"><a href="#谷歌浏览器开发工具综述" class="headerlink" title="谷歌浏览器开发工具综述"></a>谷歌浏览器开发工具综述</h1><ol>
<li>使用开发工具<ul>
<li>选择浏览器位于浏览器窗口右上方的菜单栏的工具目录chrome-menu，选择开发者工具选项</li>
<li>右击页面任何位置并选择审查元素</li>
<li>使用快捷键f12</li>
</ul>
</li>
<li>开发者工具窗口<ul>
<li>开发者工具窗口的顶部工具栏中排列着任务相关的组。每个工具栏项目和相应的面板让你能够使用网页或应用程序的特定信息来工作，包括 DOM 元素，资源，和源。</li>
<li>总体而言，有八个主要的工具可供查看开发工具<ol>
<li>元素面板(Element):许我们从浏览器的角度看页面，也就是说我们可以看到chrome渲染页面所需要的的HTML、CSS和DOM(Document Object Model)对象。此外，还可以编辑这些内容更改页面显示效果；</li>
<li>控制台面板(Console):显示各种警告与错误信息，并且提供了shell用来和文档、开发者工具交互；</li>
<li>源代码面板(sources):主要用来调试js；</li>
<li>网络面板(Network):可以看到页面向服务器请求了哪些资源、资源的大小以及加载资源花费的时间，当然也能看到哪些资源不能成功加载。此外，还可以查看HTTP的请求头，返回内容等；</li>
<li>性能面板(Performance):</li>
<li>内存面板(Memory)</li>
<li>应用面板(Application)(Audits):分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案；</li>
<li>安全面板(Security)</li>
</ol>
</li>
<li>可以使用 Ctrl + [ 和 Ctrl + ] 快捷键在面板之间移动<a id="more"></a>
<h1 id="元素面板-Element-详解"><a href="#元素面板-Element-详解" class="headerlink" title="元素面板(Element)详解"></a>元素面板(Element)详解</h1></li>
</ul>
</li>
<li>检查和调整页面<ul>
<li>实时编辑 DOM 节点：只需双击选定元素，然后进行更改</li>
<li>实时编辑样式：<ul>
<li>在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。</li>
<li>要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。</li>
<li>默认情况下，您的 CSS 修改不是永久的，重新加载页面时更改会丢失。 如果您想要在页面加载时保留更改，请设置永久制作</li>
</ul>
</li>
<li>检查和编辑框模型参数：<ul>
<li>使用 Computed 窗格检查和编辑当前元素的框模型参数。 框模型中的所有值均可修改，只需点击它们即可</li>
</ul>
</li>
</ul>
</li>
<li>编辑样式<ul>
<li>检查应用到元素的样式<ul>
<li>顶端为 element.style。这些样式要么直接使用样式属性（例如 <p style="color:green">）直接应用到元素，要么在 DevTools 中应用</p></li>
<li>下方是与元素匹配的任何 CSS 规则。例如，在下面的屏幕截图中，选定元素从 tools.css 中定义的规则接收 line-height:24px</li>
<li>再下方是继承的样式，其中包括与选定元素的祖先实体匹配的任何可继承样式规则。 例如，在下面的屏幕截图中，选定元素从 user agent stylesheet 继承 display:list-item</li>
</ul>
</li>
</ul>
</li>
<li>编辑DOM</li>
</ol>
<h3 id="元素面板右侧的辅助功能"><a href="#元素面板右侧的辅助功能" class="headerlink" title="元素面板右侧的辅助功能"></a>元素面板右侧的辅助功能</h3><ul>
<li>Styles: 显示用户定义的样式，比如请求的default.css中的样式，和通过Javasript生成的样式，还有开发者工具添加的样式；</li>
<li>Computed: 显示开发者工具计算好的元素样式；</li>
<li>Event Listeners: 显示当前HTML DOM节点和其祖先节点的所有JavaScript事件监听器，这里的监听脚本可以来自Chrome的插件。可以点击右边小漏斗形状(filter)选择只显示当前节点的事件监听器；</li>
<li>DOM Breakpoints: 列出所有的DOM 断点；</li>
<li>Properties: 超级全面地列出当前选中内容的属性，不过基本很少用到。</li>
</ul>
<h1 id="网络面板-Network-详解"><a href="#网络面板-Network-详解" class="headerlink" title="网络面板(Network)详解"></a>网络面板(Network)详解</h1><ol>
<li>点击单个请求展开详细界面<ul>
<li>Headers:头信息<br>  - </li>
<li>Preview:资源预览</li>
<li>Response:未处理的响应正文</li>
<li>Cookies:请求和返回中所传输的cookies</li>
<li>Timing:图形化显示资源加载的时间<ul>
<li>Stalled:等待时间，浏览器要发出的请求到这个请求可以发出的这一段时间，</li>
<li>Request sent:请求时间，请求的第一个字节发出以前到最后一个自求发出以后时间；</li>
<li>Waiting(TFFB):请求发出以后，到收到响应的第一个字节所发费的时间，响应时间；</li>
<li>Content Download:收到响应的第一个字节开始到接受完最后一个字节所发费的时间，下载时间</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 浏览器基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> chrome浏览器 </tag>
            
            <tag> chrome开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议的学习二]]></title>
      <url>/2017/07/12/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="URL和资源"><a href="#URL和资源" class="headerlink" title="URL和资源"></a>URL和资源</h2><ul>
<li>URL的基本组成部分<ul>
<li>URL的第一部分(http)是URL方案,方案可以告知Web客服端怎样访问资源</li>
<li>URL的第二部分指的是主机(服务器的位置)，这不分告知Web客服端资源位于何处。</li>
<li>URL的第三部分是资源路径，路径说明了请求的是服务器上那个特定的本地资源。<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/38150723.jpg" alt=""></li>
<li>通用URL组件<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/43330542.jpg" alt=""></li>
<li>URL由两种方式：绝对的和相对的<ul>
<li>相对URL是不完整的，需要对基础的URL进行解析</li>
<li>相对URL解析为绝对URL的算法<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/43465307.jpg" alt=""><a id="more"></a>
<h2 id="HTTP报文详解"><a href="#HTTP报文详解" class="headerlink" title="HTTP报文详解"></a>HTTP报文详解</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>报文的流动性<ul>
<li>报文在客服端，服务器和代理之间的流动称为报文流</li>
<li>HTTP使用术语流入(inbound)和流出(outbound)来描述事务处理(transaction)的方向</li>
<li>不管是请求报文还是响应报文，所有的报文都会想下游流动。所有的报文发送者都在接受者的上游<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/97194159.jpg" alt=""></li>
</ul>
</li>
<li><p>报文的组成部分</p>
<ul>
<li>报文主要有三个部分组成；①对报文进行描述的起始行，②包含属性的首部块，③包含数据的主体部分。<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/70522161.jpg" alt=""></li>
<li><p>报文的格式</p>
<ul>
<li><p>请求报文格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;method&gt;(方法) &lt;request-URL&gt;(请求URL) &lt;version&gt;(版本)</div><div class="line">&lt;headers&gt;(首部)</div><div class="line">&lt;entity-body&gt;(主体部分)</div></pre></td></tr></table></figure>
</li>
<li><p>响应报文格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;method&gt;(方法) &lt;status-code&gt;(状态码) &lt;reason-phrase&gt;(原因短语)</div><div class="line">&lt;headers&gt;(首部)</div><div class="line">&lt;entity-body&gt;(主体部分)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>报文各部分的简要描述</p>
<ul>
<li>方法(method):客服端希望服务器对资源执行的动作.比如GET,HEAD或者POST</li>
<li>请求URL(request-URL):命名了所请求的资源，或者URL路径组件的完整URL</li>
<li>版本(version):报文所使用的HTTP版本，其格式看起来是这样的<code>HTTP/&lt;major&gt;.&lt;minor&gt;</code>其中主要版本号(major)和次要版本号(minor)都是整数。</li>
<li>状态码(status-code):这三位数字描述了请求过程中所发生的情况。</li>
<li>原因短语(reason-phrase):数字转台码的可读版本，包含终止序列之前的所有文本。</li>
<li>首部(header):可以有零个或者多个首部，每个首部都包含一个名字，后面跟着一个冒号(:),然后是一个可选的空格，接着是一个值，最后是一个CRLF。例如：<code>content-type:text/plain</code>;</li>
<li>主体部分(entity-body):实体的主体部分包含一个有任意数据组成的数据块，并不是所有的报文都包含主体部分。</li>
</ul>
</li>
<li>HTTP常见的请求方法<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/85068148.jpg" alt=""></li>
<li>状态码的基本分类<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/33693777.jpg" alt=""></li>
</ul>
</li>
</ol>
<h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><ol>
<li>通用首部：提供报文最基本的信息，客服端和服务器都可以使用<ul>
<li>通用的信息性首部<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-13/92284000.jpg" alt=""></li>
<li>通用缓存首部<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-13/85327719.jpg" alt=""></li>
</ul>
</li>
<li>请求首部：只在请求报文中有意义，用于说明是谁或什么在发送请求，请求源自何处，或者客服端的喜好及能力。</li>
<li>响应首部</li>
<li>实体首部</li>
<li>扩展首部</li>
</ol>
<h2 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h2><ul>
<li>400-499客服端错误代码<br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-13/52574748.jpg" alt=""><br><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-13/43117551.jpg" alt=""></li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> URL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议的学习一]]></title>
      <url>/2017/07/11/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="初识HTTP协议"><a href="#初识HTTP协议" class="headerlink" title="初识HTTP协议"></a>初识HTTP协议</h1><ol>
<li>HTTP协议是一种数据传输协议，客服端通过HTTP请求向服务器获取资源，服务器通过HTTP响应提供资源给客服端。</li>
<li>媒体类型(MIME类型)<ul>
<li>HTTP给每种要通过 Web 传输的对象都打上了名为 MIME 类型（MIME type）的数据格式标签</li>
<li>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间<br>由一条斜杠来分隔<ul>
<li>HTML 格式的文本文档由 text/html 类型来标记</li>
<li>JPEG 版本的图片为 image/jpeg 类型</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><ul>
<li>每个 Web 服务器资源都有一个名字，服务器资源名被称为统一资源标识符，URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源</li>
<li>URI和URL的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（<a href="http://）。" target="_blank" rel="external">http://）。</a></li>
<li>URI 有两种形式，分别称为 URL 和 URN</li>
</ul>
<ol>
<li>URL<ul>
<li>URL：统一资源定位符（URL）是资源标识符最常见的形式。URL 描述了一台特定服务器上某资源的特定位置。</li>
<li>大部分 URL 都遵循一种标准格式，这种格式包含三个部分<ul>
<li>URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（<a href="http://）。" target="_blank" rel="external">http://）。</a></li>
<li>第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com）。</li>
<li>其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）</li>
</ul>
</li>
</ul>
</li>
<li>URN<ul>
<li>URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用<br>的，与目前的资源所在地无关。<a id="more"></a>
<h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2></li>
</ul>
</li>
</ol>
<ul>
<li>从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从<br>服务器发往客户端的报文称为响应报文（response message）。</li>
<li>HTTP 报文包括以下三个部分<ol>
<li>起始行<ul>
<li>报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况</li>
</ul>
</li>
<li>首部字段<ul>
<li>起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单</li>
</ul>
</li>
<li>主体<ul>
<li>空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/49459854.jpg" alt=""></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>一个HTTP事务由一条(从客服端发往服务器的)请求命令来和一个(从服务器发回客服端的)响应结果组成。</li>
</ul>
<ol>
<li>方法<ul>
<li>HTTP支持几种不同的请求命令，这些命令被称为HTTP方法,这写方法回告诉服务器要执行什么动作。一般有五种常见的HTTP方法。<ol>
<li>GET：从服务器向客服端发送命名资源</li>
<li>PUT: 将来自客服端的数据存储到一个命名的服务器的资源中去</li>
<li>DELETE：从服务器中删除命名资源</li>
<li>POST：将客服端数据发送到个服务器网关应用程序</li>
<li>HEAD：仅发送命名资源响应中的HTTP首部</li>
</ol>
</li>
</ul>
</li>
<li>状态码<ul>
<li>每条 HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，<br>告知客户端请求是否成功，或者是否需要采取其他动作。</li>
</ul>
</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><p>HTTP 网络协议栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP 应用层</div><div class="line">TCP 传输层</div><div class="line">IP 网络层</div><div class="line">网络特有的链路接口 数据链路层</div><div class="line">物理网络硬件 物理层</div></pre></td></tr></table></figure>
</li>
<li><p>在 HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）<br>地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。</p>
<ul>
<li>(a)浏览器从 URL 中解析出服务器的主机名；</li>
<li>(b)浏览器将服务器的主机名转换成服务器的 IP 地址；</li>
<li>(c)浏览器将端口号（如果有的话）从 URL 中解析出来；</li>
<li>(d)浏览器建立一条与 Web 服务器的 TCP 连接；</li>
<li>(e)浏览器向服务器发送一条 HTTP 请求报文；</li>
<li>(f)服务器向浏览器回送一条 HTTP 响应报文；</li>
<li>(g)关闭连接，浏览器显示文档。</li>
</ul>
</li>
</ul>
<p><img src="http://ojvil4eq9.bkt.clouddn.com/17-7-12/34277135.jpg" alt=""></p>
<h2 id="Web的结构组件"><a href="#Web的结构组件" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h2><ol>
<li>代理: 位于客户端和服务器之间的 HTTP 中间实体。<ul>
<li>代理位于客户端和服务器之间，接收所有客户端的 HTTP 请求，并<br>将这些请求转发给服务器（可能会对请求进行修改之后转发）。</li>
</ul>
</li>
<li>缓存: HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。<ul>
<li>Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了</li>
</ul>
</li>
<li>网关: 连接其他应用程序的特殊 Web 服务器。<ul>
<li>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。</li>
</ul>
</li>
<li>隧道: 对 HTTP 通信报文进行盲转发的特殊代理<ul>
<li>隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。</li>
</ul>
</li>
<li>Agent 代理: 发起自动 HTTP 请求的半智能 Web 客户端。<ul>
<li>用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> HTTP协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> URL </tag>
            
            <tag> URI </tag>
            
            <tag> 报文 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm的快速使用]]></title>
      <url>/2017/07/06/npm%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ol>
<li>npm初始化一个包<ul>
<li><code>npm init</code>创建一个新包 需要填写信息</li>
<li><code>npm init -y</code>快速初始化</li>
</ul>
</li>
<li>安装安装包<ul>
<li>常规: <code>npm install pkg</code>, 速记: <code>npm i pkg</code>.</li>
</ul>
</li>
<li>全局安装包:<ul>
<li>常规: <code>npm i --global pkg</code>, 速记: <code>npm i -g pkg</code>.</li>
</ul>
</li>
<li>安装包并包含在依赖中:<ul>
<li>常规: <code>npm i --save pkg</code>, 速记: <code>npm i -S pkg</code>.</li>
</ul>
</li>
<li>安装包并包含在开发依赖中:<ul>
<li>常规: <code>npm i --save-dev pkg</code>, 速记: <code>npm i -D pkg</code>.<a id="more"></a>
<h3 id="有意义的指令"><a href="#有意义的指令" class="headerlink" title="有意义的指令"></a>有意义的指令</h3></li>
</ul>
</li>
<li>进入安装包的官网<ul>
<li><code>npm repo vue</code></li>
<li><code>npm home vue</code></li>
</ul>
</li>
<li>运行测试指令<ul>
<li><code>npm test</code>, 速记：<code>npm t</code></li>
</ul>
</li>
<li>枚举可用的脚本<ul>
<li>当我们开始一个新项目，我们想知道如何开始。我们通常会问自己这样的问题：我们如何运行它？哪些脚本可用</li>
<li>打开package.json文件并检查scripts部分</li>
<li>我们只要运行npm run得到一个的所有可用的脚本的列表</li>
</ul>
</li>
<li>枚举已经安装的包<ul>
<li>当查看项目中的哪些依赖项，可以打开package.json文件和检查</li>
<li>枚举项目安装包 使用 <code>npm ls --depth 0</code></li>
<li>枚举全局安装包 使用 <code>npm ls -g --depth 0</code></li>
</ul>
</li>
<li>npm更新<ul>
<li><code>npm i -g npm</code></li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端构建生态 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Babel的使用总结]]></title>
      <url>/2017/07/01/Babel%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="babel-polfill插件"><a href="#babel-polfill插件" class="headerlink" title="babel-polfill插件"></a>babel-polfill插件</h2><ul>
<li>由于Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码，所以在IE浏览器下会出现缺少Promise对象的问题</li>
<li><p>为了完整使用 ES6 的 API ，我们只能安装这个插件<br><code>npm install babel-polyfill --save-dev</code></p>
<ul>
<li>node.js 中<code>require(&#39;babel-polyfill&#39;)</code></li>
<li><p>webpack.config.js中</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: [&apos;babel-polyfill&apos;, &apos;./app/js&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>vue-cli配置的环境下,在main.js中引入：<code>import &#39;babel-polyfill&#39;</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h2><h3 id="全局安装："><a href="#全局安装：" class="headerlink" title="全局安装："></a>全局安装：</h3><p><code>npm install --global babel-cli</code></p>
<ul>
<li><p>这时候我们可以使用 Babel 命令编译文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">babel index.js --out-file compiled.js</div><div class="line">#或</div><div class="line">babel index.js -o compiled.js</div></pre></td></tr></table></figure>
</li>
<li><p>编译目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">babel src -out-dir lib</div><div class="line">#或</div><div class="line">babel src -d lib</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="本地安装，记在项目的根目录下："><a href="#本地安装，记在项目的根目录下：" class="headerlink" title="本地安装，记在项目的根目录下："></a>本地安装，记在项目的根目录下：</h3><ul>
<li><code>npm install --save-dev babel-cli</code></li>
<li><p>但是在本地就不能用 babel 命令了，我们可以在 package.json 文件中添加点东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;script&quot;: &#123;</div><div class="line">        &quot;build&quot;: &quot;babel src -d lib&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后，运行 npm run build 即可把 src 目录编译输出到 lib</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Babel </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js学习三]]></title>
      <url>/2017/06/27/Vue-js%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="钩子函数的理解"><a href="#钩子函数的理解" class="headerlink" title="钩子函数的理解"></a>钩子函数的理解</h2><ul>
<li>文档翻译造成的问题，原名是“hook”（不负责任的直译为“钩子”而已），它是一种事件劫持机制，也就是说它会比你的事件更早进行执行处理。</li>
<li>可以简单地把它理解为vue的内置事件，但是这个内置事件是由你去配置的。</li>
</ul>
<h2 id="vue的生命周期详解"><a href="#vue的生命周期详解" class="headerlink" title="vue的生命周期详解"></a>vue的生命周期详解</h2><h3 id="vue生命周期图示"><a href="#vue生命周期图示" class="headerlink" title="vue生命周期图示"></a>vue生命周期图示</h3><p><img src="https://ooo.0o0.ooo/2017/06/28/5952fd52156c2.png" alt=""></p>
<h3 id="生命周期总共分为八个阶段"><a href="#生命周期总共分为八个阶段" class="headerlink" title="生命周期总共分为八个阶段"></a>生命周期总共分为八个阶段</h3><ol>
<li>beforeCreate（组件实例创建前）<ul>
<li>el和data并未初始化</li>
<li>实例创建前：这个阶段实例的data、methods是读不到的</li>
</ul>
</li>
<li>created（组件实例创建后）,<ul>
<li>完成了 data 数据的初始化，el没有</li>
<li>实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染</li>
</ul>
</li>
<li>beforeMount(模板编译/挂载之前),<ul>
<li>完成了 el 和 data 初始化</li>
<li>在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
</ul>
</li>
<li>mounted（模板编译/挂载之后）<ul>
<li>完成挂载</li>
<li>el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染</li>
</ul>
</li>
<li>beforeUpdate（组件更新之前）<ul>
<li>data的值改变后，组件更新，触发update的操作</li>
<li>数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理</li>
</ul>
</li>
<li>updated（组件更新之后）<ul>
<li>data的值改变后，组件更新，触发update的操作</li>
<li>这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行</li>
</ul>
</li>
<li>beforeDestroy（组件销毁前）<ul>
<li>实例销毁之前调用。</li>
</ul>
</li>
<li>destroyed（组件销毁后）</li>
</ol>
<ul>
<li>销毁完成后，我们再重新改变data中的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。</li>
<li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<h3 id="钩子函数的使用"><a href="#钩子函数的使用" class="headerlink" title="钩子函数的使用"></a>钩子函数的使用</h3></li>
<li>beforecreate : 可以在这加个loading事件</li>
<li>created ：在这结束loading，还做一些初始化，实现函数自执行</li>
<li>mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情</li>
<li><p>beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容</p>
</li>
<li><p>created：进行ajax请求异步数据的获取、初始化数据</p>
</li>
<li>mounted：挂载元素内dom节点的获取</li>
<li>nextTick：针对单一事件更新数据后立即操作dom</li>
<li>updated：任何数据的更新，如果要做统一的业务逻辑处理</li>
<li>watch：监听具体数据变化，并做相应的处理<a id="more"></a>
<h2 id="render-渲染-函数的使用-解决重复html"><a href="#render-渲染-函数的使用-解决重复html" class="headerlink" title="render(渲染)函数的使用(解决重复html)"></a>render(渲染)函数的使用(解决重复html)</h2></li>
<li>template模板中有重复HTMl的时候可以用render函数编译</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">        &lt;div id=&quot;app&quot;&gt;</div><div class="line">            &lt;mycomment :level=&quot;2&quot;&gt;</div><div class="line">                这是h2元素</div><div class="line">            &lt;/mycomment&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;script type=&quot;text/x-template&quot; id=&quot;is&quot;&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1 v-if=&quot;level === 1&quot;&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/h1&gt;</div><div class="line">    &lt;h2 v-if=&quot;level === 2&quot;&gt;</div><div class="line">        &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/h2&gt;</div><div class="line">    &lt;h3 v-if=&quot;level === 3&quot;&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/h3&gt;</div><div class="line">    &lt;h4 v-if=&quot;level === 4&quot;&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/h4&gt;</div><div class="line">    &lt;h5 v-if=&quot;level === 5&quot;&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/h5&gt;</div><div class="line">    &lt;h6 v-if=&quot;level === 6&quot;&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/h6&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        Vue.component(&apos;mycomment&apos;,&#123;</div><div class="line">            template:&apos;#is&apos;,</div><div class="line">            props:&#123;</div><div class="line">                level:&#123;</div><div class="line">                    type:Number,</div><div class="line">                    required:true,</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        var app =new Vue(&#123;</div><div class="line">            el:&apos;#app&apos;,</div><div class="line">        &#125;)</div><div class="line"></div><div class="line"></div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>用Render函数解决代码冗长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line">        &lt;div id=&quot;app&quot;&gt;</div><div class="line">            &lt;render-teample :level=&quot;4&quot; &gt;</div><div class="line"></div><div class="line">                &lt;div class=&quot;jah&quot; slot=&quot;myslot&quot;&gt;render function&lt;/div&gt;</div><div class="line">            &lt;/render-teample&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">    Vue.component(&apos;render-teample&apos;,&#123;</div><div class="line">        render:function(createElement)&#123;</div><div class="line">            return createElement(</div><div class="line">                &apos;h&apos;+this.level,</div><div class="line">                &#123;</div><div class="line">                    &apos;class&apos;:&#123;</div><div class="line">                        show:true,</div><div class="line">                        hide:false,</div><div class="line">                    &#125;,</div><div class="line">                    style:&#123;</div><div class="line">                        width:&apos;200px&apos;,</div><div class="line">                        height:&apos;400px&apos;,</div><div class="line">                        background:&apos;red&apos;,</div><div class="line">                    &#125;,</div><div class="line">                    attrs:&#123;</div><div class="line">                        name:&apos;h-ex&apos;,</div><div class="line">                        id:&apos;h-id&apos;</div><div class="line">                    &#125;,</div><div class="line">                    props:&#123;</div><div class="line">                        myprops:true,</div><div class="line">                    &#125;,</div><div class="line">                     on: &#123;</div><div class="line">                    click: function(event)&#123;</div><div class="line">                        alert(this.num)</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                    nativeOn:&#123;</div><div class="line">                        click:function(event) &#123;</div><div class="line"></div><div class="line">                            alert(1111)</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;,</div><div class="line">                [</div><div class="line">                    this.$slots.myslot,</div><div class="line">                    createElement(&apos;div&apos;,&#123;</div><div class="line">                         domProps:&#123;</div><div class="line">                        innerHTML:&apos;holle render&apos;</div><div class="line">                    &#125;</div><div class="line">                    &#125;)</div><div class="line">                ]</div><div class="line"></div><div class="line">                )</div><div class="line">        &#125;,</div><div class="line">         props: &#123;</div><div class="line">        level: &#123;</div><div class="line">          type: Number,</div><div class="line">          required: true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">        var app=new Vue(&#123;</div><div class="line">            el:&quot;#app&quot;,</div><div class="line">            data:&#123;</div><div class="line">                num:110</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line"></div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h2><ul>
<li>当项目中需要对纯 DOM 元素进行底层操作,就要用到自定义指令<h3 id="vue自定义指令的注册"><a href="#vue自定义指令的注册" class="headerlink" title="vue自定义指令的注册"></a>vue自定义指令的注册</h3></li>
<li><p>注册全局自定义指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.directive(&apos;focus&apos;, &#123;</div><div class="line">  inserted: function (el) &#123;</div><div class="line">    el.focus()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>注册局部自定义指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">directives: &#123;</div><div class="line">  focus: &#123;</div><div class="line">    inserted:function (el) &#123;</div><div class="line">                    el.focus()</div><div class="line">                &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>###自定义指令函数提供的钩子函数</p>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用<br>###钩子函数的参数</li>
<li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding: 一个对象，包含以下属性：<ul>
<li>name: 指令名，不包括 v- 前缀。</li>
<li>value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。</li>
<li>oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
<li>expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。</li>
<li>arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。</li>
<li>modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。</li>
</ul>
</li>
<li>vnode: Vue 编译生成的虚拟节点。</li>
<li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js学习二]]></title>
      <url>/2017/06/23/Vue-js%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><h3 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h3><ol>
<li>对象语法：</li>
</ol>
<ul>
<li><p>给<code>v-bind:class</code>一个对象，以动态切换class,语法表示<code>classactive</code>的更新将取决于数据属性 isActive 是否为真值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在对象中传入更多属性用来动态切换多个 class ,v-bind:class 指令可以与普通的 class 属性共存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;static&quot;</div><div class="line">     v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>直接绑定数据里的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</div><div class="line">data: &#123;</div><div class="line">  classObject: &#123;</div><div class="line">    active: true,</div><div class="line">    &apos;text-danger&apos;: false</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>数组语法</li>
</ol>
<ul>
<li><p>把一个数组传给 v-bind:class ，以应用一个 class 列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;</div><div class="line">data: &#123;</div><div class="line">    activeClass: &apos;active&apos;,</div><div class="line">    errorClass: &apos;text-danger&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用三元表达式，据条件切换列表中的 class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul>
<li><code>v-if</code>是“真正的”条件渲染，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li>
<li><code>v-show</code>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换</li>
<li>区别：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好</li>
</ul>
<a id="more"></a>
<h3 id="vue时间处理器"><a href="#vue时间处理器" class="headerlink" title="vue时间处理器"></a>vue时间处理器</h3><ul>
<li>用 <code>v-on</code> 指令监听 DOM 事件来触发一些 JavaScript 代码</li>
<li><code>v-on</code> 可以接收一个定义的方法来调用，方法定义在<code>methods</code><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3></li>
<li><p>vue推荐methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节,当我们要调用 event.preventDefault() 或 event.stopPropagation(),就可以使用事件修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</div><div class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 提交事件不再重载页面 --&gt;</div><div class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</div><div class="line">&lt;!-- 修饰符可以串联  --&gt;</div><div class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 只有修饰符 --&gt;</div><div class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</div><div class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</div><div class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</div><div class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</div><div class="line">&lt;div v-on:click.once=&apos;doThat&apos;&gt;...&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。</p>
<h3 id="关键修饰符"><a href="#关键修饰符" class="headerlink" title="关键修饰符"></a>关键修饰符</h3></li>
<li><p>Vue 允许为 v-on 在监听键盘事件时添加关键修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;</div><div class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>Vue 为最常用的按键提供了别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 同上 --&gt;</div><div class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</div><div class="line">&lt;!-- 缩写语法 --&gt;</div><div class="line">&lt;input @keyup.enter=&quot;submit&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>全部的按键别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.enter</div><div class="line">.tab</div><div class="line">.delete (捕获 “删除” 和 “退格” 键)</div><div class="line">.esc</div><div class="line">.space</div><div class="line">.up</div><div class="line">.down</div><div class="line">.left</div><div class="line">.right</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="vue的数据绑定"><a href="#vue的数据绑定" class="headerlink" title="vue的数据绑定"></a>vue的数据绑定</h2><ul>
<li>“Mustache” 语法（双大括号）<code>{{text}}</code> 单向的数据绑定</li>
<li><code>v-model</code> 双向数据绑定<h3 id="v-model可以添加修饰符"><a href="#v-model可以添加修饰符" class="headerlink" title="v-model可以添加修饰符"></a><code>v-model</code>可以添加修饰符</h3></li>
<li><p>可以添加一个修饰符 lazy ,从而转变为在 change 事件中同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</div><div class="line">&lt;input v-model.lazy=&quot;msg&quot; &gt;</div></pre></td></tr></table></figure>
</li>
<li><p>将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model.number=&apos;age&apos; type=&apos;number&apos;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建博客]]></title>
      <url>/2017/06/23/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul>
<li>第一步、执行npm install hexo-cli -g 安装hexo</li>
<li>第二步、找到你想写博客的文件夹，执行hexo init blog生成文件</li>
<li>第三步、在生成的文件blog中执行hexo server，访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></li>
</ul>
<h2 id="安装和配置Next主题"><a href="#安装和配置Next主题" class="headerlink" title="安装和配置Next主题"></a>安装和配置Next主题</h2><ul>
<li>在hexo目录下右键Git bash通过命令<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>next主题自动下载到themes目录下</li>
<li>在blog文件下的站点配置文件_config.yml,找到 theme 字段，并将其值更改为 next<code>theme:next</code></li>
<li><code>hexo s</code>验证主题配置是否成功，浏览器输入 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></li>
</ul>
<h2 id="hexo书写博客"><a href="#hexo书写博客" class="headerlink" title="hexo书写博客"></a>hexo书写博客</h2><ul>
<li>在source文件夹的_posts里面,通过<code>hexo new 博客标题</code>命令生成markdown文件</li>
<li>文章写好后，执行<code>hexo generate</code>命令生成静态的html文件</li>
</ul>
<h2 id="发送博客到github上"><a href="#发送博客到github上" class="headerlink" title="发送博客到github上"></a>发送博客到github上</h2><ul>
<li>我们把public里面的文件发布到github上面</li>
<li>在创建github仓库是取名一定要去[github用户名].github.io 例子:saber-tgb.github.io</li>
<li>用git发送到githoub是一定要发送到master分支</li>
<li>不用更改生成的博客html文件的css，js的路径 传上去后路径就会正确<a id="more"></a>
<h2 id="next主题的配置和优化"><a href="#next主题的配置和优化" class="headerlink" title="next主题的配置和优化"></a>next主题的配置和优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div></pre></td><td class="code"><pre><div class="line"># ---------------------------------------------------------------</div><div class="line"># Site Information Settings</div><div class="line"># ---------------------------------------------------------------</div><div class="line"></div><div class="line"># Place your favicon.ico to /source directory.</div><div class="line">favicon: /favicon.ico   #站标  可以放在hexo文件夹下的/source里</div><div class="line"></div><div class="line"># Set default keywords (Use a comma to separate)</div><div class="line">keywords: &quot;为学,willxue,willxue.top&quot;  #网站关键字</div><div class="line"></div><div class="line"># Set rss to false to disable feed link.</div><div class="line"># Leave rss as empty to use site&apos;s feed link.</div><div class="line"># Set rss to specific value if you have burned your feed already.</div><div class="line">rss:  #rss这里不设置 引文站点配置文件已经配置了 需要安装插件</div><div class="line"></div><div class="line"># Specify the date when the site was setup</div><div class="line">since: 1990  #网站时间 从xx开始 类似 1990-2016</div><div class="line"></div><div class="line"></div><div class="line"># ---------------------------------------------------------------</div><div class="line"># Menu Settings</div><div class="line"># ---------------------------------------------------------------</div><div class="line"></div><div class="line"># When running hexo in a subdirectory (e.g. domain.tld/blog)</div><div class="line"># Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )</div><div class="line">menu: #菜单路径设置 如果hexo在二级目录放置要去掉/</div><div class="line">  home: /</div><div class="line">  archives: /archives #归档</div><div class="line">  tags: /tags #标签</div><div class="line">  categories: /categories  #分类</div><div class="line">  about: /about #关于我</div><div class="line">  commonweal: /404.html  #公益404</div><div class="line"></div><div class="line"></div><div class="line"># Enable/Disable menu icons.</div><div class="line"># Icon Mapping:</div><div class="line">#   Map a menu item to a specific FontAwesome icon name.</div><div class="line">#   Key is the name of menu item and value is the name of FontAwsome icon.</div><div class="line">#   When an question mask icon presenting up means that the item has no mapping icon.</div><div class="line">menu_icons:  #icon图标</div><div class="line">  enable: true</div><div class="line">  # Icon Mapping.</div><div class="line">  home: home</div><div class="line">  about: user</div><div class="line">  categories: th</div><div class="line">  tags: tags</div><div class="line">  archives: archive</div><div class="line">  commonweal: heartbeat</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># ---------------------------------------------------------------</div><div class="line"># Scheme Settings</div><div class="line"># ---------------------------------------------------------------</div><div class="line"></div><div class="line"># Schemes  #next的三个scheme</div><div class="line">#scheme: Muse</div><div class="line">#scheme: Mist</div><div class="line">scheme: Pisces</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># ---------------------------------------------------------------</div><div class="line"># Sidebar Settings</div><div class="line"># ---------------------------------------------------------------</div><div class="line"></div><div class="line"></div><div class="line"># Social links   #社交链接</div><div class="line">social:</div><div class="line">  GitHub:</div><div class="line">  Weibo:</div><div class="line">  Others:</div><div class="line"></div><div class="line"># Social Icons  #社交的图标</div><div class="line">social_icons:</div><div class="line">  enable: true</div><div class="line">  # Icon Mappings</div><div class="line">  GitHub: github</div><div class="line">  Twitter: twitter</div><div class="line">  Weibo: weibo</div><div class="line"></div><div class="line"></div><div class="line"># Sidebar Avatar</div><div class="line"># in theme directory(source/images): /images/avatar.jpg</div><div class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</div><div class="line"># default : /images/default_avatar.jpg</div><div class="line">avatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像</div><div class="line"></div><div class="line"></div><div class="line"># TOC in the Sidebar  #文章自动显示目录</div><div class="line">toc:</div><div class="line">  enable: true</div><div class="line"></div><div class="line">  # Automatically add list number to toc.  #目录是否自动显示数字序号</div><div class="line">  number: false</div><div class="line"></div><div class="line"></div><div class="line"># Creative Commons 4.0 International License.</div><div class="line"># http://creativecommons.org/  #自由协议</div><div class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</div><div class="line">#creative_commons: by-nc-sa</div><div class="line">#creative_commons:</div><div class="line"></div><div class="line">sidebar:</div><div class="line">  # Sidebar Position, available value: left | right</div><div class="line">  position: left</div><div class="line">  #position: right</div><div class="line"></div><div class="line">  # Sidebar Display, available value:</div><div class="line">  #  - post    expand on posts automatically. Default.</div><div class="line">  #  - always  expand for all pages automatically</div><div class="line">  #  - hide    expand only when click on the sidebar toggle icon.</div><div class="line">  #  - remove  Totally remove sidebar including sidebar toggle icon.</div><div class="line">  display: post</div><div class="line">  #display: always</div><div class="line">  #display: hide</div><div class="line">  #display: remove</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># ---------------------------------------------------------------</div><div class="line"># Misc Theme Settings</div><div class="line"># ---------------------------------------------------------------</div><div class="line"></div><div class="line"># Custom Logo.</div><div class="line"># !!Only available for Default Scheme currently.</div><div class="line"># Options:</div><div class="line">#   enabled: [true/false] - Replace with specific image</div><div class="line">#   image: url-of-image   - Images&apos;s url</div><div class="line">custom_logo:</div><div class="line">  enabled: false</div><div class="line">  image:</div><div class="line"></div><div class="line"></div><div class="line"># Code Highlight theme</div><div class="line"># Available value:</div><div class="line">#    normal | night | night eighties | night blue | night bright</div><div class="line"># https://github.com/chriskempson/tomorrow-theme</div><div class="line">highlight_theme: night</div><div class="line"></div><div class="line"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</div><div class="line">scroll_to_more: true</div><div class="line"></div><div class="line"># Automatically Excerpt</div><div class="line">auto_excerpt:</div><div class="line">  enable: false</div><div class="line">  length: 150</div><div class="line"></div><div class="line"># Use Lato font</div><div class="line">use_font_lato: true</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># ---------------------------------------------------------------</div><div class="line"># Third Party Services Settings</div><div class="line"># ---------------------------------------------------------------</div><div class="line"></div><div class="line"># MathJax Support</div><div class="line">mathjax:</div><div class="line"></div><div class="line"></div><div class="line"># Swiftype Search API Key</div><div class="line">#swiftype_key:</div><div class="line"></div><div class="line"># Baidu Analytics ID</div><div class="line">#baidu_analytics:</div><div class="line"></div><div class="line"># Duoshuo ShortName</div><div class="line">duoshuo_shortname: imwillxue</div><div class="line"></div><div class="line"># Disqus</div><div class="line">#disqus_shortname:</div><div class="line"></div><div class="line"># Baidu Share</div><div class="line"># Available value:</div><div class="line">#    button | slide</div><div class="line">#baidushare:</div><div class="line">##  type: button</div><div class="line"></div><div class="line"># Share</div><div class="line">#jiathis:</div><div class="line">#add_this_id:</div><div class="line"></div><div class="line"># Share</div><div class="line">duoshuo_share: true</div><div class="line"></div><div class="line"># Google Webmaster tools verification setting</div><div class="line"># See: https://www.google.com/webmasters/</div><div class="line">#google_site_verification:</div><div class="line"></div><div class="line"></div><div class="line"># Google Analytics</div><div class="line">#google_analytics:</div><div class="line"></div><div class="line"># CNZZ count</div><div class="line">#cnzz_siteid:</div><div class="line"></div><div class="line"></div><div class="line"># Make duoshuo show UA</div><div class="line"># user_id must NOT be null when admin_enable is true!</div><div class="line"># you can visit http://dev.duoshuo.com get duoshuo user id.</div><div class="line">duoshuo_info:</div><div class="line">  ua_enable: true</div><div class="line">  admin_enable: true</div><div class="line">  user_id: 6262178932196377345</div><div class="line">  admin_nickname: 神</div><div class="line"></div><div class="line"></div><div class="line"># Facebook SDK Support.</div><div class="line"># https://github.com/iissnan/hexo-theme-next/pull/410</div><div class="line">facebook_sdk:</div><div class="line">  enable: false</div><div class="line">  app_id:       #&lt;app_id&gt;</div><div class="line">  fb_admin:     #&lt;user_id&gt;</div><div class="line">  like_button:  #true</div><div class="line">  webmaster:    #true</div><div class="line"></div><div class="line"></div><div class="line"># Show number of visitors to each article.</div><div class="line"># You can visit https://leancloud.cn get AppID and AppKey.</div><div class="line">leancloud_visitors:</div><div class="line">  enable: true</div><div class="line">  app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz</div><div class="line">  app_key: AMcYaNHy9Y5OdH42k0d4uSED</div><div class="line"></div><div class="line"></div><div class="line"># Tencent analytics ID</div><div class="line"># tencent_analytics:</div><div class="line"></div><div class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</div><div class="line">baidu_push: true</div><div class="line"></div><div class="line">## 文章末尾是否显示打赏按钮</div><div class="line">donate:</div><div class="line">  enable: true</div><div class="line">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</div><div class="line">  alipay:</div><div class="line">  wechat:</div><div class="line"></div><div class="line"></div><div class="line">#! ---------------------------------------------------------------</div><div class="line">#! DO NOT EDIT THE FOLLOWING SETTINGS</div><div class="line">#! UNLESS YOU KNOW WHAT YOU ARE DOING</div><div class="line">#! ---------------------------------------------------------------</div><div class="line"></div><div class="line"># Motion</div><div class="line">use_motion: true</div><div class="line"></div><div class="line"># Fancybox</div><div class="line">fancybox: true</div><div class="line"></div><div class="line"># Static files</div><div class="line">vendors: vendors</div><div class="line">css: css</div><div class="line">js: js</div><div class="line">images: images</div><div class="line"></div><div class="line"># Theme version</div><div class="line">version: 0.5.0</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信页面开发的注意事项]]></title>
      <url>/2017/06/19/%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h2 id="页面搜索框"><a href="#页面搜索框" class="headerlink" title="页面搜索框"></a>页面搜索框</h2><ul>
<li>为了保持和微信搜索一致，搜索框未点击时搜索图标在中间显示，点击搜索框后，搜索图标在左边</li>
<li><p>实现手机键盘显示搜索按钮<code>&lt;form&gt;</code>标签里面包含<code>&lt;input type=search&gt;</code>，<code>&lt;form&gt;</code>标签必须有<code>action</code>属性,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;&quot; class=&quot;searchForm&quot; v-show=&quot;searchShow1&quot;&gt;</div><div class="line">            &lt;input type=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;搜索&quot; class=&quot;search&quot; @focus=&quot;searchFocus&quot;&gt;</div><div class="line">            &lt;i class=&quot;iconfont icon-sousuo icoImg&quot;&gt;&lt;/i&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;form action=&quot;&quot; class=&quot;searchForm2&quot; v-show=&quot;searchShow2&quot;&gt;</div><div class="line">            &lt;input type=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;搜索&quot; class=&quot;search&quot; v-model=&quot;keywords2&quot; @keydown=&quot;searchVk($event)&quot;&gt;</div><div class="line">            &lt;i class=&quot;iconfont icon-sousuo icoImg&quot; @click=&quot;getVkBusList()&quot;&gt;&lt;/i&gt;</div><div class="line">            &lt;span class=&quot;btn&quot; @click=&quot;cancelSearch&quot;&gt;取消&lt;/span&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>vue绑定事件在<code>&lt;input&gt;</code>标签上,用监听键盘事件<code>@keydown</code>,要使用<code>e.preventDefault()</code>阻止默认事件触发。</p>
<a id="more"></a>
<h2 id="页面1px边框显示问题"><a href="#页面1px边框显示问题" class="headerlink" title="页面1px边框显示问题"></a>页面1px边框显示问题</h2></li>
<li>使用淘宝的flexible.js插件转化为1rem.</li>
</ul>
<h2 id="微信页面禁止缩放页面"><a href="#微信页面禁止缩放页面" class="headerlink" title="微信页面禁止缩放页面"></a>微信页面禁止缩放页面</h2>]]></content>
      
        <categories>
            
            <category> 应用工具学习 </category>
            
            <category> 微信公众号 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 微信公众号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm,browser-sync,gulp工具的学习]]></title>
      <url>/2017/06/16/npm-browser-sync-gulp%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><ul>
<li>官网[<a href="https://www.npmjs.com" target="_blank" rel="external">https://www.npmjs.com</a>]</li>
<li>node package manager</li>
<li>命令:<ul>
<li>初始化:<code>npm init</code></li>
<li>安装指定包:<code>npm install jquery --save</code></li>
<li>删除指定包:<code>npm remove jquery --save</code></li>
<li>卸载一般用 npm uninstall –save jquery  或者 npm remove –save jquery</li>
<li>下载安装package.json中dependencies属性对的文件:<code>npm install --production</code></li>
</ul>
</li>
<li>npm的使用步骤<ul>
<li>第一步、npm init创建一个文件夹（注意：不要用中文名,不能以数字开头，不能有空格）</li>
<li>第二步、执行npm init -y</li>
<li>第三步、安装需要的js库 npm install –save jquery</li>
</ul>
</li>
</ul>
<h3 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h3><ul>
<li>更改代码之后自动刷新浏览器</li>
<li>需要使用npm进行全局安装:<code>npm install browser-sync -g</code>,-g表示安装到全局</li>
<li>使用:<code>browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot;</code></li>
<li>–files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。</li>
</ul>
<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><p>  <a href="http://www.gulpjs.com" target="_blank" rel="external">官网</a><br>  <a href="http://www.gulpjs.com.cn" target="_blank" rel="external">中文网</a></p>
<ul>
<li><p>前端自动化构建工具<br>js压缩,var x,xname，混淆<br>合并.<br>css压缩<br>html压压缩</p>
</li>
<li><p>grunt ,webpack…</p>
</li>
</ul>
<h3 id="核心就5个方法"><a href="#核心就5个方法" class="headerlink" title="核心就5个方法"></a>核心就5个方法</h3><ul>
<li>task,gulp中是一个个任务的形式来实现功能。<ul>
<li>task(‘任务名’,function(){<br>…..<br>});</li>
</ul>
</li>
<li>src<ul>
<li>src(‘./*.js’)</li>
</ul>
</li>
<li>dest(‘./minjs/‘)// 指定处理后的文件的输出路径.</li>
<li>watch(‘./*.js’,[‘任务名1’,’任务名2’]);</li>
<li>run(‘任务名’);//执行指定的任务.<a id="more"></a>
<h3 id="gulp的安装"><a href="#gulp的安装" class="headerlink" title="gulp的安装"></a>gulp的安装</h3></li>
<li>使用npm 进行安装</li>
<li><code>npm install gulp-cli -g</code>;</li>
</ul>
<h3 id="gulp-使用"><a href="#gulp-使用" class="headerlink" title="gulp 使用"></a>gulp 使用</h3><h4 id="使用时还需要在项目中通过npm非全局安装gulp"><a href="#使用时还需要在项目中通过npm非全局安装gulp" class="headerlink" title="使用时还需要在项目中通过npm非全局安装gulp"></a>使用时还需要在项目中通过npm非全局安装gulp</h4><ul>
<li><code>npm install gulp --save-dev</code><ul>
<li>-dev安装在本地</li>
<li>之所以在全局安装了一次还有在项目中安装，是为了保证gulp的版本的控制，每次使用的时候重新安装能控制gulp的版本</li>
</ul>
</li>
</ul>
<h4 id="还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码"><a href="#还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码" class="headerlink" title="还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码."></a>还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">// 得到gulp对象</div><div class="line">var gulp = require(&quot;gulp&quot;);</div><div class="line">//引入gulp-uglify插件 用来压缩js</div><div class="line">var uglify = require(&apos;gulp-uglify&apos;);</div><div class="line">//引入gulp-concat插件 用来合并代码 js,css都能合并</div><div class="line">var concat = require(&apos;gulp-concat&apos;);</div><div class="line">//引入gulp-cssnano插件 用来对css进行压缩</div><div class="line">var cssnano = require(&apos;gulp-cssnano&apos;);</div><div class="line">//引入gulp-htmlmin插件 用来对html代码进行压缩</div><div class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;);</div><div class="line">//引入gulp-imagemin插件 对图片进行压缩</div><div class="line">var imagemin = require(&apos;gulp-imagemin&apos;);</div><div class="line">//引入gulp-spriter插件 合并成精灵图</div><div class="line">var spriter = require(&apos;gulp-spriter&apos;);</div><div class="line">&lt;!-- more --&gt;</div><div class="line">//创建js压缩任务</div><div class="line">gulp.task(&apos;script&apos;,function()&#123;</div><div class="line">  // 这里写任务具体需要做的事情.</div><div class="line">  // 2.匹配到app.js文件,如果使用多个规则，需要以数组的形式来书写第一个参数，数组中的每一个元素都是一个规则。</div><div class="line">  gulp.src([&apos;./app.js&apos;,&apos;./signIn.js&apos;])</div><div class="line">  //合并后生成的文件名</div><div class="line">  .pipe(concat(&apos;all.js&apos;))</div><div class="line">  //调用方法 压缩js</div><div class="line">  .pipe(uglify())</div><div class="line">  //将合格的js文件 输出到指定目录</div><div class="line">  .pipe(gulp.dest(&apos;./dist&apos;))</div><div class="line">&#125;);</div><div class="line">//创建css压缩任务</div><div class="line">gulp.task(&apos;style&apos;,function()&#123;</div><div class="line">   // 匹配css文件</div><div class="line">   gulp.src([&apos;./style.css&apos;,&apos;./signIn.css&apos;])</div><div class="line">   .pipe(concat(&apos;all.css&apos;)) // 需要指定一个名字，作为压缩后文件的文件名</div><div class="line">   .pipe(cssnano())</div><div class="line">   .pipe(gulp.dest(&apos;./dist&apos;))</div><div class="line">&#125;);</div><div class="line">//创建html压缩任务</div><div class="line">gulp.task(&apos;htmlmin&apos;,function()&#123;</div><div class="line">    gulp.src(&apos;./index.html&apos;)</div><div class="line">        .pipe(htmlmin(&#123;</div><div class="line">            //collapseWhitespace:清除空格</div><div class="line">            collapseWhitespace:true,</div><div class="line">            //collapseBooleanAttributes:省略布尔属性的值，</div><div class="line">            collapseBooleanAttributes:true,</div><div class="line">            //removeComments:清除html中注释的部分</div><div class="line">            removeComments:true,</div><div class="line">            //removeEmptyAttributes:清除所有的空属性</div><div class="line">            removeEmptyAttributes:true,</div><div class="line">            //removeSciptTypeAttributes:清除所有script标签中的type=&quot;text/javascript&quot;属性。</div><div class="line">            removeScriptTypeAttributes:true,</div><div class="line">            //removeStyleLinkTypeAttributes:清楚所有Link标签上的type属性</div><div class="line">            removeStyleLinkTypeAttributes:true,</div><div class="line">            //minifyJS:压缩html中的javascript代码。</div><div class="line">            minifyJS:true,</div><div class="line">            //minifyCSS:压缩html中的css代码</div><div class="line">            minifyCSS:true</div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(&apos;./dist&apos;));</div><div class="line">&#125;);</div><div class="line">//创建合并压缩方法</div><div class="line">gulp.task(&apos;concat&apos;,function()&#123;</div><div class="line">    // 匹配文件</div><div class="line">    gulp.src([&apos;./1.js&apos;,&apos;./2.js&apos;])</div><div class="line">        //调用合并方法 生成新的文件名</div><div class="line">        .pipe(concat(&apos;index.js&apos;))</div><div class="line">        //调用压缩方法</div><div class="line">        .pipe(uglify())</div><div class="line">        //输出到指定目录</div><div class="line">        .pipe(gulp.dest(&apos;./build&apos;));</div><div class="line">&#125;)</div><div class="line">//创建图片压缩方法</div><div class="line">gulp.task(&apos;imagemin&apos;,function()&#123;</div><div class="line">  //引入图片地址方法</div><div class="line">  gulp.src(&apos;./images/*&apos;)</div><div class="line">      //调用图片压缩</div><div class="line">      .pipe(imagemin())</div><div class="line">      //输出压缩后图片的存放地址</div><div class="line">      .pipe(gulp.dest(&apos;dist/images&apos;));</div><div class="line">&#125;);</div><div class="line">//创建合并精灵图任务</div><div class="line">gulp.task(&apos;spriter&apos;,function()&#123;</div><div class="line">  return gulp.src(&apos;./style.css&apos;)//原始的css文件地址</div><div class="line">             //调用spriter精灵图合并方法</div><div class="line">             .pipe(spriter(&#123;</div><div class="line">               sprite:&apos;test.png&apos;,//合并后图片的名字</div><div class="line">               slice:&apos;./slice&apos;,//原始小图片路径</div><div class="line">               outpath:&apos;build/tests&apos;//合并后的大图的地址</div><div class="line">             &#125;))</div><div class="line">             //合并精灵图后的css的文件地址</div><div class="line">             .pipe(gulp.dest(&apos;./build/css&apos;));</div><div class="line">&#125;)</div><div class="line">//创建监视任务</div><div class="line">gulp.task(&quot;watch&quot;,function()&#123;</div><div class="line">      //调用watch方法</div><div class="line">      //第一个参数是监视目标文件,第二个参数是执行的任务</div><div class="line">      gulp.watch([&apos;./app.js&apos;,&apos;./signIn.js&apos;],[&quot;script&quot;]);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用方法直接在控制台输入<code>gulp 任务名</code></li>
</ul>
<h3 id="gulp监视文件的改变"><a href="#gulp监视文件的改变" class="headerlink" title="gulp监视文件的改变"></a>gulp监视文件的改变</h3><ul>
<li>监视文件,当文件发生改变时,watch方法就会执行目标文件所绑定的事件</li>
<li>使用：在cmd命令窗口直接调用gulp myWatch方法</li>
<li>第一个参数是监视目标文件,第二个参数是执行的任务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gulp.task(&quot;myWatch&quot;,function()&#123;</div><div class="line">    gulp.watch([&quot;./a.html&quot;,&quot;./b.html&quot;],function()&#123;</div><div class="line">        console.console.log()</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="gup-结合browsr-sync使用"><a href="#gup-结合browsr-sync使用" class="headerlink" title="gup 结合browsr-sync使用"></a>gup 结合browsr-sync使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//gulp结合browser-sync一起使用</div><div class="line">//当你改动html,css,js的时候 --&gt; 合并,压缩我们的html,js,css --&gt; browser-sync刷新浏览器</div><div class="line">//使用之前要在当前项目安装browser-sync 命令:npm install --save-dev browser-sync</div><div class="line">var browserSync = require(&apos;browser-sync&apos;) //得到browserSync对象</div><div class="line">//创建browserSync任务</div><div class="line">gulp.task(&quot;browserSync&quot;,function()&#123; // 静态服务器</div><div class="line">        //第一步先用gulp监视index.html,如果有改动就会执行htmlmin这个任务</div><div class="line">        gulp.watch([&quot;./index.html&quot;],[&quot;htmlmin&quot;]);</div><div class="line">        //第二步开启browserSyn,一旦html文件夹里面压缩的html有改动，就会刷新浏览器</div><div class="line">        browserSync(&#123;</div><div class="line">            server:&#123;</div><div class="line">                baseDir:&quot;./html&quot; //创建服务器的文件夹</div><div class="line">            &#125;,</div><div class="line">            files:[&quot;./html/index.html&quot;] //同步的html代码</div><div class="line">        &#125;);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h3 id="gulp的一些插件"><a href="#gulp的一些插件" class="headerlink" title="gulp的一些插件"></a>gulp的一些插件</h3><ul>
<li>也是使用npm安装</li>
<li>对js代码进行压缩 gulp-uglify</li>
<li>对代码进行合并 gulp-concat</li>
<li>对css进行压缩 gulp-cssnano</li>
<li>对html进行压缩 gulp-htmlmin</li>
<li>对图片进行压缩  gulp-imagemin</li>
<li>合并精灵图  gulp-spriter</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端构建生态 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
            <tag> browser-sync </tag>
            
            <tag> gulp </tag>
            
            <tag> 前端自动化工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git的使用]]></title>
      <url>/2017/06/16/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git?"></a>什么是Git?</h3><ul>
<li>Git是一款源代码管理工具(版本控制工具)<ul>
<li>我们写的代码需要使用Git进行管理。</li>
</ul>
</li>
</ul>
<h3 id="分布式，集中式版本管理工具"><a href="#分布式，集中式版本管理工具" class="headerlink" title="分布式，集中式版本管理工具"></a>分布式，集中式版本管理工具</h3><ul>
<li>git属于分布式</li>
<li>svn集中式</li>
</ul>
<h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><h3 id="git初始化一个仓库"><a href="#git初始化一个仓库" class="headerlink" title="git初始化一个仓库"></a>git初始化一个仓库</h3><ul>
<li>创建一个.git隐藏目录</li>
<li>命令:<code>git init</code>;<ul>
<li>想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令.</li>
<li>一般是在项目的根目录执行这个命令.</li>
</ul>
</li>
</ul>
<h3 id="自报家门"><a href="#自报家门" class="headerlink" title="自报家门"></a>自报家门</h3><ul>
<li>配置用户名 : <code>git config user.name &quot;testName&quot;</code></li>
<li>配置邮箱   : <code>git config user.email &quot;test@sina.com&quot;</code></li>
<li>查看配置信息: <code>git config --list</code></li>
</ul>
<h3 id="把代码提交到仓库中"><a href="#把代码提交到仓库中" class="headerlink" title="把代码提交到仓库中"></a>把代码提交到仓库中</h3><ul>
<li><p>1.先把代码添加到暂存区(就相当于放到仓库门口)</p>
<ul>
<li>命令:<code>git add 文件路径</code></li>
<li>示例:<code>git add ./reademe.md</code></li>
<li>可以使用<code>git add .</code>这个命令，批量把当前目录下所有修改过的文件添加到暂存区。</li>
</ul>
</li>
<li><p>2.把暂存区的文件提交仓库里</p>
<ul>
<li>命令: <code>git commit -m &quot;注释&quot;</code></li>
<li>示例: <code>git commit -m &quot;我们添加了一个新的功能&quot;</code></li>
<li>-m 表示指定一个字符串，作为提交的说明(相当于注释);</li>
</ul>
</li>
<li><p>合并add 与commit 命令</p>
<ul>
<li><code>git commit -a -m &quot;这是使用合并添加与提交的操作&quot;</code>;</li>
<li>这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用)</li>
</ul>
</li>
</ul>
<h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><ul>
<li>命令:<code>git status</code></li>
</ul>
<h3 id="添加忽略文件"><a href="#添加忽略文件" class="headerlink" title="添加忽略文件"></a>添加忽略文件</h3><ul>
<li>在项目中有一些文件是不需要提交的,我们需要把它忽略掉</li>
<li>需要在.git文件夹所在目录新建一个名为.gitignore的文件<br>然后在这个文件中写上需要被忽略的文件的路径。<br>示例: /css/a.css<pre><code>: /css/*.css
: /a.html
</code></pre></li>
</ul>
<h3 id="对比文件差异"><a href="#对比文件差异" class="headerlink" title="对比文件差异"></a>对比文件差异</h3><ul>
<li>命令: <code>git diff</code><ul>
<li>用来比较暂存区文件内容与工作区文件内容的区别</li>
<li>如果暂存区没有文件，就会将工作与代码与最近一次提交对比</li>
</ul>
</li>
<li>命令：<code>git diff --cached</code>  比较暂存区的文件和仓库中文件的区别</li>
<li>对比之前某两次提交的文件的差异<ul>
<li>命令:<code>git diff [版本号1] [版本号2] [想比较的文件路径]</code></li>
</ul>
</li>
</ul>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><ul>
<li>命令:<code>git log</code>,可以查看每一次提交的日志</li>
<li>命令:<code>git log --oneline</code> 表示使用简洁的形式输出提交日志</li>
</ul>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul>
<li>命令:<code>git reset --hard Head~1</code><ul>
<li>这是将代码回退到上上一次提交时的状态</li>
</ul>
</li>
<li>命令:<code>git reset --hard Head~2</code><ul>
<li>回退到上上上次</li>
</ul>
</li>
<li><p>命令:<code>git reset --hard Head~0</code></p>
<ul>
<li>回退到上次提交时的状态,~0可以省略</li>
</ul>
</li>
<li><p>命令:<code>git reset --hard 版本号</code></p>
<ul>
<li>通过每次提交时生成的版本号来回退版本</li>
</ul>
</li>
<li><p>通过<code>git reflog</code>命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。</p>
<a id="more"></a>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3></li>
<li>命令:<code>git branch [分支名]</code><ul>
<li>创建一个新分支</li>
</ul>
</li>
<li>命令:<code>git branch</code><ul>
<li>查看当前所有的分支</li>
</ul>
</li>
</ul>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><ul>
<li>命令:<code>git checkout [分支名]</code><ul>
<li>切换分支后可以在切换后的分支中进行正常的操作</li>
</ul>
</li>
</ul>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul>
<li>命令:<code>git merge [分支名]</code><ul>
<li>git会将指定的分支合并到当前分支.</li>
</ul>
</li>
</ul>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ul>
<li>命令:<code>git branch -d [分支名]</code><ul>
<li>删除指定分支，-d参数表示要执行删除操作</li>
</ul>
</li>
</ul>
<h3 id="git提交中的冲突"><a href="#git提交中的冲突" class="headerlink" title="git提交中的冲突"></a>git提交中的冲突</h3><ul>
<li>如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交</li>
</ul>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><h3 id="github与git"><a href="#github与git" class="headerlink" title="github与git"></a>github与git</h3><ul>
<li>git 版本管理工具</li>
<li>github 就是一个网站，只是这个网站提供git服务器的功能</li>
</ul>
<h3 id="上传代码到git服务器-push"><a href="#上传代码到git服务器-push" class="headerlink" title="上传代码到git服务器(push)"></a>上传代码到git服务器(push)</h3><ul>
<li><p>命令:<code>git push [远程服务器地址] [远程服务器的分支]</code></p>
<ul>
<li>示例:<code>git push https://github.com/huoqishi/test002.git master</code></li>
</ul>
</li>
<li><p>上传时可以使用一些简化的命令</p>
<ul>
<li>将远程服务器地址写成变量的形式<ul>
<li><code>git remote add [变量名]  [远程服务器地址]</code></li>
<li>示例:<code>git remote add origin https://github.com/huoqishi/test002.git</code></li>
<li>这样之后就可以直接使用origin来代替git push 后面写的地址了<br><code>git push origin master</code></li>
</ul>
</li>
</ul>
</li>
<li>还可以尽一步简化<ul>
<li>在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了<code>git push origin</code>;</li>
</ul>
</li>
</ul>
<h2 id="git使用ssh方式上传代码与github"><a href="#git使用ssh方式上传代码与github" class="headerlink" title="git使用ssh方式上传代码与github"></a>git使用ssh方式上传代码与github</h2><ul>
<li>git生成公钥和私钥<ul>
<li>命令:<code>ssh-keygen -t rsa</code>生成的公钥与私钥文件会在当用户目录的.ssh目录下.</li>
<li>找到生成的ssh钥匙文件的地址：C盘/用户/用户名/.ssh/id_rsa.pub 找到公钥</li>
<li>在github右上角 –&gt; setting –&gt; ssh设置选项</li>
<li>把我们的公钥拷贝到github当中</li>
<li>以后push代码仓库的时候，使用ssh协议，也就是去使用git开头的那个链接</li>
</ul>
</li>
</ul>
<h3 id="拉取github服务器上的代码及多人协作冲突处理"><a href="#拉取github服务器上的代码及多人协作冲突处理" class="headerlink" title="拉取github服务器上的代码及多人协作冲突处理"></a>拉取github服务器上的代码及多人协作冲突处理</h3><ul>
<li>从服务器拉取代码的方式<ul>
<li>方式一:’git clone git url’</li>
<li>方式二:’git init’<pre><code>+ &apos;git pull url&apos;
</code></pre></li>
</ul>
</li>
<li>git pull和git clone这二种拉取方式的区别：<ul>
<li>用git pull的话默认没有设置origin这个变量，必须自己手动设置(git remote add …..),而用了git clone则不需要了，默认origin这个变量就存在了</li>
</ul>
</li>
</ul>
<h3 id="把代码push到服务器时需要先pull一下"><a href="#把代码push到服务器时需要先pull一下" class="headerlink" title="把代码push到服务器时需要先pull一下"></a>把代码push到服务器时需要先pull一下</h3><ul>
<li>在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。</li>
<li>解决拒绝提交代码<ul>
<li>执行git pull origin master</li>
<li>手动更改代码，解决冲突</li>
<li>执行:’git add’</li>
<li>执行:’git commit</li>
<li>执行:’git pull origin master’</li>
<li>执行:’git push origin master’</li>
</ul>
</li>
<li>如何避免尽量不会出现冲突？ <ul>
<li>在每次push之前执行一次git pull</li>
<li>git pull的作用：<ul>
<li>更新本地仓库至最新改动，相当于先从远程服务器获取最新代码，接着进行自动合并(merge)，如果有冲突会提示你冲突，让你在本地手动解决掉冲突之后，再推送到服务器上面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多人共同使用同一个github服务器仓库"><a href="#多人共同使用同一个github服务器仓库" class="headerlink" title="多人共同使用同一个github服务器仓库"></a>多人共同使用同一个github服务器仓库</h3><ul>
<li>第一步、建立好一个github上面的仓库</li>
<li>第二步、点击setting</li>
<li>第三步、点击add collaborator，在里面找到你的小伙伴的用户名</li>
<li>第四步、生成一个邀请链接</li>
<li>第五步、把这个链接发给你的小伙伴，他同意之后就可以把自己写的代码提交到这个仓库了</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端构建生态 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 代码提交 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vuex学习]]></title>
      <url>/2017/06/05/vuex%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="理解Vuex"><a href="#理解Vuex" class="headerlink" title="理解Vuex"></a>理解Vuex</h1><ul>
<li>运用Vue进行多组件开发时，多个组件间的数据通信和状态管理很难维护，使用Vuex将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了。</li>
</ul>
<h2 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h2><ul>
<li>vuex的状态自管理应用包含以下几个部分<ul>
<li>state，驱动应用的数据源;</li>
<li>view，以声明方式将state映射到视图； </li>
<li>actions，响应在view上的用户输入导致的状态变化<a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ul>
<li>每个应用将仅仅包含一个 store 实例,用来存储状态</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
            <category> 组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
            <tag> 状态管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扎实基础JS一]]></title>
      <url>/2017/06/03/%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80JS%E4%B8%80/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> ECMAScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扎实基础CSS一]]></title>
      <url>/2017/06/03/%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80CSS%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="文本超出显示省略号"><a href="#文本超出显示省略号" class="headerlink" title="文本超出显示省略号"></a>文本超出显示省略号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">width: 300px //要设置宽度</div><div class="line">overflow: hidden;</div><div class="line">white-space: nowrap;</div><div class="line"> text-overflow: ellipsis;</div></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css常用属性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扎实基础HTML一]]></title>
      <url>/2017/06/03/%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80HTML%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="html5新增的音频和视频"><a href="#html5新增的音频和视频" class="headerlink" title="html5新增的音频和视频"></a>html5新增的音频和视频</h2><ul>
<li>音频audio<code>&lt;audio src=&#39;&#39;&gt;&lt;/audio&gt;</code></li>
<li>视频video<code>&lt;video src=&#39;&#39;&gt;&lt;/video&gt;</code></li>
</ul>
<h2 id="html5语义化标签的使用"><a href="#html5语义化标签的使用" class="headerlink" title="html5语义化标签的使用"></a>html5语义化标签的使用</h2><ol>
<li>头部–header和nav标签</li>
</ol>
<ul>
<li>header头部，body下的直接子元素header一般用于放页面的介绍性的信息如网站名称、logo或者导航栏nav。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;header&gt;</div><div class="line">    &lt;h1&gt;html5语义化标签&lt;/h1&gt;</div><div class="line">    &lt;nav&gt;</div><div class="line">        &lt;h1&gt;导航&lt;/h1&gt;</div><div class="line">        &lt;ul&gt;</div><div class="line">            &lt;li&gt;章节标签&lt;/li&gt;</div><div class="line">            &lt;li&gt;标题标签&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">    &lt;/nav&gt;</div><div class="line">&lt;/header&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ol>
<li>主体部分——main和section</li>
</ol>
<ul>
<li>main标签表示页面的主体部份，section标签给页面区分不同的章节。section是一个章节标签，构建页面的大纲(outline)。除此外还有nav、artical和aside三个标签能够勾勒页面的轮廓。章节标签通常会带上h1~h6的标题标签。不同的章节标题是独立的，嵌套的章节标题也跟着嵌套。另外多个标题可以用hgroup包括起来，在页面提纲里成为独立的一条内容。</li>
<li><code>&lt;hgroup&gt;</code>标签用于对网页或区段（section）的标题进行组合。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> &lt;main&gt;</div><div class="line">    &lt;section&gt;</div><div class="line">        &lt;hgroup&gt;</div><div class="line">            &lt;h2&gt;章节标签&lt;/h2&gt;</div><div class="line">            &lt;p&gt;为页面区分不同的章节&lt;/p&gt;</div><div class="line">        &lt;/hgroup&gt;</div><div class="line">        &lt;div&gt;包括section article nav aside &lt;/div&gt;</div><div class="line">    &lt;/section&gt;</div><div class="line">    &lt;section&gt;</div><div class="line">        &lt;hgroup&gt;</div><div class="line">            &lt;h2&gt;标题标签&lt;/h2&gt;</div><div class="line">            &lt;p&gt;为不同的章节定义标题&lt;/p&gt;</div><div class="line">        &lt;/hgroup&gt; </div><div class="line">        &lt;div&gt;h1 h2 h3 h4 h5 h6六个标题标签&lt;/div&gt;</div><div class="line">    &lt;/section&gt;</div><div class="line">&lt;/main&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>尾部——footer</li>
</ol>
<ul>
<li>footer和header一样，用在不同的章节里，可以显示该章节（如body整个页面）相关的外链、版权等信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;footer&gt;</div><div class="line">        &lt;p&gt;copyright &amp;copy hello, world&lt;/p&gt;</div><div class="line">&lt;/footer&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>div和section、section和article的区别</li>
</ol>
<ul>
<li>div是一个普通的容器，而section不能当作一个普通的容器使用，使用section要让其起outline的作用，而article比section的章节概念更强。article适用于独立性强的内容，如本身就是一篇文章、博客，或者用户的评论等，article比section更加强调需要包含一个标题标签h1~h6。如果使用article的语义性更好的时候，就不用section。或者，内容可再继续细分章节的也应使用article。</li>
<li>章节的内容是独立的，并且可以嵌套</li>
<li>独立是指每个章节都可以有自己的标题标签、header、footer和nav，并且章节可以相互嵌套<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;h1&gt;html标签&lt;/h1&gt;</div><div class="line">    &lt;article&gt;</div><div class="line">        &lt;h1&gt;html5标签&lt;/h1&gt;</div><div class="line">        &lt;section&gt;</div><div class="line">            &lt;h1&gt;标题标签&lt;/h1&gt;</div><div class="line">        &lt;/section&gt;</div><div class="line">        &lt;section&gt;</div><div class="line">            &lt;h1&gt;章节标签&lt;/h1&gt;</div><div class="line">        &lt;/section&gt;</div><div class="line">    &lt;/article&gt;</div><div class="line">    &lt;article&gt;</div><div class="line">        &lt;h1&gt;html4标签&lt;/h1&gt;</div><div class="line">    &lt;/article&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>5 其它常用标签</p>
<ul>
<li><p>figure用作照片及其注释的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;figure&gt;</div><div class="line">       &lt;img src=&quot;Mars.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">       &lt;figcaption&gt;火星&lt;/figcaption&gt;</div><div class="line">   &lt;/figure&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>aside的内容与页面的主体内容相切，可用作侧边栏</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html常见标签 </tag>
            
            <tag> html5语义化标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue脚手架vue-cli的学习一]]></title>
      <url>/2017/06/03/vue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="vue-cli的模板"><a href="#vue-cli的模板" class="headerlink" title="vue-cli的模板"></a>vue-cli的模板</h1><ul>
<li>vue-cli的脚手架项目模板有webpack-simple 和 webpack</li>
<li>两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能</li>
</ul>
<h1 id="vue-cli的项目结构"><a href="#vue-cli的项目结构" class="headerlink" title="vue-cli的项目结构"></a>vue-cli的项目结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">|-- build                            // 项目构建(webpack)相关代码</div><div class="line">|   |-- build.js                     // 生产环境构建代码</div><div class="line">|   |-- check-version.js             // 检查node、npm等版本</div><div class="line">|   |-- dev-client.js                // 热重载相关</div><div class="line">|   |-- dev-server.js                // 构建本地服务器</div><div class="line">|   |-- utils.js                     // 构建工具相关</div><div class="line">|   |-- webpack.base.conf.js         // webpack基础配置</div><div class="line">|   |-- webpack.dev.conf.js          // webpack开发环境配置</div><div class="line">|   |-- webpack.prod.conf.js         // webpack生产环境配置</div><div class="line">|-- config                           // 项目开发环境配置</div><div class="line">|   |-- dev.env.js                   // 开发环境变量</div><div class="line">|   |-- index.js                     // 项目一些配置变量</div><div class="line">|   |-- prod.env.js                  // 生产环境变量</div><div class="line">|   |-- test.env.js                  // 测试环境变量</div><div class="line">|-- src                              // 源码目录</div><div class="line">|   |-- components                     // vue公共组件</div><div class="line">|   |-- store                          // vuex的状态管理</div><div class="line">|   |-- App.vue                        // 页面入口文件</div><div class="line">|   |-- main.js                        // 程序入口文件，加载各种公共组件</div><div class="line">|-- static                           // 静态文件，比如一些图片，json数据等</div><div class="line">|   |-- data                           // 群聊分析得到的数据用于数据可视化</div><div class="line">|-- .babelrc                         // ES6语法编译配置</div><div class="line">|-- .editorconfig                    // 定义代码格式</div><div class="line">|-- .gitignore                       // git上传需要忽略的文件格式</div><div class="line">|-- README.md                        // 项目说明</div><div class="line">|-- favicon.ico </div><div class="line">|-- index.html                       // 入口页面</div><div class="line">|-- package.json                     // 项目基本信息</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h1><ul>
<li>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。<h2 id="自定义npm相关命令"><a href="#自定义npm相关命令" class="headerlink" title="自定义npm相关命令"></a>自定义npm相关命令</h2></li>
<li>在package.json文件里有一个scripts字段。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,</div><div class="line">    &quot;build&quot;: &quot;node build/build.js&quot;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在开发环境下，在命令行中运行npm run dev就相当于在执行node build/dev-server.js。所以script字段是用来指定npm相关命令的缩写的。</p>
<h2 id="dependencies字段和devDependencies字段"><a href="#dependencies字段和devDependencies字段" class="headerlink" title="dependencies字段和devDependencies字段"></a>dependencies字段和devDependencies字段</h2><ul>
<li>dependencies字段指定了项目运行时所依赖的模块</li>
<li>devDependencies字段指定了项目开发时所依赖的模块(项目环境依赖)</li>
<li>在命令行中运行npm install命令，会自动安装dependencies和devDependencies字段中的模块。<h2 id="webpack配置相关"><a href="#webpack配置相关" class="headerlink" title="webpack配置相关"></a>webpack配置相关</h2></li>
<li>详情在webpack相关博客<h3 id="dev-server-js"><a href="#dev-server-js" class="headerlink" title="dev-server.js"></a>dev-server.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line">// http-proxy可以实现转发所有请求代理到后端真实API地址，以实现前后端开发完全分离</div><div class="line">// 在config/index.js中可以对proxyTable想进行配置</div><div class="line">var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)</div><div class="line">...</div><div class="line">...</div><div class="line">// 热加载要使用webpack-dev-middleware在没有webpack-dev-server的时候进行热加载</div><div class="line">var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)</div><div class="line">// 当html-webpack-plugin模板改变是强制进行页面重新加载</div><div class="line">compiler.plugin(&apos;compilation&apos;, function (compilation) &#123;</div><div class="line">  compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) &#123;</div><div class="line">    hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;)</div><div class="line">    cb()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line">module.export = &#123;</div><div class="line">    // 编译入口文件</div><div class="line">    entry: &#123;&#125;,</div><div class="line">    // 编译输出路径</div><div class="line">    output: &#123;&#125;,</div><div class="line">    // 一些解决方案配置</div><div class="line">    resolve: &#123;&#125;,</div><div class="line">    resolveLoader: &#123;&#125;,</div><div class="line">    module: &#123;</div><div class="line">        // 各种不同类型文件加载器配置</div><div class="line">        loaders: &#123;</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        // js文件用babel转码</div><div class="line">        &#123;</div><div class="line">            test: /\.js$/,</div><div class="line">            loader: &apos;babel&apos;,</div><div class="line">            include: projectRoot,</div><div class="line">            // 哪些文件不需要转码</div><div class="line">            exclude: /node_modules/</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    // vue文件一些相关配置</div><div class="line">    vue: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="check-version-js"><a href="#check-version-js" class="headerlink" title="check-version.js"></a>check-version.js</h3><ul>
<li>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// 加载语义化版本测试库</div><div class="line">var semver = require(&apos;semver&apos;)</div><div class="line">// 定制控制台日志的输入样式</div><div class="line">var chalk = require(&apos;chalk&apos;)</div><div class="line">// 引入package.json文件</div><div class="line">var packageConfig = require(&apos;../package.json&apos;)</div><div class="line">var exec = function (cmd) &#123;</div><div class="line">  return require(&apos;child_process&apos;)</div><div class="line">    .execSync(cmd).toString().trim()</div><div class="line">&#125;</div><div class="line">// 定义node和npm版本需求所组成的数组</div><div class="line">var versionRequirements = [</div><div class="line">  &#123;</div><div class="line">    name: &apos;node&apos;,</div><div class="line">    currentVersion: semver.clean(process.version),</div><div class="line">    versionRequirement: packageConfig.engines.node</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: &apos;npm&apos;,</div><div class="line">    currentVersion: exec(&apos;npm --version&apos;),</div><div class="line">    versionRequirement: packageConfig.engines.npm</div><div class="line">  &#125;</div><div class="line">]</div><div class="line">module.exports = function () &#123;</div><div class="line">  var warnings = []</div><div class="line">  // 依次判断版本是否符合要求</div><div class="line">  for (var i = 0; i &lt; versionRequirements.length; i++) &#123;</div><div class="line">    var mod = versionRequirements[i]</div><div class="line">    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</div><div class="line">      warnings.push(mod.name + &apos;: &apos; +</div><div class="line">        chalk.red(mod.currentVersion) + &apos; should be &apos; +</div><div class="line">        chalk.green(mod.versionRequirement)</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><ul>
<li>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 设定转码规则</div><div class="line">&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],</div><div class="line">// 转码的一些插件</div><div class="line">&quot;plugins&quot;: [&quot;transform-runtime&quot;],</div><div class="line">&quot;comments&quot;: false</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h3><ul>
<li>该文件定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = true</div><div class="line"></div><div class="line">[*]    // 对所有文件应用下面的规则</div><div class="line">charset = utf-8                    // 编码规则用utf-8</div><div class="line">indent_style = space               // 缩进用空格</div><div class="line">indent_size = 2                    // 缩进数量为2个空格</div><div class="line">end_of_line = lf                   // 换行符格式</div><div class="line">insert_final_newline = true        // 是否在文件的最后插入一个空行</div><div class="line">trim_trailing_whitespace = true    // 是否删除行尾的空格</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h1><ul>
<li>在<code>config/index.js</code>文件中配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//配置代理</div><div class="line">proxyTable: &#123;</div><div class="line">  &apos;/api/&apos;: &#123;</div><div class="line">    target: &apos;http://localhost:3000&apos;,</div><div class="line">    changeOrigin: true,</div><div class="line">    pathRewrite: &#123;</div><div class="line">      &apos;^/api&apos;: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[axios的使用]]></title>
      <url>/2017/05/24/axios%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><ul>
<li>基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用</li>
</ul>
<h1 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h1><ul>
<li>在浏览器中发送 XMLHttpRequests 请求</li>
<li>在 node.js 中发送 http请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持保护安全免受 XSRF 攻击 </li>
</ul>
<h1 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h1><ul>
<li><p>可以为每一个请求指定默认配置。</p>
<h2 id="全局-axios-默认配置"><a href="#全局-axios-默认配置" class="headerlink" title="全局 axios 默认配置"></a>全局 axios 默认配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</div><div class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</div><div class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</div></pre></td></tr></table></figure>
<h2 id="自定义实例默认配置"><a href="#自定义实例默认配置" class="headerlink" title="自定义实例默认配置"></a>自定义实例默认配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let axiosIns = axios.create(&#123;</div><div class="line">  baseURL: &apos;https://api.example.com&apos;,</div><div class="line">  timeout: 10 * 1000</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h1><ul>
<li><p>axios.get(url[, config])</p>
</li>
<li><p>axios.delete(url[, config])</p>
</li>
<li><p>axios.head(url[, config])</p>
</li>
<li><p>axios.post(url[, data[, config]])</p>
</li>
<li><p>axios.put(url[, data[, config]])</p>
</li>
<li><p>axios.patch(url[, data[, config]])</p>
<a id="more"></a>
</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><ul>
<li><p>发送一个 GET 请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// Make a request for a user with a given ID</div><div class="line">axios.get(&apos;/user?ID=12345&apos;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">// Optionally the request above could also be done as</div><div class="line">axios.get(&apos;/user&apos;, &#123;</div><div class="line">    params: &#123;</div><div class="line">      ID: 12345</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>发送一个 POST 请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">axios.post(&apos;/user&apos;, &#123;</div><div class="line">    firstName: &apos;Fred&apos;,</div><div class="line">    lastName: &apos;Flintstone&apos;</div><div class="line">  &#125;)</div><div class="line">  .then(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(function (response) &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>发送多个并发请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function getUserAccount() &#123;</div><div class="line">  return axios.get(&apos;/user/12345&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getUserPermissions() &#123;</div><div class="line">  return axios.get(&apos;/user/12345/permissions&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">axios.all([getUserAccount(), getUserPermissions()])</div><div class="line">  .then(axios.spread(function (acct, perms) &#123;</div><div class="line">    // Both requests are now complete</div><div class="line">  &#125;));</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h1><ul>
<li>可以通过给 axios传递对应的参数来定制请求：axios(config)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">axios(&#123;</div><div class="line">  method: &apos;post&apos;,</div><div class="line">  url: &apos;/user/12345&apos;,</div><div class="line">  data: &#123;</div><div class="line">    firstName: &apos;Fred&apos;,</div><div class="line">    lastName: &apos;Flintstone&apos;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //用来向服务器发送请求的url地址  </div><div class="line">  url: &apos;/user&apos;, </div><div class="line">  //请求方法，默认是GET方法</div><div class="line">  method: &apos;get&apos;, </div><div class="line">  //基础URL路径，假如url不是绝对路径，如 https://some-domain.com/api/v1/login?name=jack,那么向服务器发送请求的URL将会是baseURL + url</div><div class="line">  baseURL: &apos;https://some-domain.com/api/&apos;, </div><div class="line">  // transformRequest方法允许在请求发送到服务器之前修改该请求，此方法只适用于PUT、POST和PATCH方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。</div><div class="line">  transformRequest: [function (data) &#123;</div><div class="line">    // Do whatever you want to transform the data</div><div class="line">    return data;</div><div class="line">  &#125;],</div><div class="line">  //transformResponse方法允许在数据传递到then/catch之前修改response数据。此方法最后也要返回数据。</div><div class="line">  transformResponse: [function (data) &#123;</div><div class="line">    // Do whatever you want to transform the data</div><div class="line">    return data;</div><div class="line">  &#125;],</div><div class="line">  // 发送自定义Headers头文件，头文件中包含了http请求的各种信息。</div><div class="line">  headers: &#123;&apos;Content-Type&apos;:&apos;application/json&apos;&#125;,</div><div class="line">  //  params是发送请求的查询参数对象，对象中的数据会被拼接成url?param1=value1&amp;param2=value2。 </div><div class="line">  params: &#123;</div><div class="line">    ID: 12345</div><div class="line">  &#125;,</div><div class="line">  //params参数序列化器</div><div class="line">  paramsSerializer: function(params) &#123;</div><div class="line">    return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;)</div><div class="line">  &#125;,</div><div class="line">  //data是在发送POST、PUT或者PATCH请求的数据对象。</div><div class="line">  data: &#123;</div><div class="line">    firstName: &apos;Fred&apos;</div><div class="line">  &#125;,</div><div class="line">  //请求超时设置，单位为毫秒</div><div class="line">  timeout: 1000,</div><div class="line">  //表明是否有跨域请求需要用到证书</div><div class="line">  withCredentials: false, // default</div><div class="line">  //adapter允许用户处理更易于测试的请求。返回一个Promise和一个有效的response</div><div class="line">  adapter: function (resolve, reject, config) &#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;,</div><div class="line">  //auth表明提供凭证用于完成http的身份验证。这将会在headers中设置一个Authorization授权信息。自定义Authorization授权要设置在headers中。</div><div class="line">  auth: &#123;</div><div class="line">    username: &apos;janedoe&apos;,</div><div class="line">    password: &apos;s00pers3cret&apos;</div><div class="line">  &#125;</div><div class="line">  //表示服务器将返回响应的数据类型，有arraybuffer、blob、document、json、text、stream这6个类型，默认是json类似数据。</div><div class="line">  responseType: &apos;json&apos;, // default</div><div class="line">  // 用作 xsrf token 值的 cookie 名称</div><div class="line">  xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default</div><div class="line">  // 带有 xsrf token 值 http head 名称</div><div class="line">  xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default</div><div class="line">  // 允许在上传过程中的做一些操作,允许在下载过程中的做一些操作</div><div class="line">  progress: function(progressEvent) &#123;</div><div class="line">    // Do whatever you want with the native progress event</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="响应的数据结构"><a href="#响应的数据结构" class="headerlink" title="响应的数据结构"></a>响应的数据结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // 服务器返回的数据</div><div class="line">  data: &#123;&#125;,</div><div class="line"></div><div class="line">  // HTTP状态吗</div><div class="line">  status: 200,</div><div class="line"></div><div class="line">  // 服务器返回的消息</div><div class="line">  statusText: &apos;OK&apos;,</div><div class="line"></div><div class="line">  // 返回头</div><div class="line">  headers: &#123;&#125;,</div><div class="line"></div><div class="line">  // 在返回我们的配置</div><div class="line">  config: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> axios </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-router的使用一]]></title>
      <url>/2017/05/24/Vue-router%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="导航钩子"><a href="#导航钩子" class="headerlink" title="导航钩子"></a>导航钩子</h2><ul>
<li>vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消。有多种方式可以在路由导航发生时执行钩子：全局的, 单个路由独享的, 或者组件级的</li>
</ul>
<ol>
<li><p>全局钩子 </p>
<ul>
<li><p>可以使用 router.beforeEach 注册一个全局的 before 钩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123; ... &#125;)</div><div class="line"></div><div class="line">router.beforeEach((to, from, next) =&gt; &#123;</div><div class="line">    // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中</p>
</li>
<li>钩子方法接收三个参数：<ul>
<li>to: Route: 即将要进入的目标 路由对象</li>
<li>from: Route: 当前导航正要离开的路由</li>
<li>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。<ul>
<li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</li>
<li>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</li>
<li>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>某个路由独享的钩子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/foo&apos;,</div><div class="line">      component: Foo,</div><div class="line">      beforeEnter: (to, from, next) =&gt; &#123;</div><div class="line">        // ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol>
<li>组件内钩子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const Foo = &#123;</div><div class="line">  template: `...`,</div><div class="line">  beforeRouteEnter (to, from, next) &#123;</div><div class="line">    // 在渲染该组件的对应路由被 confirm 前调用</div><div class="line">    // 不！能！获取组件实例 `this`</div><div class="line">    // 因为当钩子执行前，组件实例还没被创建</div><div class="line">  &#125;,</div><div class="line">  beforeRouteUpdate (to, from, next) &#123;</div><div class="line">    // 在当前路由改变，但是该组件被复用时调用</div><div class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</div><div class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</div><div class="line">    // 可以访问组件实例 `this`</div><div class="line">  &#125;,</div><div class="line">  beforeRouteLeave (to, from, next) &#123;</div><div class="line">    // 导航离开该组件的对应路由时调用</div><div class="line">    // 可以访问组件实例 `this`</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>beforeRouteEnter 钩子 不能 访问 this，因为钩子在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">beforeRouteEnter (to, from, next) &#123;</div><div class="line">  next(vm =&gt; &#123;</div><div class="line">    // 通过 `vm` 访问组件实例</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="识别路由，为路由设置元信息"><a href="#识别路由，为路由设置元信息" class="headerlink" title="识别路由，为路由设置元信息"></a>识别路由，为路由设置元信息</h2><ul>
<li><p>定义路由的时候配置meta字段来识别路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/foo&apos;,</div><div class="line">      component: Foo,</div><div class="line">      children: [</div><div class="line">        &#123;</div><div class="line">          path: &apos;bar&apos;,</div><div class="line">          component: Bar,</div><div class="line">          // a meta field</div><div class="line">          meta: &#123; requiresAuth: true &#125;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>访问meta字段来判断路由</p>
<ul>
<li>routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</li>
<li>路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航钩子中的 route 对象）的 $route.matched 数组</li>
<li>通过遍历 $route.matched 来检查路由记录中的 meta字段,来识别路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    router.beforeEach((to, from, next) =&gt; &#123;</div><div class="line">  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;</div><div class="line">    // this route requires auth, check if logged in</div><div class="line">    // if not, redirect to login page.</div><div class="line">    if (!auth.loggedIn()) &#123;</div><div class="line">      next(&#123;</div><div class="line">        path: &apos;/login&apos;,</div><div class="line">        query: &#123; redirect: to.fullPath &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">      next()</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    next() // 确保一定要调用 next()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">router.beforeEach((to,from,next) =&gt; &#123;</div><div class="line">    //只有配置了meta字段的路由才会判断</div><div class="line">    if(to.meta.requireAuth) &#123;</div><div class="line">    //判断是不是主代理商</div><div class="line">      if (authStatus==1) &#123;</div><div class="line">        next();</div><div class="line">      &#125;else &#123;</div><div class="line">        globStatus=true;</div><div class="line">        next(&#123;</div><div class="line">          path: &apos;/&apos;,</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;else &#123;</div><div class="line">        next();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><ul>
<li>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。注意: 这个功能只在 HTML5 history 模式下可用</li>
<li>当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法：scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</li>
<li>如果返回一个布尔假的值，或者是一个空对象，那么不会发生滚动。返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">scrollBehavior (to, from, savedPosition) &#123;</div><div class="line">  if (savedPosition) &#123;</div><div class="line">    return savedPosition</div><div class="line">  &#125; else &#123;</div><div class="line">    return &#123; x: 0, y: 0 &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><ol>
<li><p>导航完成之后获取</p>
<ul>
<li>当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;post&quot;&gt;</div><div class="line">    &lt;div class=&quot;loading&quot; v-if=&quot;loading&quot;&gt;</div><div class="line">      Loading...</div><div class="line">    &lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;div v-if=&quot;error&quot; class=&quot;error&quot;&gt;</div><div class="line">      &#123;&#123; error &#125;&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;div v-if=&quot;post&quot; class=&quot;content&quot;&gt;</div><div class="line">      &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;</div><div class="line">      &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">export default &#123;</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      loading: false,</div><div class="line">      post: null,</div><div class="line">      error: null</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  created () &#123;</div><div class="line">    // 组件创建完后获取数据，</div><div class="line">    // 此时 data 已经被 observed 了</div><div class="line">    this.fetchData()</div><div class="line">  &#125;,</div><div class="line">  watch: &#123;</div><div class="line">    // 如果路由有变化，会再次执行该方法</div><div class="line">    &apos;$route&apos;: &apos;fetchData&apos;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    fetchData () &#123;</div><div class="line">      this.error = this.post = null</div><div class="line">      this.loading = true</div><div class="line">      // replace getPost with your data fetching util / API wrapper</div><div class="line">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</div><div class="line">        this.loading = false</div><div class="line">        if (err) &#123;</div><div class="line">          this.error = err.toString()</div><div class="line">        &#125; else &#123;</div><div class="line">          this.post = post</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>导航完成之前获取</p>
</li>
</ol>
<ul>
<li>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 beforeRouteEnter 钩子中获取数据，当数据获取成功后只调用 next 方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">export default &#123;</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      post: null,</div><div class="line">      error: null</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  beforeRouteEnter (to, from, next) &#123;</div><div class="line">    getPost(to.params.id, (err, post) =&gt; </div><div class="line">      if (err) &#123;</div><div class="line">        // display some global error message</div><div class="line">        next(false)</div><div class="line">      &#125; else &#123;</div><div class="line">        next(vm =&gt; &#123;</div><div class="line">          vm.post = post</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  // 路由改变前，组件就已经渲染完了</div><div class="line">  // 逻辑稍稍不同</div><div class="line">  watch: &#123;</div><div class="line">    $route () &#123;</div><div class="line">      this.post = null</div><div class="line">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</div><div class="line">        if (err) &#123;</div><div class="line">          this.error = err.toString()</div><div class="line">        &#125; else &#123;</div><div class="line">          this.post = post</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
            <category> 组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> 路由 </tag>
            
            <tag> vue-router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-router的API学习]]></title>
      <url>/2017/05/24/Vue-router%E7%9A%84API%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="lt-router-link-gt"><a href="#lt-router-link-gt" class="headerlink" title="&lt;router-link&gt;"></a><code>&lt;router-link&gt;</code></h2><ul>
<li><router-link> 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 <a> 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。<h3 id="自定义属性-props"><a href="#自定义属性-props" class="headerlink" title="自定义属性(props)"></a>自定义属性(props)</h3></a></router-link></li>
<li><p><code>to</code></p>
<ul>
<li>表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 字符串 --&gt;</div><div class="line">&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;</div><div class="line">&lt;!-- 渲染结果 --&gt;</div><div class="line">&lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>replace</code>重定向</p>
<ul>
<li>设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;/abc&apos;&#125;&quot; replace&gt;&lt;/router-link&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>append</code></p>
<ul>
<li>设置 append 属性后，则在当前（相对）路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b</li>
</ul>
</li>
<li><p><code>tab</code></p>
<ul>
<li>有时候想要 <router-link> 渲染成某种标签，例如 <li>。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;</div><div class="line">&lt;!-- 渲染结果 --&gt;</div><div class="line">&lt;li&gt;foo&lt;/li&gt;</div></pre></td></tr></table></figure>
</li>
</router-link></li></ul>
</li>
<li><p><code>exact</code></p>
<ul>
<li>“是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 <router-link to="/a"> 也会被设置 CSS 类名。</router-link></li>
<li>按照这个规则，<router-link to="/"> 将会点亮各个路由！想要链接使用 “exact 匹配模式”，则使用 exact 属性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;</div><div class="line">&lt;router-link to=&quot;/&quot; exact&gt;</div></pre></td></tr></table></figure>
</router-link></li>
</ul>
</li>
<li><p><code>events</code></p>
<ul>
<li>声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。</li>
</ul>
</li>
<li><p><code>active-class</code></p>
<ul>
<li>设置 链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。</li>
</ul>
</li>
<li><p>将”激活时的CSS类名”应用在外层元素</p>
<ul>
<li><p>有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 <a> 标签本身，那么可以用 <router-link> 渲染外层元素，包裹着内层的原生 <a> 标签：</a></router-link></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt;</div><div class="line">  &lt;a&gt;/foo&lt;/a&gt;</div><div class="line">&lt;/router-link&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在这种情况下，<a> 将作为真实的链接（它会获得正确的 href 的），而 “激活时的CSS类名” 则设置到外层的 <li>。</li></a></p>
<a id="more"></a>
<h3 id=""><a href="#" class="headerlink" title=""></a><router-view></router-view></h3></li>
<li><router-view> 组件是一个 functional 组件，渲染路径匹配到的视图组件。<router-view> 渲染的组件还可以内嵌自己的 <router-view>，根据嵌套路径，渲染嵌套组件。</router-view></router-view></router-view></li>
</ul>
</li>
</ul>
<ol>
<li>属性<ul>
<li>name<ul>
<li>如果 <router-view>设置了名称，则会渲染对应的路由配置中 components 下的相应组件。查看 命名视图 中的例子。</router-view></li>
</ul>
</li>
</ul>
</li>
<li>行为表现<ul>
<li>其他属性（非 router-view 使用的属性）都直接传给渲染的组件， 很多时候，每个路由的数据都是包含在路由参数中。</li>
<li>因为它也是个组件，所以可以配合 <transition> 和 <keep-alive> 使用。如果两个结合一起用，要确保在内层使用 <keep-alive>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;transition&gt;</div><div class="line">    &lt;keep-alive&gt;</div><div class="line">        &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">    &lt;/keep-alive&gt;</div><div class="line">&lt;/transition&gt;</div></pre></td></tr></table></figure>
</keep-alive></keep-alive></transition></li>
</ul>
</li>
</ol>
<h3 id="路由信息对象"><a href="#路由信息对象" class="headerlink" title="路由信息对象"></a>路由信息对象</h3><pre><code>- 一个 route object（路由信息对象） 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的 route records（路由记录）。
- route object 是 immutable（不可变） 的，每次成功的导航后都会产生一个新的对象。
</code></pre><h4 id="路由信息对象的属性"><a href="#路由信息对象的属性" class="headerlink" title="路由信息对象的属性"></a>路由信息对象的属性</h4><pre><code>- $route.path
    - 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。
- $route.params
    - 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。
- $route.query
    - 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。
- $route.hash
    - 当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。
- $route.fullPath
    - 完成解析后的 URL，包含查询参数和 hash 的完整路径。
- $route.matched
    - 一个数组，包含当前路由的所有嵌套路径片段的 路由记录 。路由记录就是 routes 配置数组中的对象副本（还有在 children 数组）。
    - 当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象（副本）。
- $route.name
    - 当前路由的名称，如果有的话
</code></pre>]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
            <category> 组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> 路由 </tag>
            
            <tag> vue-router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-router的使用一]]></title>
      <url>/2017/05/24/Vue-router%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="vue-router的使用"><a href="#vue-router的使用" class="headerlink" title="vue-router的使用"></a>vue-router的使用</h2><ul>
<li><p>javascript部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 0. 使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)</div><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import VueRouter from &apos;vue-router&apos;</div><div class="line"></div><div class="line">Vue.use(VueRouter)</div><div class="line"></div><div class="line">// 1. 定义（路由）组件。</div><div class="line">// 可以从其他文件 import 进来</div><div class="line">import Foo from &apos;@/page/login.vue&apos;</div><div class="line">import Bar from &apos;@/page/login.vue&apos;</div><div class="line"></div><div class="line">// 2. 定义路由</div><div class="line">// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</div><div class="line">// 通过 Vue.extend() 创建的组件构造器，</div><div class="line">// 或者，只是一个组件配置对象。</div><div class="line">// 我们晚点再讨论嵌套路由。</div><div class="line">const routes = [</div><div class="line">  &#123; path: &apos;/foo&apos;, component: Foo &#125;,</div><div class="line">  &#123; path: &apos;/bar&apos;, component: Bar &#125;</div><div class="line">]</div><div class="line"></div><div class="line">// 3. 创建 router 实例，然后传 `routes` 配置</div><div class="line">// 你还可以传别的配置参数, 不过先这么简单着吧。</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes // （缩写）相当于 routes: routes</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 4. 创建和挂载根实例。</div><div class="line">// 记得要通过 router 配置参数注入路由，</div><div class="line">// 从而让整个应用都有路由功能</div><div class="line">const app = new Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;).$mount(&apos;#app&apos;)</div><div class="line"></div><div class="line">// 现在，应用已经启动了！</div></pre></td></tr></table></figure>
</li>
<li><p>html部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &lt;h1&gt;Hello App!&lt;/h1&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">    &lt;!-- 使用 router-link 组件来导航. --&gt;</div><div class="line">    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;</div><div class="line">    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</div><div class="line">    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</div><div class="line">    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</div><div class="line">  &lt;/p&gt;</div><div class="line">  &lt;!-- 路由出口 --&gt;</div><div class="line">  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</div><div class="line">  &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="vue动态路由的设置"><a href="#vue动态路由的设置" class="headerlink" title="vue动态路由的设置"></a>vue动态路由的设置</h2><ol>
<li><p>使用场景：例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const User = &#123;</div><div class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    // 动态路径参数 以冒号开头</div><div class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line">// /user/foo 和 /user/bar 都将映射到相同的路由</div></pre></td></tr></table></figure>
</li>
<li><p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 我们可以更新 User 的模板，输出当前用户的 ID</div><div class="line">const User = &#123;</div><div class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>响应路由参数的变化</p>
<ul>
<li>当使用路由参数时，例如从 /user/foo 导航到 user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</li>
<li>想对路由参数的变化作出响应的话，你可以简单地 watch（监测变化） $route 对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const User = &#123;</div><div class="line">  template: &apos;...&apos;,</div><div class="line">  watch: &#123;</div><div class="line">    &apos;$route&apos; (to, from) &#123;</div><div class="line">      // 对路由变化作出响应...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>路由匹配优先级</p>
<ul>
<li>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</li>
</ul>
</li>
</ol>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ol>
<li><p>使用children配置来设置嵌套路由 注意事项：以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。children 配置就是像 routes 配置一样的路由配置数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/user/:id&apos;, component: User,</div><div class="line">      children: [</div><div class="line">        &#123;</div><div class="line">          // 当 /user/:id/profile 匹配成功，</div><div class="line">          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</div><div class="line">          path: &apos;profile&apos;,</div><div class="line">          component: UserProfile</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          // 当 /user/:id/posts 匹配成功</div><div class="line">          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</div><div class="line">          path: &apos;posts&apos;,</div><div class="line">          component: UserPosts</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/user/:id&apos;, component: User,</div><div class="line">      children: [</div><div class="line">        // 当 /user/:id 匹配成功，</div><div class="line">        // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</div><div class="line">        &#123; path: &apos;&apos;, component: UserHome &#125;,</div><div class="line"></div><div class="line">        // ...其他子路由</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="用JS控制导航"><a href="#用JS控制导航" class="headerlink" title="用JS控制导航"></a>用JS控制导航</h2><ol>
<li><p><code>router.push(location)</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">声明式: &lt;router-link :to=&quot;...&quot;&gt;	编程式: router.push(...)</div></pre></td></tr></table></figure>
<ul>
<li>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</li>
<li>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</li>
<li>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 router.push(…)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 字符串</div><div class="line">router.push(&apos;home&apos;)</div><div class="line"></div><div class="line">// 对象</div><div class="line">router.push(&#123; path: &apos;home&apos; &#125;)</div><div class="line"></div><div class="line">// 命名的路由</div><div class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</div><div class="line"></div><div class="line">// 带查询参数，变成 /register?plan=private</div><div class="line">router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>router.replace(location)</code></p>
</li>
</ol>
<ul>
<li>它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">声明式: &lt;router-link :to=&quot;...&quot; replace&gt;	编程式: router.replace(...)</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><code>router.go(n)</code></li>
</ol>
<ul>
<li>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 在浏览器记录中前进一步，等同于 history.forward()</div><div class="line">router.go(1)</div><div class="line"></div><div class="line">// 后退一步记录，等同于 history.back()</div><div class="line">router.go(-1)</div><div class="line"></div><div class="line">// 前进 3 步记录</div><div class="line">router.go(3)</div><div class="line"></div><div class="line">// 如果 history 记录不够用，那就默默地失败呗</div><div class="line">router.go(-100)</div><div class="line">router.go(100)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><ul>
<li>通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/user/:userId&apos;,</div><div class="line">      name: &apos;user&apos;,</div><div class="line">      component: User</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><ul>
<li><p>使用场景：同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;</div><div class="line">&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;</div><div class="line">&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/&apos;,</div><div class="line">      components: &#123;</div><div class="line">        default: Foo,</div><div class="line">        a: Bar,</div><div class="line">        b: Baz</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="重定向-和-别名"><a href="#重定向-和-别名" class="headerlink" title="重定向 和 别名"></a>重定向 和 别名</h2><ol>
<li><p>重定向</p>
<ul>
<li><p>重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">    routes: [</div><div class="line">        &#123; path: &apos;/a&apos;, redirect: &apos;/b&apos; &#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>重定向的目标也可以是一个命名的路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">    routes: [</div><div class="line">        &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>甚至是一个方法，动态返回重定向目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">    routes: [</div><div class="line">        &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123;</div><div class="line">        // 方法接收 目标路由 作为参数</div><div class="line">        // return 重定向的 字符串路径/路径对象</div><div class="line">        &#125;&#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>别名</p>
</li>
</ol>
<ul>
<li>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTML5-History-模式"><a href="#HTML5-History-模式" class="headerlink" title="HTML5 History 模式"></a>HTML5 History 模式</h2><ul>
<li>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</li>
<li>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  mode: &apos;history&apos;,</div><div class="line">  routes: [...]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
            <category> 组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> 路由 </tag>
            
            <tag> vue-router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js学习一]]></title>
      <url>/2017/05/24/Vue-js%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="VueJs的单文件组件"><a href="#VueJs的单文件组件" class="headerlink" title="VueJs的单文件组件"></a>VueJs的单文件组件</h1><ul>
<li>vuejs 自定义了一种.vue文件，可以把html, css, js 写到一个文件中，从而实现了对一个组件的封装， 一个.vue 文件就是一个单独的组件。</li>
<li>.vue文件是自定义的，浏览器不认识，所以需要对该文件进行解析，在webpack构建中，需要安装vue-loader 对.vue文件进行解析。</li>
<li>好处：项目更易于维护，代码模块化清晰明了，能够使用构建工具开发更有效率</li>
</ul>
<h1 id="生产环境的部署"><a href="#生产环境的部署" class="headerlink" title="生产环境的部署"></a>生产环境的部署</h1><ul>
<li>使用vue的脚手架<code>vue-cli</code>来配置</li>
</ul>
<h1 id="vue的过滤器"><a href="#vue的过滤器" class="headerlink" title="vue的过滤器"></a>vue的过滤器</h1><ul>
<li><p>过滤器可以用在mustache 插值和 v-bind 表达式即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;message | capitalize&#125;&#125;</div><div class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤器方法注册在<code>filters</code>函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filters: &#123;</div><div class="line">    capitalize: function (value) &#123;</div><div class="line">      if (!value) return &apos;&apos;</div><div class="line">      value = value.toString()</div><div class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="vue的计算属性"><a href="#vue的计算属性" class="headerlink" title="vue的计算属性"></a>vue的计算属性</h1><ul>
<li>计算属性方法写在<code>computed</code>函数中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">            message: &apos;Hello&apos;</div><div class="line">        &#125;,</div><div class="line">computed: &#123;</div><div class="line">            reversedMessage: function () &#123;</div><div class="line">                return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h1 id="vue基本指令"><a href="#vue基本指令" class="headerlink" title="vue基本指令"></a>vue基本指令</h1><ul>
<li>v-for<ul>
<li>vue的迭代渲染数据必须使用特定语法<code>item in items</code></li>
<li>可以为数组索引指定别名(或者用于对象的键)<code>(item, index) in items</code></li>
<li>vueJs推荐提供一个 key 的特殊属性来做提示,以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key 属性<code>v-for=&quot;item in items&quot; :key=&quot;item.id&quot;</code></li>
</ul>
</li>
<li>v-show<ul>
<li>v-show 是简单地切换元素的 CSS 属性 display,用来显示或者隐藏元素</li>
<li>v-show 必须提供布尔值，不支持 <code>&lt;template&gt;</code> 语法，也不支持 <code>v-else</code>。</li>
</ul>
</li>
<li>v-if<ul>
<li>根据表达式的值的真假条件渲染元素</li>
</ul>
</li>
<li>v-else-if<ul>
<li>前一兄弟元素必须有 v-if 或 v-else-if</li>
</ul>
</li>
<li>v-else<ul>
<li>不需要表达式 前一兄弟元素必须有 v-if 或 v-else-if</li>
</ul>
</li>
<li>v-text<ul>
<li>绑定数据，只能渲染成文本格式<code>&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</code></li>
</ul>
</li>
<li>v-html<ul>
<li>绑定输出真正的HTML格式<code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;</code></li>
</ul>
</li>
<li><p>v-bind</p>
<ul>
<li>为元素动态地绑定一个或多个特性，或一个组件 prop 到表达式。</li>
<li><code>v-bind</code>缩写：例<code>&lt;img v-bind:src=&quot;imageSrc&quot;&gt;</code>等同<code>&lt;img :src=&quot;imageSrc&quot;&gt;</code></li>
<li>class和style的动态绑定<ul>
<li><code>&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code>类active是否起作用取决于属性<code>isActive</code> 是否为真值,<code>isActive</code>必须是布尔值</li>
<li>可以在对象中传入更多属性用来动态切换多个 class <code>v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError }</code></li>
<li>数组语法<code>v-bind:class=&quot;[{ active: isActive }, errorClass]</code></li>
<li>绑定内联样式：<code>&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&quot;&gt;&lt;/div&gt;</code></li>
<li>绑定到一个样式对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</div><div class="line">data: &#123;</div><div class="line">    styleObject: &#123;</div><div class="line">    color: &apos;red&apos;,</div><div class="line">    fontSize: &apos;13px&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>v-once </p>
<ul>
<li>只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2.0——从环境搭建到发布]]></title>
      <url>/2017/05/23/Vue2-0%E2%80%94%E2%80%94%E4%BB%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%88%B0%E5%8F%91%E5%B8%83/</url>
      <content type="html"><![CDATA[<h1 id="Vue开发环境的配置"><a href="#Vue开发环境的配置" class="headerlink" title="Vue开发环境的配置"></a>Vue开发环境的配置</h1><ol>
<li>安装Nodejs<code>npm install nodejs</code></li>
<li>安装webpack<code>npm install webpack</code></li>
<li>安装vue脚手架<code>npm install vue-cli -g</code></li>
</ol>
<h1 id="用vue-cli创建模板"><a href="#用vue-cli创建模板" class="headerlink" title="用vue-cli创建模板"></a>用vue-cli创建模板</h1><ul>
<li>vue-cli的模板分为两套<ul>
<li>精简版：vue init webpack-simple 工程名字</li>
<li>常规版：vue init webpack 工程名字</li>
</ul>
</li>
<li>初始化设置根据需求来设定，多人开发时开启Project name (vue-test)(语法检测)<h1 id="安装项目依赖"><a href="#安装项目依赖" class="headerlink" title="安装项目依赖"></a>安装项目依赖</h1></li>
<li>npm install 有可能安装速度会很慢可以使用cnpm 安装淘宝镜像<code>npm install -g cnpm</code><h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1></li>
<li>cd进入项目中<code>npm run dev</code><h1 id="Vue项目组件的使用"><a href="#Vue项目组件的使用" class="headerlink" title="Vue项目组件的使用"></a>Vue项目组件的使用</h1></li>
<li>组件放在工程目录/src下创建component文件夹,组件都在这个目录下创建使用</li>
<li>组件的使用<ol>
<li>引入：<code>import firstcomponent from &#39;./component/firstcomponent.vue</code></li>
<li>注册：data 代码块后面加上<code>components: { firstcomponent }</code></li>
<li>使用：在<code>&lt;template&gt;&lt;/template&gt;</code>内加上<code>&lt;firstcomponent&gt;&lt;/firstcomponent&gt;</code><a id="more"></a>
<h1 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h1></li>
</ol>
</li>
<li>安装vue-router<code>npm install vue-router --save</code></li>
<li>在man.js中导入路由模块<code>import VueRouter from &#39;vue-router&#39;</code></li>
<li>使用：<code>Vue.use(VueRouter)</code></li>
<li>挂载：<code>new Vue({
el: &#39;#app&#39;,
router,
template: &#39;&lt;App/&gt;&#39;,
components: { App }
})</code></li>
<li>配置项目路由<ol>
<li>在router文件夹的index.js文件中配置</li>
<li>导入路由模块<code>import Router from &#39;vue-router&#39;</code></li>
<li>引入页面模块:<code>import login from &#39;@/page/login.vue&#39;</code></li>
<li>路由的配置：export default new Router({<br> routes: [<pre><code>{path: &apos;/login&apos;,name:&apos;登录&apos;,component:login}
</code></pre> ]<br>})</li>
<li>路由的使用：在视图<template></template>标签中<router-link to="/advert"></router-link><h1 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h1></li>
</ol>
</li>
<li>在config文件夹下的index.js中改变文件打包后指定到的文件夹<br>  <code>index: path.resolve(__dirname, &#39;../../webapp/index.html&#39;),
  assetsRoot: path.resolve(__dirname, &#39;../../webapp&#39;),
  assetsSubDirectory: &#39;static&#39;,
  assetsPublicPath: &#39;/&#39;,</code><br>-dev: {<br>  port:8888<br>}改变文件的端口号<br>#文件打包</li>
<li>npm run build</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
