<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[grid布局--网格模板区域]]></title>
    <url>%2F2018%2F07%2F19%2Fgrid%E5%B8%83%E5%B1%80-%E7%BD%91%E6%A0%BC%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[grid布局–网格模板区域命名网格区域 通过grid-area属性为这些区域各分配一个名字,可以随意为区域命名；然后在 grid-template-areas 属性值中指定这个区域的位置。12345678910111213141516171819202122232425262728&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;header&quot;&gt;Header&lt;/div&gt; &lt;div class=&quot;sidebar&quot;&gt;Sidebar&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;Content&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;Footer&lt;/div&gt;&lt;/div&gt;//-----------css-----------.header &#123; grid-area: hd;&#125;.footer &#123; grid-area: ft;&#125;.content &#123; grid-area: main;&#125;.sidebar &#123; grid-area: sd;&#125;.wrapper &#123; display: grid; grid-template-columns: repeat(9, 1fr); grid-auto-rows: minmax(100px, auto); grid-template-areas: &quot;hd hd hd hd hd hd hd hd hd&quot; &quot;sd sd sd main main main main main main&quot; &quot;ft ft ft ft ft ft ft ft ft&quot;;&#125; 留出空白的网格单元 留出空单元的方法是使用句点符，“.”; 为了让布局更整齐，可以使用多个 “.” 符号，如果在多个句点符号之间没有空格，那它们就会被计为一个单元格。用多个句点表示一个单元格的好处是对于复杂的布局来说很容易让行列对齐，这意味着你在 CSS 中看到的，就像是实际布局看起来那样123456789.wrapper &#123; display: grid; grid-template-columns: repeat(9, 1fr); grid-auto-rows: minmax(100px, auto); grid-template-areas: &quot;hd hd hd hd hd hd hd hd hd&quot; &quot;sd sd sd main main main main main main&quot; &quot;. . . ft ft ft ft ft ft&quot;;&#125; 跨越多个网格单元 在上面的例子中，每个区域都跨越了多个网格单元，为了实现这个效果，要把区域名字在它的区域内重复写多次，中间用空格分隔。你也可以在 grid-template-areas 中添加额外的空格以便让列对齐; 用区域名连接起来的区域必须是矩形的，目前还不能创建 L 形的区域; grid-template-areas的值必须是一个完整的网格，否则无效（即这个属性会被忽略掉），这意味着你应该让每一行都有相同数量的单元格，如果出现句点符就表示这个单元格将被留空。如果创建的区域不是矩形，也是无效的网格; 用媒体查询重新定义网格 若要（通过媒体查询）重新定义网格，应该把区域名称定义在媒体查询之外，在这种情况下，主要内容区域就总是会被称为 main，不管它被（媒体查询语句）定位在网格中的什么位置。123456789101112131415161718192021222324252627282930313233343536373839.header &#123; grid-area: hd;&#125;.footer &#123; grid-area: ft;&#125;.content &#123; grid-area: main;&#125;.sidebar &#123; grid-area: sd;&#125;.wrapper &#123; display: grid; grid-auto-rows: minmax(100px, auto); grid-template-columns: 1fr; grid-template-areas: &quot;hd&quot; &quot;main&quot; &quot;sd&quot; &quot;ft&quot;;&#125;@media (min-width: 500px) &#123; .wrapper &#123; grid-template-columns: repeat(9, 1fr); grid-template-areas: &quot;hd hd hd hd hd hd hd hd hd&quot; &quot;sd sd sd main main main main main main&quot; &quot;sd sd sd ft ft ft ft ft ft&quot;; &#125;&#125;@media (min-width: 700px) &#123; .wrapper &#123; grid-template-areas: &quot;hd hd hd hd hd hd hd hd hd&quot; &quot;sd sd main main main main main ft ft&quot;; &#125;&#125; 网格定义的简写规则 简写方式不仅能够一口气把多个属性缩写成一行，它们还会把一些你没有设置过的值、或不能在简写中设置的值重置成初始值。所以如果要用简写方式，一定要意识到它可能会把你在别处已经设置过的值给重置了。grid-template grid-template属性可同时设置以下属性: grid-template-rows grid-template-columns grid-template-areas 这个属性之所以被称为显式网格简写，是因为它设置的都是在定义显式网格时要用到的属性，而不是那些与创建隐式的行或列轨道相关的属性12345678.wrapper &#123; display: grid; grid-template: &quot;hd hd hd hd hd hd hd hd hd&quot; minmax(100px, auto) &quot;sd sd sd main main main main main main&quot; minmax(100px, auto) &quot;ft ft ft ft ft ft ft ft ft&quot; minmax(100px, auto) / 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr ; &#125; grid grid 简写方式更进一步，它包含了与隐式网格相关的属性，所以通过它可以同时设置以下属性： grid-template-rows grid-template-columns grid-template-areas grid-auto-rows grid-auto-columns grid-auto-flow 这个属性会把 grid-gap 属性的值重置为 0，而且你还不能在简写中设置间距值1234567.wrapper &#123; display: grid; grid: &quot;hd hd hd hd hd hd hd hd hd&quot; minmax(100px, auto) &quot;sd sd sd main main main main main main&quot; minmax(100px, auto) &quot;ft ft ft ft ft ft ft ft ft&quot; minmax(100px, auto) / 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr ; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>grid布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid布局--基于线的定位]]></title>
    <url>%2F2018%2F07%2F19%2Fgrid%E5%B8%83%E5%B1%80-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[grid布局–基于线的定位按线编号为元素定位 我们可以使用基于线的定位控制这些元素在网格上的位置。比如我想要第一个元素从网格的最左开始，占1个列导轨;它还应该从第1行线开始，延伸至第4行线： 1234567891011121314151617181920212223242526&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;box1&quot;&gt;One&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;Two&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;Three&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;Four&lt;/div&gt;&lt;/div&gt;//---------------css---------------.box2 &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3;&#125;.box3 &#123; grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125;.box4 &#123; grid-column-start: 2; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4;&#125; 当你为某些元素定位，剩下的元素会继续按照自动定位规则定位 网格布局的一个优势是：无需给元素周围加上margin来阻止文档流自动填补空白，就能实现设计中的留白区域 grid-column 和 grid-row 缩写 grid-column-start和grid-column-end属性可以合并为grid-column; grid-row-start和grid-row-end则合并为grid-row;1234.box1 &#123; grid-column: 1 / 2; grid-row: 1 / 4;&#125; 默认跨度 如果一个元素只延伸一个轨道的话，可以省略 grid-column-end 或 grid-row-end 值 当省略了跨越一个轨道的元素的／和第二个值，我们的缩写则会是这样12345678910111213141516171819.box1 &#123; grid-column-start: 1; grid-row-start: 1; grid-row-end: 4;&#125;.box2 &#123; grid-column-start: 3; grid-row-start: 1; grid-row-end: 3&#125;//缩写省略跨域一个轨道的元素.box1 &#123; grid-column: 1; grid-row: 1/4&#125;.box2 &#123; grid-column: 3; grid-row: 1/3&#125; grid-area属性 给每个元素只定义一个属性grid-area，值的顺序如下 grid-row-start grid-column-start grid-row-end grid-column-end 用grid-area属性来定义网格区域时我们先定义 块起始（block-start） 和 行起始（inline-start）, 然后再定义 块结束（block-end） 和 行结束（inline-end） 反向计数 我们也可以从行和块结束线开始反方向计数，对于英语来说就是右端的列线和底端的行线。这些线会被记为 -1，然后你可以从这往前数，所以倒数第2条线会被记为 -2。值得注意的是最后一条线是指显式定义网格的最后一条线，即由 grid-template-columns 和 grid-template-rows 定义的网格，并不把隐式定义网格的加入的行和列纳入考虑 使元素跨越整个网格 拥有从开始计数和从末尾计数这两种定位方法使得使一个元素跨越整个网格变得很方便:123.item &#123; grid-column: 1 / -1;&#125; 使用 span 关键字 除了”起始线与结束线”的定位方法，你还可以使用”起始线与跨越轨道数量”的定位方法 12345678910111213141516.box1 &#123; grid-column: 1; grid-row: 1 / span 3;&#125;.box2 &#123; grid-column: 3; grid-row: 1/ span 2;&#125;.box3 &#123; grid-column: 2; grid-row: 1;&#125;.box4 &#123; grid-column: 2 / span 2; grid-row: 3;&#125; 例1：我们设定了起始行，然后说我们想结束线在跨越3个线之后。那这个元素就会从1号线开始，跨越3个线，到4号线结束。 1234.box1 &#123; grid-column: 1; grid-row: 1 / span 3;&#125; 例2：我们定义了结束行线，然后设置起始线为跨越3个线。意味着这个元素会从指定的线往上跨越3个线。这个元素会从4号线开始，跨越3个线到1号线。 1234.box1 &#123; grid-column: 1; grid-row: span 3 / 4;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>grid布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid布局基本概念]]></title>
    <url>%2F2018%2F07%2F19%2Fgrid%E5%B8%83%E5%B1%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[grid布局网格容器 通过在元素上声明display:grid或display: inline-grid来创建一个网格容器，设定后该元素的所有直系子元素将成为网格元素1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;One&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt; &lt;div&gt;Three&lt;/div&gt; &lt;div&gt;Four&lt;/div&gt; &lt;div&gt;Five&lt;/div&gt; &lt;div&gt;Six&lt;/div&gt;&lt;/div&gt;.wrapper &#123; display: grid;&#125; 网格轨道 我们通过grid-template-columns和grid-template-rows属性来定义网格中的列和行；一个网格轨道就是网格中任意两条线之间的空间。 grid-template-columns: 定义网格中的列 grid-template-rows: 定义网格中行 fr单位 网格引入了新的长度单位fr; fr单位代表网格容器中可用空间的一部分，轨道会随着可用空间增长和收缩。123456789101112&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;One&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt; &lt;div&gt;Three&lt;/div&gt; &lt;div&gt;Four&lt;/div&gt; &lt;div&gt;Five&lt;/div&gt; &lt;div&gt;Six&lt;/div&gt;&lt;/div&gt;.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr 1fr;&#125; 使用repeat() 有着多轨道的大型网格可使用repeat() 标记来重复部分或整个轨道列表 123456789.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr 1fr;&#125;//也可写成.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr);&#125; repeat语句可以用于重复轨道列表中的一部分 12345//起始轨道为100像素，接着重复了4个1fr的轨道，最后再添加了一个100像素的轨道.wraper &#123; display: grid; grid-template-columns: 100px repeat(4, 1fr) 100px;&#125; repeat语句可以传入一个轨道列表，因此你可以用它来创建一个多轨道模式的重复轨道列表。 12345//网格将有共计10个轨道，为1个1fr轨道后面跟着1个2fr轨道，该模式重复5次。.wrapper &#123; display: grid; grid-template-columns: repeat(5,1fr,2fr);&#125; 隐式和显式网格 使用grid-template-columns和grid-template-rows属于定义的是显示网格的行和列； 如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列。按照默认，这些轨道将自动定义尺寸，所以会根据它里面的内容改变尺寸。 在隐式网格中用 grid-auto-rows 和 grid-auto-columns 属性来定义一个设置大小尺寸的轨道。 123456//用 grid-auto-rows 属性来确保在隐式网格中创建的轨道是200像素高.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 200px;&#125; 定义的显示网格尺寸优先级大于定义的隐式网格尺寸 1234567//轨道高250px.wrapper &#123; display: grid; grid-template-columns: repeat(3,1fr); grid-template-rows: repeat(4, 250px); //优先级更高 grid-auto-rows: 200px;&#125; 轨道大小和minmax() 用minmax()函数可以给网格一个最小的尺寸，确保他们能扩大到容纳他里面添加的内容，同时也不限定死最大高度，网格可以随着内容延伸。123456//自动创建的行高将会是最小100像素，最大为auto。用auto意味着行的尺寸将会根据内容的大小来自动变换：根据本行中最高的单元，把空间扩展到足够容纳该单元。.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: minmax(100px,auto);&#125; 网格线 当我们定义网格时，我们定义的是网格轨道，而不是网格线；grid会为我们创建编号的网格线来让我们定位每一个网格元素，例如下面这个三列两行网格中就拥有四条纵向的网格线 网格线的编号顺序取决于文章的书写模式，在从左至右书写的语言中，编号为 1 的网格线位于最左边。 跨轨道放置网格元素 grid-column-start: 网格列线开始编号 grid-column-end: 网格列线结束编号 grid-row-start: 网格行线开始编号 grid-row-end: 网格行线结束编号 网格单元 一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像 网格区域 网格元素可以向行或者列的方向扩展一个或多个单元，并且会创建一个网格区域；网格区域的形状应该是一个矩形，也就是说你不可能创建出一个类似于“L”形的网格区域 网格间距 在两个网格单元之间的 网格横向间距 或 网格纵向间距 可使用grid-column-gap和grid-row-gap属性来创建; 间距只出现在网格轨道与轨道之间，它们并不会出现在网格容器的四周; 间距使用的空间会在 使用弹性长度fr的轨道的空间计算前就被留出来，间距的尺寸定义行为和普通轨道一致，但不同的是你不能向其中插入任何内容。从以基线定位的角度来说，间距就像一条很宽的基线。 网格间距缩写 这两个属性可以用grid-gap简写。如果你只给出一个值，那这个值会同时应用于行间距和列间距。如果你给了两个值，第一个会被用于grid-row-gap，第二个则会被用于grid-column-gap grid-gap: 10px 20px:先是行间距后是列间距 123456.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 100px); grid-gap: 1em 20px;&#125; 嵌套网格 一个网格元素可以也成为一个网格容器，嵌套网格和他的父级并没有关系 当元素不是网格容器的直接子级元素时，它们不会参与到网格布局中，并显示为正常的文档流 使用z-index控制层级 多个网格项目可以占用同一个网格单位，使用z-index属性控制重叠的顺序,z-index越大层级越高 网格布局结合弹性布局 当抉择该用网格还是弹性盒时，你可以问自己一个简单的问题 我只需要按行或者列控制布局？那就用弹性盒子 我需要同时按行和列控制布局？那就用网格]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>grid布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS固定底部的方法]]></title>
    <url>%2F2018%2F07%2F19%2FCSS%E5%9B%BA%E5%AE%9A%E5%BA%95%E9%83%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[CSS粘住固定底部的方法 1. 使用flexbox布局实现 HTML: 12345678910&lt;body&gt; &lt;div class=&quot;wraper&quot;&gt; &lt;div class=&quot;content&quot;&gt; content &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; footer &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; CSS: 12345678910111213141516171819html,body &#123; height: 100%;&#125;.wraper &#123; min-height: 100%; display: flex; flex-direction: column;&#125;.wraper .content &#123; flex: 1;&#125;.wraper .footer &#123; width: 300px; height: 50px; line-height: 50px; text-align: center; margin: 0 auto; border:1px solid #000;&#125; 全局增加一个负值下边距等于底部高度 html: 12345678910&lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt; content &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; footer &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; CSS: 12345678910111213141516171819html,body &#123; height: 100%;&#125;.wrapper &#123; height: 100%;&#125;.wrapper .content &#123; min-height: 100%; margin-bottom: -50px;&#125;.wrapper .footer &#123; width: 300px; height: 50px; line-height: 50px; text-align: center; background: #000; color:#fff; margin: 0 auto;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的长度单位]]></title>
    <url>%2F2018%2F07%2F19%2FCSS%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[CSS的长度单位绝对长度单位px123.wrap &#123; width: 400px;&#125; 相对字体长度em123.wrap &#123; width: 40em&#125; 在没有任何CSS规则的前提下，1em的长度是： 11em == 16px == 0.17in == 12pt == 1pc == 4.2mm == 0.42cm 著作权归作者所有。 如果有任何CSS规则改变了字体大小（不管在文档的什么位置），1em的长度会变成相对于新的font-size的大小。 em单位有点古怪，当设置了font-size属性后，它会逐级向上相乘，所以如果一个设置了font-size:1.1em的元素在另一个设置了font-size:1.1em的元素里，而这个元素又在另一个设置了font-size:1.1em的元素里，那么最后计算的结果是1.1X1.1X1.1=1.331rem（根em）。这意味着即使一个元素设置为10em，这个元素也不会在他出现的每个地方都是10em。如果font-size变化了，它可能会宽点，也可能会窄点。 rem123.wrap &#123; width: 40rem;&#125; rem总是相对于根元素(html)的字体大小；如果设置htmlfont-size : 14px，则1rem = 14px 可视区百分比长度单位vw123.wrap &#123; width: 10vw;&#125; vw是可视区宽度单位。1vw等于可视区宽度的百分之一。vw单位跟百分比很相似，不同的是vw的值对所有的元素都一样，与他们父元素或父元素的宽度无关。有点像rem单位那样总是相对于根元素。 vh123.wrap &#123; width: 10vh&#125; vh和vw（viewport widht）单位一样，不同的是vh是相对于可视区的高度。 vmin vmin的值是当前vw和vh中较小的值。在标准尺寸类型的使用实例中，和由自己确定屏幕大小的vw、vh单位相比，vmin是一个更有用的度量标准 vmax Vmax的值是vw和vh中的较大的值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS长度单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目使用vw适配移动端]]></title>
    <url>%2F2018%2F07%2F19%2FReact%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8vw%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[React项目使用vw适配移动端打开自定义配置选项123yarn eject//Are you sure you want to eject? This action is permanent. (y/N) y 修改配置配置使用scss1234# 第一处是： （大约167行左右）test: /\.css$/ 变成 test: /\.s?css$/ # 第二处是： （大约217行左右）&#123;loader: require.resolve(&apos;sass-loader&apos;)&#125; 安装postCss插件1yarn add postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano -D 配置开发环境 在config/webpack.config.dev.js文件中进行如下修改 引入postCss插件 123456const postcssAspectRatioMini = require(&apos;postcss-aspect-ratio-mini&apos;);const postcssPxToViewport = require(&apos;postcss-px-to-viewport&apos;);const postcssWriteSvg = require(&apos;postcss-write-svg&apos;);const postcssCssnext = require(&apos;postcss-cssnext&apos;);const postcssViewportUnits = require(&apos;postcss-viewport-units&apos;);const cssnano = require(&apos;cssnano&apos;); 加入postCss配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; test: /\.s?css$/, use: [ require.resolve(&apos;style-loader&apos;), &#123; loader: require.resolve(&apos;css-loader&apos;), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve(&apos;postcss-loader&apos;), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: &apos;postcss&apos;, plugins: () =&gt; [ require(&apos;postcss-flexbugs-fixes&apos;), autoprefixer(&#123; browsers: [ &apos;&gt;1%&apos;, &apos;last 4 versions&apos;, &apos;Firefox ESR&apos;, &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway ], flexbox: &apos;no-2009&apos;, &#125;), postcssAspectRatioMini(&#123;&#125;), // 用来处理元素容器宽高比 postcssWriteSvg(&#123; // 用来处理移动端1px的解决方案 utf8: false &#125;), postcssCssnext(&#123;&#125;), // 让项目使用CSS未来特性 并对其做兼容性处理 postcssPxToViewport(&#123; viewportWidth: 375, // 视窗的宽度，对应我们设计稿的宽度，一般是750 viewportHeight: 667, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定&apos;px&apos;转换为视窗单位值得小数位数（很多时候无法整除） viewportUnit: &apos;vw&apos;, // 指定需要转换成的视窗单位,建议使用vw selectorBlackList: [&apos;.ignore&apos;, &apos;.hairlines&apos;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值。 mediaQuery: false // 允许在媒体查询中转换`px` &#125;), postcssViewportUnits(&#123;&#125;), // 给CSS的属性添加content的属性 配合viewport-units-buggyfill解决个别手机不支持vw cssnano(&#123; // 压缩和清理CSS代码 preset: &quot;advanced&quot;, autoprefixer: false, &quot;postcss-zindex&quot;: false &#125;) ], &#125;, &#125;, &#123; loader: require.resolve(&apos;sass-loader&apos;) &#125; ], &#125;, 配置生产环境 操作与配置测试环境文件相同，先引入插件在相同的位置配置postCss插件； VW兼容方案 主要使用viewport-units-buggyfill.js和viewport-units-buggyfill.hacks.js，只需要在public/index.html引入它们 在&lt;head&gt;&lt;/head&gt;中引入阿里cdn:&lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt; 在HTML文件中调用viewport-units-buggyfill 12345678&lt;!--使用viewport-units-buggyfill解决个别手机不支持vw--&gt;&lt;script&gt; window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); &#125;&lt;/script&gt; 前面配置的postcss-viewport-units插件。这个插件将让你无需关注content的内容，插件会自动帮你处理。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目使用vw适配移动端]]></title>
    <url>%2F2018%2F07%2F19%2FVue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8vw%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Vue项目使用vw适配移动端1.vw原理解析 vw是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小。 Viewport相关的单位有四个，分别为vw、vh、vmin和vmax: vw：是Viewport’s width的简写,1vw等于window.innerWidth的1% vh：和vw类似，是Viewport’s height的简写，1vh等于window.innerHeihgt的1% vmin：vmin的值是当前vw和vh中较小的值 vmax：vmax的值是当前vw和vh中较大的值 vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。 如果设计稿的宽度是750px，那么100vw=750px,1vw=7.5px 2.Vue项目中使用vw实现移动端适配 安装PostCSS插件 在.postcssrc.js使用postcss 已经装好有postcss-import、postcss-url、autoprefixer 新增插件：npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano -D 在.postcssrc.js文件对新安装的PostCSS插件进行配置： 12345678910111213141516171819202122232425262728module.exports = &#123; &quot;plugins&quot;: &#123; &quot;postcss-import&quot;: &#123;&#125;, &quot;postcss-url&quot;: &#123;&#125;, // 使用postcss的插件实现vw适配移动端 // 由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false &apos;postcss-aspect-ratio-mini&apos;: &#123;&#125;, // 用来处理元素容器宽高比 &apos;postcss-write-svg&apos;: &#123; // 用来处理移动端1px的解决方案 uft8:false &#125;, &apos;postcss-cssnext&apos;: &#123;&#125;, // 让项目使用CSS未来特性 并对其做兼容性处理 &apos;postcss-px-to-viewport&apos;: &#123; viewportWidth: 750, // 视窗的宽度，对应我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定&apos;px&apos;转换为视窗单位值得小数位数（很多时候无法整除） viewportUnit:&apos;vw&apos;, // 指定需要转换成的视窗单位,建议使用vw selectorBlackList: [&apos;.ignore&apos;,&apos;.hairliness&apos;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值。 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, &apos;postcss-viewport-units&apos;: &#123;&#125;, // 给CSS的属性添加content的属性 配合viewport-units-buggyfill解决个别手机不支持vw &apos;cssnano&apos;: &#123; // 压缩和清理CSS代码 preset: &apos;advanced&apos;, autoprefixer: false, &apos;postcss-zindex&apos;: false &#125; &#125;&#125; vw兼容方案: 兼容个别手机 主要使用viewport-units-buggyfill.js和viewport-units-buggyfill.hacks.js，只需要在你的HTML文件中引入这两个文件。比如在Vue项目中的index.html引入它们 &lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt; 在HTML文件中调用viewport-units-buggyfill 12345678&lt;!--使用viewport-units-buggyfill解决个别手机不支持vw--&gt;&lt;script&gt; window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); &#125;&lt;/script&gt; 前面配置的postcss-viewport-units插件。这个插件将让你无需关注content的内容，插件会自动帮你处理。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期]]></title>
    <url>%2F2018%2F07%2F19%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React生命周期组件的生命周期可分成三个状态 挂载：组件被实例化并挂载在到dom树这一过程称为挂载 更新：当组件的属性或者状态改变时会重新渲染 卸载：当一个组件被移出Dom树时，组件就会被卸载 挂载 首次渲染执行的顺序如图上 getDefaultProps相当于ES6中staticdefaultProps = {} getInitialState相当于constructor中的 this.state = {} componentWillMount() 在render()之前调用被调用，因此在这方法里设置this.setState是不会触发不会触发重渲 这是唯一会在服务端渲染调起的生命周期钩子函数，在服务端渲染的场景中可以在这发送AJAX请求 componentDidMount() 该方法在组件挂载完成后立即调用，并且只会调用一次 通常在这个方法中发送AJAX请求 更新Props改变 State改变 componentWillReceiveProps 方法在已挂载的组件接收到新属性前调用 要合理使用componentWillReceiveProps需做好条件判断12345componentWillReceiveProps(nextProps) &#123; if(nextProps.myProp !== this.props.myProps) &#123; // nextProps.myProp has a different value than our current prop &#125;&#125; shouldComponentUpdate componentWillUpdate componentDidUpdate 卸载 componentWillUnmount 当组件被卸载之前立刻调用；可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素。 错误处理 componentDidCatch() 在渲染过程中发生错误时会被调用;只可以处理子组件中产生的、未处理的错误，能够捕获的错误类型有子组件render函数中产生的错误及生命周期函数中产生的非异步错误12345678910111213//父组件或祖宗组件中实现componentDidCatch(errorString, errorInfo) &#123; this.setState(&#123; error: errorString &#125;); ErrorLoggingTool.log(errorInfo);&#125;render() &#123; if(this.state.error) return &lt;ShowErrorMessage error=&#123;this.state.error&#125; /&gt; return ( // render normal component output );&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-router-dom学习]]></title>
    <url>%2F2018%2F07%2F19%2FReact-router-dom%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React-router-domAPI 使用 HTML5 提供的 history API (pushState, replaceState 和 popstate 事件) 来保持 UI 和 URL 的同步。 basename: string 当前位置的基准URL。如果你的页面部署在服务器的二级（子）目录，你需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。 HashRouter 使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步。 当存在服务区来管理动态请求时，需要使用&lt;BrowserRouter&gt;组件，而&lt;HashRouter&gt;被用于静态网站 所有路由器组件的通用接口，使用时&lt;Router&gt;标签只能包含一个子标签，一般Router放在元素标签最顶部，只需使用包括 123456&lt;Route path=&apos;/roster&apos;/&gt;// 当路径名为&apos;/&apos;时, path不匹配// 当路径名为&apos;/roster&apos;或&apos;/roster/2&apos;时, path匹配// 当你只想匹配&apos;/roster&apos;时，你需要使用&quot;exact&quot;参数// 则路由仅匹配&apos;/roster&apos;而不会匹配&apos;/roster/2&apos;&lt;Route exact path=&apos;/roster&apos;/&gt; 渲染当匹配到对应的路径时，呈现相应的页面 Route渲染页面的三种方法 component ：一个React组件。当带有component参数的route匹配成功后，route会返回一个新的元素，其为component参数所对应的React组件（使用React.createElement创建） 1&lt;Route path=&apos;/page&apos; component=&#123;Page&#125; /&gt; render ： 一个返回React element的函数。当匹配成功后调用该函数。该过程与传入component参数类似，并且对于行级渲染与需要向元素传入额外参数的操作会更有用。 123&lt;Route path=&apos;/page&apos; render=&#123;(props) =&gt; ( &lt;Page &#123;...props&#125; data=&#123;extraProps&#125;/&gt;)&#125;/&gt; children ： 一个返回React element的函数。与上述两个参数不同，无论route是否匹配当前location，其都会被渲染 12345&lt;Route path=&apos;/page&apos; children=&#123;(props) =&gt; ( props.match ? &lt;Page &#123;...props&#125;/&gt; : &lt;EmptyPage &#123;...props&#125;/&gt;)&#125;/&gt; 嵌套路由 /roster ：对应路径名仅仅是/roster时，因此需要在exact元素上添加exact参数。 /roster/:number ： 该路由使用一个路由参数来获取/roster后的路径名。 1234&lt;Switch&gt; &lt;Route exact path=&apos;/roster&apos; component=&#123;FullRoster&#125;/&gt; &lt;Route path=&apos;/roster/:number&apos; component=&#123;Player&#125;/&gt;&lt;/Switch&gt; 路径参数 如’/roster/:number’中:number这种写法意味着/roster/后的路径名将会被获取并存在match.params.number中。例如，路径名’/roster/6’会获取到一个对象：12345678const Player = (props) =&gt; &#123; const number = props.match.params.number; return ( &lt;div&gt; &lt;h1&gt;参数：&#123;number&#125;&lt;/h1&gt; &lt;/div&gt;) 提供路由跳转和导航，显示在html中就是a标签 to: string 需要跳转到的路径(pathname)或地址（location） to: object 需要跳转到的地址（location） replace: bool 默认为false 当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址 当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。 特殊版本的&lt;Link&gt;,当需要设置导航点击，匹配当前路由样式时，使用该组件 activeClassName：string 设置匹配当前路由时的a标签类名，默认类名是class=&#39;active&#39; activeStyle: object 设置匹配当前路由时的a标签样式 exact: bool 默认是false,设置为true则只有完全匹配时才能应用activeClassName和activeStyle HistoryLocationJS控制路由跳转及传参123456789this.props.history.push(&#123; pathname: &apos;/order-detail&apos;,//路由 state: &#123; orderNo: params //传参 &#125;, &#125;);//接受参数let orderNo = this.props.location.state.orderNo]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router-dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由组件按需加载的几种方法]]></title>
    <url>%2F2018%2F07%2F19%2FVue%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue路由组件按需加载的几种方法 1. 普通加载 使用vue-cli构建项目后，我们会在Router文件夹下面的index.js里面引入相关的路由组件,如： 123import Hello from &apos;@/components/Hello&apos;import Boy from &apos;@/components/Boy&apos;import Girl from &apos;@/components/Girl&apos; 这样做的结果就是webpack在npm run build的时候会打包成一个整个的js文件，如果页面一多，会导致这个文件非常大，加载缓慢，为了解决这个问题，需要将他分成多个小文件，而且还要实现异步按需加载，即用到了再加载，而不用一股脑全部加载 2. webpack的require.ensure()实现按需加载 语法：require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String) dependencies：字符串构成的数组，声明 callback 回调函数中所需的所有模块,模块作为依赖被加载 callback：只要加载好全部依赖，webpack 就会执行此函数。require 函数的实现，作为参数传入此函数。当程序运行需要依赖时，可以使用 require() 来加载依赖。函数体可以使用此参数，来进一步执行 require() 模块。 errorCallback：当 webpack 加载依赖失败时，会执行此函数。 chunkName：由 require.ensure() 创建出的 chunk 的名字。通过将同一个 chunkName 传递给不同的 require.ensure() 调用，我们可以将它们的代码合并到一个单独的 chunk 中，从而只产生一个浏览器必须加载的 bundle。 使用方法一： 1234require.ensure([], function(require)&#123; require(&apos;./a.js&apos;);&#125;);// 此时会单独打包出一个js文件，没有自定义名称的话，会被命名为1.js(有hash时候会带上md5) 使用方法二： 1234567891011121314require.ensure([&apos;./a.js&apos;], function(require) &#123; require(&apos;./b.js&apos;);&#125;);1、此时a.js作为依赖被加载，但是没有被执行（官方文档说的only loads the modules）2、a.js和b.js会被打包成一个文件。3、回调函数里只require了b.js，只有b.js的内容会被执行。4、如果你需要使用a.js的内容，需要再加上require(&apos;./a.js&apos;)require.ensure([&apos;./list&apos;], function(require)&#123; var list = require(&apos;./list&apos;); list.show();&#125;);给require.ensure的第一个参数传了[&apos;./list&apos;]，执行到这里的时候list.js会被浏览器下载下来，但是并不会执行list.js模块中的代码，也就是webpack官网说的，不会进行evaluate。真正进行evaluate的时候是到了后面这句var list = require(&apos;./list&apos;);这就是所谓的懒执行。写在函数中的多个模块会被打包在一起，这一点和上面没有区别。另外，写在数组中的模块也会跟他们打包在一起，不管你有没有手动执行。 vue中使用 123456comst List = resolve =&gt; &#123; require.ensure([],() =&gt; &#123; resolve(require(&apos;./list&apos;)) &#125;,&apos;list&apos;)&#125;其实resolve的作用就是Promise里面那个resolve，在这里就是定义一个异步的组件 使用动态 import语法123456789const Foo = () =&gt; import(/* webpackChunkName: &quot;foo&quot; */ &apos;./Foo.vue&apos;);const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo &#125; ]&#125;)// /* webpackChunkName: &quot;foo&quot; */使用命名chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)// webpack要加配置 output需要加个chunkFilenamechunkFilename: &apos;[name].js&apos;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli 根据不同的环境打包]]></title>
    <url>%2F2018%2F07%2F19%2FVue-cli-%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[vue-cli 根据不同的环境打包 vue-cli 中build中build.js部分代码做如下修改1234567891011121314151617require(&apos;./check-versions&apos;)()// process.env.NODE_ENV = &apos;production&apos;var ora = require(&apos;ora&apos;)var rm = require(&apos;rimraf&apos;)var path = require(&apos;path&apos;)var chalk = require(&apos;chalk&apos;)var webpack = require(&apos;webpack&apos;)var config = require(&apos;../config&apos;)var webpackConfig = require(&apos;./webpack.prod.conf&apos;)var spinner = ora(&apos;building for &apos; + process.env.NODE_ENV + &apos; of &apos; + process.env.env_config+ &apos; mode...&apos; )spinner.start()// var spinner = ora(&apos;building for production...&apos;)// spinner.start()。。。。 build中webpack.prod.conf.js做如下修改12// const env = require(&apos;../config/prod.env&apos;);const env = config.build[process.env.env_config+&apos;Env&apos;] config中的index.js 部分代码修改如下1234567module.exports = &#123; build: &#123; prodEnv: require(&apos;./prod.env&apos;), testEnv: require(&apos;./test.env&apos;), ppeEnv: require(&apos;./ppe.env&apos;), index: path.resolve(__dirname, &apos;../dist/&apos; + new Date().getTime() + &apos;/index.html&apos;), 。。。。。 config中的index.js 配置代理跨域12345678910// 配置代理跨域 proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://xxxxxxxxxxxx/&apos;, // 开发接口域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125; &#125; &#125;, 在config中新建test.env.js123456//测试环境module.exports = &#123; NODE_ENV: &apos;&quot;testEnvironment&quot;&apos;, ENV_CONFIG: &apos;&quot;test&quot;&apos;,。。。&#125; 在config中新建ppe.env.js1234567//预生产module.exports = &#123; NODE_ENV: &apos;&quot;ppeEnvironment&quot;&apos;, ENV_CONFIG: &apos;&quot;ppe&quot;&apos;,hosturl: &apos;&quot;https://ppexxx&quot;&apos;。。。&#125; 安装cross-env npm i cross-env -S接口调用 src文件夹中新建api文件；文件夹中新建api.js和baseURL.js12345678910111213141516171819202122232425262728293031//--------------baseURL.js----------------let baseURL = &apos;/api&apos;;// 判断开发环境 设置不同的请求域名if(process.env.NODE_ENV === &apos;development&apos;) &#123; baseURL = &apos;/api&apos;; // 开发环境使用代理域名&#125; else if (process.env.NODE_ENV === &apos;testEnvironment&apos;) &#123; baseURL = &apos;http://xxxxxxxxxxxx&apos;; // 测试环境&#125; else if (process.env.NODE_ENV === &apos;ppeEnvironment&apos;) &#123; baseURL = &apos;http://ppe&apos;; // 演练环境&#125; else &#123; baseURL = &apos;&apos;; // 生产环境&#125;export default baseURL//--------------api.js----------------import axios from &apos;axios&apos;;import baseURL from &apos;./baseURL.js&apos;// 创建axios实例const Request = axios.create(&#123; baseURL: baseURL,&#125;)// 初始化默认post headeraxios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;// 接口调用export const queryAllRecord = params =&gt; &#123; return Request.post(`app/xxx/xxxxxx`,params).then(res =&gt; res.data);&#125;; package.json 修改1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build:test&quot;: &quot;cross-env NODE_ENV=testEnvironment env_config=test node build/build.js&quot;, &quot;build:ppe&quot;: &quot;cross-env NODE_ENV=ppeEnvironment env_config=ppe node build/build.js&quot;, &quot;build:prod&quot;: &quot;cross-env NODE_ENV=production env_config=prod node build/build.js&quot; &#125;, 输入指令 npm run dev 开发环境 npm run build:test 打包测试环境 npm run build:ppe 打包演练环境 npm run build 打包生产环境]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用]]></title>
    <url>%2F2018%2F06%2F16%2FGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git基本操作 1. git简介 工作区：本地电脑存放项目文件的地方； 暂存区：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里； 本地仓库：使用commit命令可以将暂存区中的文件添加到本地仓库中； 远程仓库：项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可 2. git配置 配置用户名：git config --global user.name &quot;your name&quot;; 配置用户邮箱：git config --global user.email &quot;youremail@github.com&quot;; 3. 工作区操作新建仓库 创建新的本地仓库：git init 从远处仓库复制项目：git clone 提交 提交工作区所有文件到暂存区: git add . 提交工作区中指定文件到暂存区: git add [文件名] 撤销删除 删除工作区文件，并且也从暂存区删除对应文件的记录：git rm -f [文件名] 从暂存区中删除文件，但是工作区依然还有该文件:git rm --cached [文件名] 拉取暂存区的文件，并将其替换成工作区文件：git checkout -- [文件名]，简单的说 就是当我们把工作区弄乱了,可以帮我们 拉取暂存区 恢复工作区 查询信息 查询当前工作区所有文件的状态：git status 对比工作区和暂存区之间的差异，即修改后还没有暂存的内容：git diff 4. 暂存区操作提交文件到本地仓库 将暂存区中的文件提交到本地仓库：git commit -m &quot;commit_info&quot; 将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：git commit -a -m &quot;commit_info&quot; 提交文件时，发现漏掉几个文件，或者注释写错了，可以修改上一次提交：git commit -- amend 输入指令后会进入git vim 编辑器 按a,i或o进入编辑模式 按ESC进入操作模式 在操作模式下，:wq为写入退出,:q!不保存退出 查看信息 比较暂存区和本地仓库的差异：git diff --cached 指定文件在暂存区和本地仓库的不同：git diff [文件名] --cached; 查看提交历史：git log 参数-p展开每次提交的内容差异git log -p 用-2显示最近的两次更新git log -p -2 版本回退 将代码回退到上一次提交时的状态：git reset --hard Head 将代码回退到上上一次提交时的状态: git reset --hard Head~1 将代码回退到上上上一次提交时的状态: git reset --hard Head~2 查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本：git reflog 将代码回退到指定版本：git reset --hard [版本号] 分支管理 显示本地仓库的所有分支：git branch; 创建分支：git branch [分支名] 从当前所处的分支切换到其他分支：git checkout [分支名] 新建并切换到新建分支上：git checkout -b [分支名] 删除分支：git branch -d [分支名] 将当前分支与指定分支进行合并：git merge [分支名]; 查看各个分支最后一个提交对象的信息：git branch -v; 在远程分支的基础上创建新的本地分支：git checkout -b &lt;branch-name&gt; &lt;remote-name&gt;/&lt;branch-name&gt; 即：git checkout -b [本地分支名] origin/[远程分支名] 使用例子：git checkout -b branch-dev origin/branch-dev; 5. 本地仓库操作 添加远程仓库，取一个变量名代替地址：git remote add [变量名] [远程服务器地址] 示例：git remote add origin https://github.com/Saber-tgb/test-git.git 指定默认上传服务器地址并推送分支：git push -u origin master 将本地的master分支推送到origin服务器 同时指定origin为默认上传服务器地址，后面就可以不加任何参数使用git push了 将本地仓库某分支推送到远程仓库：git push origin [分支名] 将dev分支推送到远程仓库git push origin dev 拉取远程仓库：git pull 6. 忽略文件.gitignore 我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为 txt 的文件doc/**/*.txt]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router学习]]></title>
    <url>%2F2018%2F06%2F06%2FReact-router%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React-router介绍 React Router 是一个基于 React 之上的强大路由库 react-router、react-router-dom、react-router-native的区别 react-router: 实现了路由的核心功能 react-router-dom: 基于react-router，加入了在浏览器运行环境下的一些功能，例如：Link组件，会渲染一个a标签，Link组件源码a标签行; BrowserRouter和HashRouter组件，前者使用pushState和popState事件构建路由，后者使用window.location.hash和hashchange事件构建路由。 react-router-native: 基于react-router，类似react-router-dom，加入了react-native运行环境下的一些功能。 开发使用： react-router-dom依赖react-router，所以我们使用npm安装依赖的时候，只需要安装相应环境下的库即可，不用再显式安装react-router。基于浏览器环境的开发，只需要安装react-router-dom； 基于react-native环境的开发，只需要安装react-router-native。npm会自动解析react-router-dom包中package.json的依赖并安装。 react-router-domAPI1.BrowserRouter 使用 HTML5 提供的 history API (pushState, replaceState 和 popstate 事件) 来保持 UI 和 URL 的同步。 2.HashRouter HashRouter 使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router-dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2018%2F06%2F03%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[Cookie Cookie是什么 用户端保存请求信息的机制，在HTTP请求头中带上Cookie,用来让服务器识别请求. 格式：分号分隔的多个key-value字段 存储在本地的加密文件中 有域名和路径的限制 JavaScript中的Cookie 通过document.cookie来读取写入Cookie Cookie的属性 name: Cookie名称 domain: Cookie生效的域名 path: Cookie生效的路径 expires: Cookie过期时间 HttpOnly: 用户端不可更改 删除Cookie的方法：设置expires(过期时间)为失效时间或为0;]]></content>
      <categories>
        <category>本地存储</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript风格规范]]></title>
    <url>%2F2018%2F04%2F18%2FJavaScript%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编程风格1. 声明(块级作用域)（1）let取代var123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点；var命令存在变量提升效用，let命令没有这个问题 123456&apos;use strict&apos;;if (true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 建议不再使用var命令，而是使用let命令取代 （2）全局常量和线程安全 const优于let有几个原因: const可以提醒阅读程序的人，这个变量不应该改变 const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同 所有的函数都应该设置为常量 2. 字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = &apos;foobar&apos;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = `foobar`; 3. 结构赋值 使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4, 5];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 123456789101112131415// bad function getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123;firstName,lastName&#125;) &#123; &#125; 4. 对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾 12345678910111213// bedconst a = &#123; k1: v1, k2: v2,&#125;;const b = &#123; k1: v1, k2:v2&#125;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123;x: 2&#125;);// goodconst a = &#123;x: null&#125;;a.x = 3; 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写 123456789101112131415161718192021let ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + vlaue &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value &#125;&#125; 5. 数组 使用扩展运算符（…）拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用 Array.from 方法，将类似数组的对象转为数组 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 6. 函数 立即执行函数可以写成箭头函数的形式 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;)&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x; &#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x*x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this 1234567891011// badconst self = this;const boundMethod = function(..params) &#123; return method.apply(self,params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7. Map 结构 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。12345678910let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0],itme[1])&#125; 8. Class 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9. 模块 首先，Module 语法是 JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。 123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 12345// badimport * as myObject from &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide;- ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 如果模块默认输出一个对象，对象名的首字母应该大写。 123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide;]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ECMAScript规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js讲解]]></title>
    <url>%2F2018%2F04%2F16%2FVue.js%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.框架使用前期准备1.1 Node.js安装 直接去nodejs官网下载最新版本对应操作系统的nodejs进行安装，nodejs安装程序会自己设置环境变量，所以打开命令行输出node -v就能查看安装信息了，就说明安装成功了 npm就是nodejs的包管理工具，在安装nodejs的时候我们就会默认把npm安装了,并且已经配置到系统的环境变量Path中去，在控制台输出npm -v就能看到npm的版本 由于一些众所周知原因,有时候使用npm下载包的时候会非常慢，可以使用淘宝的镜像安装使用cnpm替代npm1npm install -g cnpm --registry=https://registry.npm.taobao.org 1.2 ES6的使用 ECMAScript 2015（以下简称 ES6）是 JavaScript 语言的新标准，使用babel可以将es6语法转换成浏览器可以识别的es5语法，在vue-cli脚手架搭建的项目中已集成bable,所以在vue项目我们可以使用ES6进行开发。 ES6常用的语法 新增let、const声明 解构赋值 1234let obj = &#123;name: &apos;alex&apos;, age: 20&#125;;let &#123;name, age&#125; = obj;console.log(name);console.log(age); 模版字符 123let obj = &#123;name: &apos;alex&apos;, age: 20&#125;;let str = `用户名：$&#123;obj.name&#125;，年龄:$&#123;obj.age&#125;`;console.log(str); 模块化：模块是js能规模化、工程化最大的基础，但之前js对定一块的支持有限，所以当前端使用多个框架或类库时很容易出现冲突等问题。当然了出了一大堆AMD解决方案如seajs,commonjs.reqiruejs…现在在ES6中，已经增加了对模块的支持。 12345678import &#123;ajaxreq&#125; from &quot;./ajax&quot;function httpget(url, pars) &#123; console.log(&apos;http get &apos;) ajaxreq(url, pars)&#125;export &#123;httpget&#125; 1.3Webpack webpack当然是现在最为流行的js打包构建工具，非常强大。相关的配置以及使用三天三夜都要讲完。推荐文档https://doc.webpack-china.org/ 大家需要去明白的webpack的作是：把js项目以及相关依赖都打成一个可真正在浏览器运行的包（尽管babel能把es6转es5,事实上webpack中js的转换也是依靠babel完成的),所以这里不仅包括js转版本，还包含样式(less,sass)、前端构建(vue,react)，以及脚本去注释、压缩、混淆，甚至样式的压缩。都是通过webpack调度各类loadder和插件来完成的。 2.Vue.js基本语法介绍什么是vue,vue能帮我们解决什么实际问题 vue简单来说就是一个MVVM框架。 所以在说vue之前，我们先谈谈什么是MVVM(Model-View-ViewModel)。在我们的web前端开发过程中，需要经常做的三个工作就是渲染、交互以及提交，简单的来说就是需要把服务器响应的数据，呈现给浏览器让用户看得到可以交互的基本性东西，由于渲染的内容用户可以做比如点击、输入甚至拖动的各类交互操作，交互完成后又最终需要把用户交互处理后的结果（比如：表单提交）再提交到服务器。 这看起来当然没什么问题，但是有一点点麻烦就是首先需要写大量的代码进行渲染，然后需要写大量的代码来适应用户的各类交互，最终又通过大量的代码来获取用户最终交互的数据，这三个过程其实是分裂的。 那有没有什么更好的办法呢，当然有了，我们的MVVM就是来解决这个问题的。想象一下，如果我们根据某些数据进行渲染完成后，当数据当生改变后与之相关的UI也会重新渲染，更厉害的是当数据绑定的UI由于用户交互发生改变时，我们的数据也会自动更新。 这想想就很激动，没错MVVM框架已经完整的帮我们实现了这一个过程操作，让我们重点去关注数据本身，剩下的就全部将由mvvm框架处理就好了。vue既然是一个mvvm框架，当然这些也就都能做到。简单的界面当然可能感觉不到这种变化带来的前端开发质的飞跃，但当界面越来越复杂、交互越来越多的时候，这种模式的优势就非常明显了。 第一个Vue程序 引用vuejs,指定一个vue呈现的Dom元素,声明一个Vue对象，并且挂载指定的Dom元素，指定显示数据,这里需要关注的是Vue初始化对象的el表示该Vue渲染的Dom对象，data则是显示的内容对象,使用Vue模板来显示数据的message属性 123456789101112131415161718192021&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;hr&gt; &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; title:&apos;第一个vue&apos;, message: &apos;Hi,Vue!!!&apos;, navlist:window.pages &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 条件与循环 在开发过程中，进行数据渲染时我们使用最多的就是根据数据显示或隐藏内容，或者循环显示列表，话不多说看代码： 123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;seen&quot;&gt;设置能看见我了...&lt;/div&gt; &lt;div v-show=&quot;show&quot;&gt;就算我不显示我也还是存在的&lt;/div&gt; &lt;div v-for=&quot;item in forlist&quot;&gt;name: &#123;&#123;item.name&#125;&#125;,age:&#123;&#123;item.age&#125;&#125;&lt;/div&gt; &lt;hr&gt; &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; seen: true, show: true, forlist: [&#123; name: &apos;alex&apos;, age: 20 &#125;, &#123; name: &apos;luke&apos;, age: 30 &#125;], title: &apos;条件与循环&apos;, navlist: window.pages &#125; &#125;);&lt;/script&gt; 在元素中使用v-show或者v-if标签是，当指定的变量值为false时，则整个元素块不会显示，但v-show只是把该元素隐藏，而v-if则不显示。如果变量值为true,则效果一致。 v-for就是更简单了，看代码就明白，不多解释。 双向数据绑定 使用vue需要着重关注的点就是，数据、方法与元素的关联关系，如怎么使一个元素的属性为数据的值，或者怎么指定一个方法为元素的事件执行方法，先看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;button @click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt; &lt;hr&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;用户名:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;职业:&lt;/th&gt; &lt;td&gt; &lt;select v-model=&quot;user.occupation&quot;&gt; &lt;option&gt;老师&lt;/option&gt; &lt;option&gt;医生&lt;/option&gt; &lt;option&gt;程序员&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别:&lt;/th&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;radioMan&quot; value=&quot;男&quot; v-model=&quot;user.sex&quot;&gt;&lt;label for=&quot;radioMan&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;radioWoman&quot; value=&quot;女&quot; v-model=&quot;user.sex&quot;&gt;&lt;label for=&quot;radioWoman&quot;&gt;女&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; 表单结果,用户名：&#123;&#123;user.name&#125;&#125;,职业：&#123;&#123;user.occupation&#125;&#125;,性别：&#123;&#123;user.sex&#125;&#125; &lt;br&gt; &lt;button @click=&quot;getFormVal&quot;&gt;表单值&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //文本绑定使用&#123;&#123;message&#125;&#125;,事件绑定使用@如@click，属性绑定 /** * 各种绑定 1.文本绑定使用&#123;&#123;message&#125;&#125; 2.属性绑定使用:class,:title=&quot;className&quot;, 3.事件绑定，使用@,@click... 4.表单绑定使用v-model=&#123;&#125; */ var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;这个是测试的内容文字啊@!!&apos;, navlist: window.pages, user: &#123; name: &apos;tgb&apos;, occupation: &apos;程序员&apos;, sex: &apos;男&apos; &#125; &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;, getFormVal: function () &#123; console.log(this.user); alert(&apos; 表单结果,用户名：&apos; + this.user.name + &apos;,职业：： &apos; + this.user.occupation + &apos;,性别：： &apos; + this.user.sex); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 组件化 vue组件是非常强大重要的功能之一，通过简单的组件封装就能在元素中使用特定功能的标签。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;br&gt; &lt;child1 :my-message=&quot;message&quot;&gt;&lt;/child1&gt; &lt;ul&gt; &lt;child2 v-for=&quot;item in userlist&quot; :user=&apos;item&apos;&gt;&lt;/child2&gt; &lt;/ul&gt; &lt;p&gt;总数&#123;&#123;total&#125;&#125;&lt;/p&gt; &lt;button1 v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button1&gt; &lt;button2 v-on:reduction=&quot;reductionTotal&quot;&gt;&lt;/button2&gt; &lt;hr&gt; &lt;a v-for=&quot;item in navlist&quot; class=&quot;nav-item&quot; :title=&quot;item.title&quot; :href=&quot;item.page&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;pages.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&apos;child1&apos;, &#123; props: [&apos;myMessage&apos;], template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos; &#125;) Vue.component(&apos;child2&apos;, &#123; props: [&apos;user&apos;], template: &apos;&lt;li&gt;名字:&#123;&#123; user.name &#125;&#125;,年龄:&#123;&#123;user.age&#125;&#125;&lt;/li&gt;&apos; &#125;) Vue.component(&apos;button1&apos;,&#123; template:&apos;&lt;button v-on:click=&quot;incrementHandler&quot;&gt;+&lt;/button&gt;&apos;, methods: &#123; incrementHandler: function () &#123; this.$emit(&apos;increment&apos;) &#125; &#125;, &#125;) Vue.component(&apos;button2&apos;,&#123; template:&apos;&lt;button v-on:click=&quot;reductionHandler&quot;&gt;-&lt;/button&gt;&apos;, methods: &#123; reductionHandler: function () &#123; this.$emit(&apos;reduction&apos;) &#125; &#125;, &#125;) new Vue(&#123; el: &apos;#app&apos;, data: &#123; message:&apos;测试的文字&apos;, navlist: window.pages, userinfo:&#123;name:&apos;alex&apos;,age:18&#125;, userlist:[ &#123;name:&apos;tonme&apos;,age:18&#125;, &#123;name:&apos;luke&apos;,age:22&#125;, ], total: 0 &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;, incrementTotal: function () &#123; this.total += 1 &#125;, reductionTotal: function () &#123; this.total -= 1 &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 3. Vue组件化开发3.1vue-cli 脚手架工具 现在前端使用的技术、框架以及工具是非常多非常麻烦的，配置对于一个新手可以说是绝望的。不过还好有一些辅助工具已经把这些工具给封装了，我们只需要简单的几个命令就可以快速把项目跑起来。 3.1.1 安装vue-cli 全局安装npm install -g vue-cli 安装成功后，使用vue -V检测版本是否已经安装成功3.1.2 搭建项目 vue init webpack my-projectname3.1.3 还原依赖并运行项目 cd my-projectname npm run dev 3.1.4 默认项目结构简单介绍 -build 构建相关的脚本目录，开发过程中几乎不需要改更 -config 构建相关的配置目录，没特殊要求也不需要修改 |—index.js 基本的配置脚本，这里可以配置启动的端口，代理等。极少用 node_modules 引用的模块目录，如果太慢可以把该目录排除，不进行索引打描。 -src 源代码开发目录，非常重要，要写的代码都在这里 |—assets 引用资源目录如图片、字体素材等. |—components 组件类库 |—router vue-router配置目录，如果需要新增router页面需要在这里进行添加 |—App.vue Vue首页 |—main.js Vue入口文件 -index.html 程序入口文件 -package.json nodejs 工程配置文件 3.1.5 Vue单文件介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;br/&gt; &lt;button @click=&quot;userclick&quot;&gt;处理一下事件吧&lt;/button&gt; &lt;hr&gt; UI组件： &lt;el-switch v-model=&quot;isselected&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt; &lt;/el-switch&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from &quot;axios&quot;;export default &#123; name: &apos;HelloWorld&apos;, data () &#123; return &#123; msg:&apos;&apos;, isselected:true &#125; &#125;, methods:&#123; userclick:function () &#123; this.msg = `改变了值...$&#123;new Date().getTime()&#125;` &#125; &#125;, mounted()&#123; let that = this; axios.get(&apos;/api/getmsg&apos;).then(res=&gt;&#123; console.log(res); that.msg = res.data.msg; &#125;); console.log(&apos;hw loadding&apos;) &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; template.该部分包含我们最终的vue前端模板 script部分为脚本编写模块 export default 为初始化vue的参数，一般采用了简写最重要的三个部分是 data 函数返回当前对象默认的数据，methods为处理绑定的方法，mounted则为页面加载时执行行回调方法，在这里我们可以向服务器发出请求获取列表，加载数据行装 stytle 就是样式了没什么好说了。 3.2 vue-router vue-router是vue生态最重要的一部分，简单来说用router后使得我们可以进行单个页面开发，控制页面的路由跳转 创建一个vue页面src\components\Profile.vue 在src/router/index.js 脚本中注册路由 123456789101112131415161718192021import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos; import Profile from &apos;@/components/Profile&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component: HelloWorld &#125;, &#123; path: &apos;/profile&apos;, name: &apos;Profile&apos;, component: Profile &#125; ]&#125;) 使用路由在入口App.Vue中增加代码 12345678910 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/profile&quot;&gt;用户中心&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 4. aixos使用和配置代理跨域 安装axiosnpm install axios -S 123456789//基本使用mounted()&#123; let that = this; axios.get(&apos;/api/getmsg&apos;).then(res=&gt;&#123; console.log(res); that.msg = res.data.msg; &#125;); console.log(&apos;hw loadding&apos;)&#125; 配置代理跨域：在config、index.js文件修改 12345proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8839/&apos; &#125; &#125;,]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vw适配移动端]]></title>
    <url>%2F2018%2F04%2F16%2Fvw%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[1.vw原理解析 vw是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小。 Viewport相关的单位有四个，分别为vw、vh、vmin和vmax: vw：是Viewport’s width的简写,1vw等于window.innerWidth的1% vh：和vw类似，是Viewport’s height的简写，1vh等于window.innerHeihgt的1% vmin：vmin的值是当前vw和vh中较小的值 vmax：vmax的值是当前vw和vh中较大的值 vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。 如果设计稿的宽度是750px，那么100vw=750px,1vw=7.5px 2.Vue项目中使用vw实现移动端适配 安装PostCSS插件 在.postcssrc.js使用postcss 已经装好有postcss-import、postcss-url、autoprefixer 新增插件：npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano --S 在.postcssrc.js文件对新安装的PostCSS插件进行配置： 12345678910111213141516171819202122232425262728module.exports = &#123; &quot;plugins&quot;: &#123; &quot;postcss-import&quot;: &#123;&#125;, &quot;postcss-url&quot;: &#123;&#125;, // 使用postcss的插件实现vw适配移动端 // 由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false &apos;postcss-aspect-ratio-mini&apos;: &#123;&#125;, // 用来处理元素容器宽高比 &apos;postcss-write-svg&apos;: &#123; // 用来处理移动端1px的解决方案 uft8:false &#125;, &apos;postcss-cssnext&apos;: &#123;&#125;, // 让项目使用CSS未来特性 并对其做兼容性处理 &apos;postcss-px-to-viewport&apos;: &#123; viewportWidth: 750, // 视窗的宽度，对应我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定&apos;px&apos;转换为视窗单位值得小数位数（很多时候无法整除） viewportUnit:&apos;vw&apos;, // 指定需要转换成的视窗单位,建议使用vw selectorBlackList: [&apos;.ignore&apos;,&apos;.hairliness&apos;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值。 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, &apos;postcss-viewport-units&apos;: &#123;&#125;, // 给CSS的属性添加content的属性 配合viewport-units-buggyfill解决个别手机不支持vw &apos;cssnano&apos;: &#123; // 压缩和清理CSS代码 preset: &apos;advanced&apos;, autoprefixer: false, &apos;postcss-zindex&apos;: false &#125; &#125;&#125; vw兼容方案: 兼容个别手机 主要使用viewport-units-buggyfill.js和viewport-units-buggyfill.hacks.js，只需要在你的HTML文件中引入这两个文件。比如在Vue项目中的index.html引入它们 &lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt; 在HTML文件中调用viewport-units-buggyfill 12345678&lt;!--使用viewport-units-buggyfill解决个别手机不支持vw--&gt;&lt;script&gt; window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); &#125;&lt;/script&gt; 前面配置的postcss-viewport-units插件。这个插件将让你无需关注content的内容，插件会自动帮你处理。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>vw适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pc端密码控件的使用]]></title>
    <url>%2F2018%2F04%2F11%2Fpc%E7%AB%AF%E5%AF%86%E7%A0%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[密码控件 PassGuard介绍 使用的密码控件是北京微通新成的 控件集成了crypto-js.js、PassGuardCtrl.js、jQuery.js、AESWithJCE.jar(解密jar); 前端初始化控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script type=&quot;text/javascript&quot;&gt; //第一步 向后台发送ajax请求获取sKey,enStr; //第二步初始化控件 //初始化控件时注意 pageEdittype必须设置为0 星号 不然会造成input框输入卡 var pgeditor = new $.pge(&#123; pgePath : &quot;./ocx/&quot;,//控件下载目录，可以指定绝对路径，如&quot;http://www.baidu.com/download/&quot; pgeId : &quot;_ocx_password&quot;,//控件id pgeEdittype : 0,//控件显示类型,0(星号),1(明文) pgeEreg1 : &quot;[\\s\\S]*&quot;,//输入过程中字符类型限制，如&quot;[0-9]*&quot;表示只能输入数字 pgeEreg2 : &quot;[\\s\\S]&#123;6,12&#125;&quot;,//输入完毕后字符类型判断条件，与pgeditor.pwdValid()方法对应 pgeMaxlength : 12,//允许最大输入长度 pgeTabindex : 2,//tab键顺序 pgeClass : &quot;ocx_style&quot;,//控件css样式 pgeInstallClass : &quot;ocx_style&quot;,//针对安装或升级的css样式 pgeOnkeydown :&quot;FormSubmit()&quot;,//回车键响应函数，需焦点在控件中才能响应 tabCallback : &quot;input2&quot;,//火狐tab键回调函数,设置要跳转到的对象ID pgeOnfocus:&quot;pgeFocus()&quot;,//监控光标切入密码控件框 pgeOnblur:&quot;pgeBlur()&quot;,//监控光标切出密码控件框 //windows10 edge&amp;Chrome42+相关 pgeWindowID:&quot;password&quot;+new Date().getTime()+1, //设置多个密码输入框是时间戳一定要不同 pgeRZRandNum:sKey, pgeRZDataB:enStr &#125;); window.pgeCtrl = pgeditor; var i = 0; //密码控件获得焦点时，提示一下 function pgeFocus()&#123; $(&quot;#tishi&quot;).html(&quot;获得焦点&quot;+(i++)); &#125; //密码控件失去焦点时获得密码强度，并展示出来 function pgeBlur()&#123; $(&quot;#tishi&quot;).html(&quot;失去焦点&quot;+(i++)); //显示密码强度 GetLevel(); &#125; window.onload = function()&#123; $(&quot;#login&quot;).focus(); pgeditor.pgInitialize(); $(&quot;lic&quot;).html(pgeditor.setLicense()); &#125; &lt;/script&gt; //第三步 点击提交时 function FormSubmit() &#123; var length = pgeditor.pwdLength();//获得密码长度 if (length == 0 || length == undefined) &#123; setTimeout(function()&#123; alert(&quot;密码不能为空&quot;); _$(&quot;_ocx_password&quot;).focus(); &#125;,0); return false; &#125; if (pgeditor.pwdValid() == 1) &#123;//判断密码是否匹配正则表达式二 setTimeout(function()&#123; alert(&quot;密码不符合要求&quot;); _$(&quot;_ocx_password&quot;).focus(); &#125;,0); return false; &#125; // 一定要再次请求获取随机因子并设置 // 后台保存此次的sKey //pgeditor.pwdResult()是提交给后台的 加了AES密文的密码 $.ajax( &#123; url : &quot;./srand_num.jsp?&quot; + get_time(),//get_time()防止缓存 type : &quot;GET&quot;, async : false, success : function(srand_num) &#123; pgeditor.pwdSetSk(srand_num);//给控件设置随机因子 &#125; &#125;); var pwdResult = pgeditor.pwdResult();//获取密码AES密文 var machineNetwork = pgeditor.machineNetwork();//获取网卡信息密文 var machineDisk = pgeditor.machineDisk();//获取硬盘信息密文 var machineCPU = pgeditor.machineCPU();//获取CPU信息密文 _$(&quot;password&quot;).value = pwdResult;//将密码密文赋值给表单 _$(&quot;local_network&quot;).value = machineNetwork;//将网卡和MAC信息密文赋值给表单 _$(&quot;local_disk&quot;).value = machineDisk;//将硬盘信息密文赋值给表单 _$(&quot;local_cpu&quot;).value = machineCPU;//将CPU信息密文赋值给表单 document.form1.submit();&#125; 第四步 服务器端调用安全控件解密接口进行解密]]></content>
      <categories>
        <category>应用工具</category>
      </categories>
      <tags>
        <tag>密码控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS调试的5个debug技巧]]></title>
    <url>%2F2018%2F03%2F01%2FJS%E8%B0%83%E8%AF%95%E7%9A%845%E4%B8%AAdebug%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1.debugger 直接在javaScript代码中加入一句debugger手工造成一个断点效果 带有条件的断点吗？你只需要用if语句包围它1234if (somethingHappens) &#123; debugger;&#125; 2.设置在DOM node发生变化时触发断点 DOM不受你的控制，自己会发生一些奇怪的变化，让你很难找出问题的根源 3.Ajax 断点]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中的类]]></title>
    <url>%2F2018%2F03%2F01%2FES6%E4%B8%AD%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类的声明 基本的类声明语法：要声明一个类，首先编写class关键字，紧跟着的是类的名字，其他部分的语法类似于对象字面量方法的简写形式 1234567891011121314151617class PersonClass &#123; //等价于PersonClass构造函数 constructor(name) &#123; this.name &#125; //等价于PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass(&apos;tgb&apos;);person.sayName(); //outputs &apos;tgb&apos;console.log(person instanceof PersonClass); //trueconsole.log(person instanceof Object); trueconsole.log(typeof PersonClass); //&apos;function&apos;console.log(typeof PersonClass.prototype.sayName); //&apos;function&apos; 提升：类声明不会声明提升，你首先需要声明你的类，然后访问它，否则会抛出一个ReferenceError： 类语法的特性: 类声明与let声明类似，不能被提升，真正执行声明语句之前，他们会一直存在于临时死区中 类声明中的所有代码将自行运行在严格模式下，而且无法强行 类中所有方法都是不可枚举的 每个类都有一个名为[[constructor]]的内部方法,通过关键字new调用那些不含[[constructor]]的方法会导致程序抛出错误 使用除关键字new以外的方式调用类的构造函数会导致程序抛出错误 在类中修改类名会导致程序报错 类表达式promise 一个 Promise 就是一个代表了异步操作最终完成或者失败的对象. 一个promise可以使用它的constructor创建 本质上，一个promise是某个函数返回的对象，你可以把回调函数绑定在这个对象上，而不是把回调函数当作参数传进函数]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS总结]]></title>
    <url>%2F2018%2F02%2F02%2FCSS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSS介绍 CSS 指层叠样式表 (Cascading Style Sheets)，是用来定义HTML元素在页面中如何显示。 CSS写法分类 行内样式：通过标签中style属性来设置只能作用在当前标签之中，出了这个标签就没有作用，使用情况少(特定场合，整个页面只有这个标签出现了这个样式) 1&lt;p style=&apos;font-size:16px;color:#fff&apos;&gt;行内样式&lt;/p&gt; 内嵌样式：把样式写在&lt;head&gt;标签中的&lt;title&gt;标签下，并用标签去声明 12345678910111213141516171819202122232425 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&apos;text/css&apos;&gt; .p1 &#123; color: red; &#125; .p2 &#123; color: yellow; &#125; .p3 &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;p1&quot;&gt;内嵌样式第一行&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;内嵌样式第二行&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;内嵌样式第三行行&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外联样式: 在外部定义CSS样式表并形成以.CSS为扩展名文件，然后在页面中通过链接标记链接到页面中，而且该链接语句必须放在页面的标记区。为了结构样式分离，推荐写法。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link type=&apos;text/css&apos; rel=&apos;stylesheet&apos; href=&apos;./base.css&apos;&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;p1&quot;&gt;内嵌样式第一行&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;内嵌样式第二行&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;内嵌样式第三行行&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS选择器 基础选择器： E：元素选择器（以DOM元素名称来匹配） .classname ：类选择器（以类名来匹配） #id ：ID选择器（以唯一标识符id属性匹配） * ：通配选择器（可匹配任意类型的DOM元素） 组合选择器 A B ：后代选择器（匹配A元素内的B元素，包含所有匹配的子孙后代） A &gt; B ：子选择器（匹配A元素内的直接后代B元素，不包含孙辈） A,B,C: 群组选择器的使用范畴是，多个选择器使用同一个样式或者同一组样式。这在做CSS样式初始化，CSS框架设计以及后期CSS代码优化时会经常使用。多个选择器之间用逗号（,）隔开，其语法形式为：&lt;选择器1&gt;,&lt;选择器2&gt;，&lt;选择器3&gt; { 定义样式 }； A + B ：相邻兄弟选择器（匹配A元素后的兄弟B元素，B元素必须紧跟着A元素）,“+”只能选择该选择器相邻的下一个选择器 群组选择器的使用范畴是，多个选择器使用同一个样式或者同一组样式。这在做CSS样式初始化，CSS框架设计以及后期CSS代码优化时会经常使用。多个选择器之间用逗号（,）隔开，其语法形式为：&lt;选择器1&gt;,&lt;选择器2&gt;，&lt;选择器3&gt; { 定义样式 }； A ~ B ：普通兄弟选择器（匹配A元素后的兄弟B元素，B元素只需在A元素后，不要求紧跟）,能选择该选择器后的所有同级选择器 伪元素选择器 E::after / E:after ：两个等价，用来创建已选中元素的一个虚拟的最后子元素（行内元素），必须设置content属性 E::before / E:before ：两个等价，用来创建已选中元素的一个虚拟的第一个子元素（行内元素），必须设置content属性 CSS3新增 E::first-letter / E:first-letter ： 匹配已选中元素内的文字的第一行的第一个字母（只作用于块元素） E::selection ： 设置文档被选择时的样式 E::first-line / E:first-line ：设置匹配元素内的第一行文字（只作用于块元素） E::placeholder ：设置表单输入框占位符 伪类选择器 E:focus ： 匹配一个成为焦点的元素（该元素的onfocus事件发生） E:link ： 设置超链接a在未被访问状态的样式 E:visited：匹配超链接a在其链接地址已被访问过的元素 E:active ： 匹配被用户激活的元素（在鼠标点击与释放之间发生的事件） E:hover ： 匹配鼠标悬停在其上面的元素 结构伪类选择器(CSS3新增 移动端常用) E:nth-child(n)：选择所有在其父元素中第n个位置的匹配E的子元素，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始 tr:nth-child(3)匹配所有表格中第3排的tr； tr:nth-child(2n+1)匹配所有表格的奇数行； tr:nth-child(2n)匹配所有表格的偶数行； tr:nth-child(odd)匹配所有表格的奇数行； tr:nth-child(even)匹配所有表格的偶数行； E:last-child: 选择位于其父元素中最后一个位置，且匹配E的子元素。 E:nth-last-child(n)：选择所有在其父元素中倒数第n个位置的匹配E的子元素 E:nth-of-type(n):匹配同类型中的第n个兄弟元素E E:nth-last-of-type(n):选择父元素中倒数第n个位置，且匹配E的子元素。 E:first-of-type：选择位于其父元素中且匹配E的第一个同类型的子元素。该选择器的功能类似于 E:nth-of-type(1) E:last-of-type：选择位于其父元素中且匹配E的最后第一个同类型的子元素。该选择器的功能类似于 E:nth-last-of-type(1) E:only-child：选择其父元素只包含一个子元素，且该子元素匹配E。 E:only-of-type：选择其父元素只包含一个同类型的子元素，且该子元素匹配E。5.属性选择器 a[href]:a标签中含有href属性的所有标签 a[href=”1.pm4”]:a标签中含有href=”1.mp4”的标签 a[href^=”a”]:a标签中有href属性并且以a字母开头的所有标签 a[href$=”d”]:a标签中有href属性并且以d字母结束的所有标签 a[href*=”g”]:a标签中有href属性并且g字母的所有标签 CSS三大特性 继承性 子元素可以继承父元素的样式， (字体)text-，(字体大小)font-，(行高)line-这些开头的属性都可以继承，以及(颜色)color属性 优先级 选择器是有优先级，其划分是根据权重来的; 权重 !important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 算法：（0，0，0，0）==》第一个0对应的是important的个数，第二个0对应的是id选择器的个数，第三个0对应的类选择器的个数，第四个0对应的是标签选择器的个数， 先从第一个0开始比较，如果第一个0大，那么说明这个选择器的权重高，如果第一个相同，比较第二个，依次类推 层叠性 如果两个相同的属性作用于同一标签，它们会发生层叠。如果多个复合选择器，同时作用于我们的同一标签，优先级就不好计算了，就要计算权重，通过比较权重，来先出优先级最高的选择器 浏览器的渲染机制是从上到下的，当有冲突的时候就采用权重最高的,权重相同则后面覆盖前面 CSS样式内外边距（margin、padding），边框(border) css盒子模型概念 在CSS中，所有的网页元素都被看作一个矩形框，或者是元素框。盒子模型描述了元素在网页布局中所占的空间和位置，盒子模型包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素，在写CSS时可以理解成’万物皆盒子’。 图中最内部的框是元素的实际内容，也就是元素框，紧挨着元素框外部的是内边距padding，其次是边框（border），然后最外层是外边距（margin），整个构成了框模型。通常我们设置的背景显示区域，就是内容、内边距、边框这一块范围。而外边距margin是透明的，不会遮挡周边的其他元素。 元素框的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度； 元素框的总高度 = 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度 css 外边距合并（叠加） 两个上下方向相邻的元素框垂直相遇时，外边距会合并，合并后的外边距的高度等于两个发生合并的外边距中较高的那个边距值，如图： 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并 在CSS重置时,经常用到. 1234* &#123;margin : 0;padding : 0;&#125; 开发技巧 margin塌陷 当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象 解决方法 给父元素加边框border （副作用） 给父元素设置padding值 （副作用） 父元素添加 overflow：hidden （副作用） 父元素加前置内容生成(::before)。（推荐） 常用：margin: 0 auto实现水平居中 box-sizing属性介绍(CSS3新增) box-sizing : content-box|border-box|inherit; content-box ,默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的width只包含内容。总宽度=margin+border+padding+width border-box , 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容，即总宽度=margin+width inherit , 规定应从父元素继承 box-sizing 属性的值 border-box的使用 一个box宽度为100%，又想要两边有内间距，这时候用就比较好 全局设置 border-box 更符合我们通常对一个「盒子」尺寸的认知，可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度，在写移动端重置css时全局写 边框(border) border：设置元素的边框（width style color） border-width：设置元素边框的宽度 border-style：设置元素边框的样式 border-color：设置元素边框的颜色 单独设置元素边框 border-top|right|bottom|left border-top-width border-top-style border-top-color 使用border画三角形123456.triangle &#123; width : 0; height: 0; border : 100px solid transparent; border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/ &#125; 定位 position：设置元素的定位方式 static: 没有定位，元素出现在正常的流中 relative: 生成相对定位的元素，相对于元素本身正常位置进行定位。没有脱离文本流，且会占用该元素在文档中初始的页面空间，即在使用top，bottom，left，right进行移动位置之后依旧不会改变其所占用空间的位置。可以使用z-index进行在z轴方向上的移动 absolute: 绝对定位方式，脱离文档流，不会占用页面空间。以最近的不是static定位的父级元素作为参考进行定位，如果其所有的父级元素都是static定位，那么此元素最终则是以当前窗口作为参考进行定位(body元素) fixed: 固定定位，直接以浏览器窗口作为参考进行定位 开发中使用定位实现盒子上下垂直居中,‘父相子绝’ 1234567891011121314.father &#123; position:relative; width:500px; height:500px;&#125;.father .son &#123; width:200px; height:200px; position:absolute; top:50%; left:50%; margin-top:-100px; margin-left:-100px;&#125; 实现水平垂直居中 1234567891011.box &#123; width: 400px; height: 400px; background: #000; position: absolute; top:0; right:0; bottom:0; left:0; margin: auto; &#125; z-index：设置一个元素的堆叠顺序(Z轴)，可为负数（只作用于定义了position为非static的元素） 浮动布局 float：设置元素是否及如何浮动 clear：用来清除浮动 在页面标准流中，块级元素独占一行,自上而下排列，为了实现在一行中显示多个块计元素，就要用到浮动让某个块级元素脱硫标准流，漂浮在标准流上。 visibility：hidden设置元素是否显示（占的位置依旧存在） overflow：设置元素处理溢出内容的方式 overflow-x：设置元素处理横向溢出内容的方式 overflow-y：设置元素处理纵向溢出内容的方式 overflow-wrap：设置当内容溢出时，是否允许换行（和word-wrap一样） 清除浮动的几种方式123456789101112131415/*单伪元素法*/.clearfix:after &#123; content: &apos;&apos;; clear: both; display: block; height: 0; &#125;/*双伪元素法*/.clearfix:before,.clearfix:after &#123; content:&apos;&apos;; display:table;&#125;.clearfix:after &#123; clear:both;&#125; flex布局(弹性布局)flex布局介绍 为什么使用flex布局：布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 PC端除了要照顾ie9及以前的用户,移动端已经全面支持,是现在的主流布局方式 Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 flex布局基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 主要介绍:https://saber-tgb.github.io/2017/09/12/flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/ 网格布局(Grid布局) 浏览器兼容性:CSS网格布局从Safari 10.1, Firefox 52, Opera 44, Chrome 57开始收到支持，微软Edge在Edge 15会更新对网格布局的支持。 字体、文本、文本装饰、书写模式 字体 font：设置元素的文本特性（style variant weight size lineHeight family） font-style：设置文本字体样式 font-variant：设置文本是否为小型的大写字母 font-weight：设置文本的字体粗细 font-size：设置文本的字体大小 font-family：设置文本的字体名称列表 font-stretch：设置文字是否横向拉伸变形 font-size-adjust：设置字体大小取决于小写字母，而不是大写字母 @font-face：设置自定义字体 文本 text-transform：设置文本的大小写 white-space：设置元素中的空格的处理方式 tab-size：设置制表符的长度 word-break：设置怎样在单词内断行 word-wrap/overflow-wrap：两者等价，设置内容溢出时是否断行 text-align：设置行内内容相对它的块父元素的水平对齐方式 text-align-last：设置内容最后一行的水平对齐方式 text-justify：设置文本怎样对齐及对齐间距 word-spacing：设置字与字之间的间距 letter-spacing：设置字符间的间距 text-indent：设置文本的缩进 vertical-align：设置内联元素在行框内的垂直对齐方式 line-height：设置文本的行高 text-size-adjust：设移动端页面中元素文本的大小调整 开发常用：文本超出显示省略号(…)1234width: 300px //要设置宽度overflow: hidden;white-space: nowrap;text-overflow: ellipsis; 文本装饰 text-decoration：设置文本的排版（line style color） text-decoration-line：设置文本的排版种类 text-decoration-color：设置文本的排版颜色 text-decoration-style：设置文本的排版样式 text-underline-position：设置文本的下划线的位置（支持度不高） 书写模式 direction：设置文本流的方向 unicode-bidi：用于同一个页面里存在从不同方向读进的文本显示 writing-mode：设置内容块固有的书写方向 背景、颜色 背景 background：设置背景（属性：color position size repeat origin clip attachment image）（可设置多个背景，每组属性间用逗号分隔） background-color：设置背景色 background-image：设置背景路径（可设置多个背景，每组属性间用逗号分隔） background-repeat：设置背景是否平铺及平铺方式 颜色 color：设置文本颜色 opacity：设置元素的不透明度（0~1） 颜色值 color name：颜色名称 HEX：十六进制记法 RGB：rgb记法 RGBA：rgba记法 CSS3 CSS3介绍： 是CSS的第三套标准,CSS3的标准规范还没有确定下来，W3C 仍然在对 CSS3 规范进行开发。所以在pc端的浏览器支持程度差，需要添加私有前缀,移动端浏览器用的都是最新版本所以不存在兼容性。 私有前缀 更具常用的浏览器内核来划分：chrome firefox IE Safari Opera WebKit内核 css前缀-webkit- Mozilla内核 css前缀-moz- Opera 内核 css前缀 -o- Trident内核 css前缀 -ms- 开发中使用PostCSS的Autoprefixer插件自动补充前缀 文字阴影 text-shadow: h-shadow v-shadow blur color h-shadow 必需。水平阴影的位置。允许负值 v-shadow 必需。垂直阴影的位置。允许负值 blur 可选。模糊的距离 color 可选。阴影的颜色 边框- 边框圆角：`border-radius:200px 200px 200px 200px` - 参数：原点、半径1-4个，可以不一样 - 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ） - 盒阴影：`box-shadow: h-shadow v-shadow blur spread color inset;` - h-shadow 必需。水平阴影的位置。允许负值。 - v-shadow 必需。垂直阴影的位置。允许负值 - blur 可选。模糊距离 - spread 可选。阴影的尺寸。 - color 可选。阴影的颜色。请参阅 CSS 颜色值。 - inset 可选。将外部阴影 (outset) 改为内部阴影。 渐变- CSS实现响应式布局 通过查询screen的宽度来指定某个宽度区间的网页布局。 超小屏幕（移动设备） 768px以下 小屏设备 768px-992px 中等屏幕 992px-1200px 宽屏设备 1200px以上1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*0-768 需要在移动端的时候 显示绿色并且是100%显示*//*需要查询当前屏幕下的尺寸 and 之后需要加空格*/@media screen and (max-width:768px)&#123; /*定义我们这个区间内的样式*/ .container&#123; width: 100%; background: green; &#125;&#125;/*768-992 需要在小屏幕设备下 显示黄色并且宽度750px*/@media screen and (min-width:768px) and (max-width: 992px)&#123; /*定义我们这个区间内的样式*/ .container&#123; width: 750px; background: yellow; &#125;&#125;/*992-1200 需要在中等屏幕下 显示蓝色并且 宽度是 970px*/@media screen and (min-width:992px) and (max-width: 1200px)&#123; /*定义我们这个区间内的样式*/ .container&#123; width: 970px; background: blue; &#125;&#125;/*1200 需要在大屏幕下 显示粉红色 宽度1170px*/@media screen and (min-width:1200px)&#123; /*定义我们这个区间内的样式*/ .container&#123; width: 1170px; background: pink; &#125;&#125; bootstrap框架用来开发响应式页面]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习--path模块]]></title>
    <url>%2F2018%2F01%2F23%2FNode-js%E5%AD%A6%E4%B9%A0-path%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node中的路径分类 node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径。 假设的文件目录结构如下 1234path/ - dist/ - src/ - task.js 在task.js文件中写入以下代码 12345const path = require(&apos;path&apos;);console.log(__dirname);console.log(__filename);console.log(prcess.cwd()); //返回Node.js 进程当前工作的目录。console.log(path.resolve(&apos;./&apos;)); 在editor目录下运行node src/task.js，我们可以看到结果如下： 1234F:\SelfProject\nodeJS-demo\path\srcF:\SelfProject\nodeJS-demo\path\src\task.jsF:\SelfProject\nodeJS-demo\pathF:\SelfProject\nodeJS-demo\path 在src目录下运行这个文件，node task.js,运行结果如下: 1234/Users/laihuamin/Documents/richEditor/editor/src/Users/laihuamin/Documents/richEditor/editor/src/task.js/Users/laihuamin/Documents/richEditor/editor/src/Users/laihuamin/Documents/richEditor/editor/src 归纳 __dirname:返回的是这个文件所在文件夹的位置 __filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件 process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止 path的模块path.normalize(规范化路径) 例子12345const path = require(&apos;path&apos;);console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;));/* 输出结果 *//foo/bar/baz/asdf path.join 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\”。 1234const path = require(&apos;path&apos;);console.log(path.join(&apos;src&apos;,&apos;task.js)); //src/task.jsconsole.log(path.join(&apos;/foo&apos;,&apos;bar&apos;,&apos;baz/asdf&apos;,&apos;quux&apos;,&apos;..&apos;)); //\foo\bar\baz\asdf 规则: 1.传入的参数是字符串的路径片段，可以是一个，也可以是多个 2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。 3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。 4.如果传入的参数中有不是字符串的，那就直接会报错 path.parse(string) 返回路径字符串的路径 123456789const path = require(&apos;path&apos;);console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));&#123; root: &apos;/&apos;, dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;, base: &apos;task.js&apos;, ext: &apos;.js&apos;, name: &apos;task&apos; &#125; 对象解析: 1.root：代表根目录 2.dir：代表文件所在的文件夹 3.base：代表整一个文件 4.name：代表文件名 5.ext: 代表文件的后缀名 path.basename 返回路径中的最后一个部分 可以接收两个参数，一个是path,还有一个是ext（可选参数）.123const path = require(&apos;path&apos;);console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;)); //task.jsconsole.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;)); //task path.dirname]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>path模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目搭建]]></title>
    <url>%2F2018%2F01%2F18%2FReact%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[React项目搭建使用create-react-app创建项目 安装： npm install -g create-react-app 创建项目：create-react-app my-app cd my-app yarn install yarn start 使用react-app-rewired改写项目有配置 安装yarn add react-app-rewired --save-dev 在项目根目录创建config-overrides.js文件 1234module.exports = function override(config, env) &#123; //do stuff with the webpack config... return config;&#125; 改写package.json文件 123456789 /* package.json */ &quot;scripts&quot;: &#123;- &quot;start&quot;: &quot;react-scripts start&quot;,+ &quot;start&quot;: &quot;react-app-rewired start&quot;,- &quot;build&quot;: &quot;react-scripts build&quot;,+ &quot;build&quot;: &quot;react-app-rewired build&quot;,- &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,+ &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;&#125; 在react-app-rewire改写的项目中配置Sass和Less1. Sass使用配置 安装yarn add react-app-rewire-sass-modules sass-loader node-sass -D 在config-overrides.js文件中添加配置12345const rewireSass = require(&apos;react-app-rewire-sass-modules&apos;);module.exports = function override(config, env) &#123; config = rewireSass(config, env); return config;&#125; 2. Less使用配置 安装yarn add react-app-rewire-less -D 在config-overrides.js文件中添加配置12345678const rewireLess = require(&apos;react-app-rewire-less&apos;);/* config-overrides.js */module.exports = function override(config, env) &#123; config = rewireLess(config, env); // with loaderOptions // config = rewireLess.withLoaderOptions(someLoaderOptions)(config, env); return config;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下使用命令行查看端口号和关闭进程]]></title>
    <url>%2F2018%2F01%2F03%2FWindows%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E5%85%B3%E9%97%AD%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[查看端口 netstat -nao 查看所有端口 netstat -nao | findstr &quot;9010&quot; 只查看9010端口 通过PID查找到相应的进程 tasklist | findstr &quot;3017&quot; 通过PID关闭进程 taskkill /pid 3017]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack的学习一]]></title>
    <url>%2F2017%2F12%2F24%2Fwebpack%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[安装 使用之前确保安装了 Node.js 的最新版本; 官方推荐本地安装webpack,使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目 npm install --save-dev webpack npm脚本命令: webpack --config webpack.config.js webpack概念入口- entry属性：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 - 通过在webpack.config.js配置文件中配置`entry`属性，来指定一个入口起点（或多个入口起点） 123 module.exports = &#123; entry: &apos;path/to/my/entry/file.js&apos;&#125; 出口 output属性：告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程12345678const path = require(&apos;path&apos;); module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125; &#125;; loader(装载) loader:让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理 weppack的核心思想–“万物皆模块” loader的目标 识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性) 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性)123456789101112131415const path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; plugins(插件) plugins概念：插件用于loader不能完成的任务，插件可以执行范围更广的任务，从打包优化和压缩，一直到重新定义环境中的变量 插件使用：只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例12345678910111213141516171819202122 const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装 const webpack = require(&apos;webpack&apos;); // 用于访问内置插件 const path = require(&apos;path&apos;); const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ] &#125;;module.exports = config; 管理资源加载CSS 为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader npm install --save-dev style-loader css-loader 123456789101112131415module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader, &apos;css-loader&apos; ] &#125; ] &#125; ...&#125; 对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use这告诉 webpack 编译器(compiler) 如下信息 “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 加载Sass npm install --save-dev style-loader css-loader node-sass sass-loader node-sass 和 webpack 是 sass-loader 的 peerDependency，因此能够精确控制它们的版本。12345678910111213141516module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\.scss$/, use: [ &apos;style-loader, // 将 JS 字符串生成为 style 节点 &apos;css-loader&apos;, // 将 CSS 转化成 CommonJS 模块 &apos;sass-loader&apos; // 将 Sass 编译成 CSS ] &#125; ] &#125; ...&#125; 加载less npm install --save-dev style-loader css-loader less-loader less123456789101112131415161718// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\.less$/, use: [&#123; loader: &quot;style-loader&quot; // creates style nodes from JS strings &#125;, &#123; loader: &quot;css-loader&quot; // translates CSS into CommonJS &#125;, &#123; loader: &quot;less-loader&quot; // compiles Less to CSS &#125;] &#125;] &#125;&#125;; 加载图片 使用 file-loader，我们可以将图片混合到 CSS 中 npm install --save-dev file-loader1234567891011121314module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125; ] &#125; ...&#125; 加载字体- 使用file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录 1234567891011121314module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125; ] &#125; ...&#125; 加载数据 要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader1234567891011121314151617181920module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\.(csv|tsv)$/, use: [ &apos;csv-loader&apos; ] &#125;, &#123; test: /\.xml$/, use: [ &apos;xml-loader&apos; ] &#125; ] &#125; ...&#125; 管理输出使用HtmlWebpackPlugin 在webpack.config.js配置时，当我们更改一个入口起点的名称，甚至添加了一个新的名称，生成的包将重命名，但是html文件还是会引用旧的名字，为了解决这种问题,HtmlWebpackPlugin将生成自动引用js包文件名的html文件 npm install --save-dev html-webpack-plugin1234567891011121314151617const path = require(&apos;path&apos;); const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos;, print: &apos;./src/print.js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;Output Management&apos; &#125;) ], output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125; &#125;; 清理上次webpack生成的文件夹(/dist文件夹) 由于过去的指南和代码示例遗留下来，导致我们的 /dist 文件夹相当杂乱，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件,使用clean-webpack-plugin插件 npm install clean-webpack-plugin --save-dev12345678910111213141516171819const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos;, print: &apos;./src/print.js&apos; &#125;, plugins: [ new CleanWebpackPlugin([&apos;dist&apos;]), new HtmlWebpackPlugin(&#123; title: &apos;Output Management&apos; &#125;) ], output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125;;]]></content>
      <categories>
        <category>前端构建生态</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习--重置密码]]></title>
    <url>%2F2017%2F12%2F22%2FMysql%E5%AD%A6%E4%B9%A0-%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1.打开mysql.exe和mysqld.exe所在的文件夹,复制路径地址 2.通过cmd命令进入mysql.exe所在的文件夹。 cd C:\Program Files\MySQL\MySQL Server 5.5\bin 3.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的学习四]]></title>
    <url>%2F2017%2F12%2F21%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[web服务器的主要功能 建立连接 接受请求–从网络中读取一条HTTP请求报文 处理请求–对请求报文进行解释，并采取行动 构建响应–创建带有正确首部的HTTP响应报文 发送响应–将响应回送给客服端 记录事务处理过程–将于已完成事务有关的内容记录在一个日志文件中。 代理 web代理服务器是网络的中间实体，代理位于客服端和服务器之间，扮演‘中间人’的角色，在各端点之间来回传送HTTP报文。]]></content>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习--module模块]]></title>
    <url>%2F2017%2F12%2F13%2FNode-js%E5%AD%A6%E4%B9%A0-module%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[exports和module.exports的区别 模块require方只能看到module.exports这个对象，它是看不到exports对象的，而我们在编写模块时用到的exports对象实际上只是对module.exports的引用。1234567891011121314151617exports.name = (x) =&gt; &#123; console.log(x);&#125;//和下面一样，修改的都是同一内存地址里的东西module.exports.name = (x) =&gt; &#123; console.log(x);&#125;/*----------下面这样写就存在区别-------------*///下面的 function是一块新的内存地址，导致exports与module.exports不存在任何关系，而require方能看到的只有module.exports这个对象，看不到exports对象，所以这样写导不出去。exports = (x) =&gt; &#123; console.log(x);&#125;//下面的写法是可以导出,说句题外话，module.exports除了导出对象，函数，还可以导出所有的类型，比如字符串、数值module.exports = (x) =&gt; &#123; console.log(x);&#125;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>module模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM操作]]></title>
    <url>%2F2017%2F12%2F08%2FDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[DOM的定义 文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合 DOM节点 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个HTML元素是元素节点 HTML元素内的文本是文本节点 每个HTML属性是属性节点 注释是注释节点 DOM节点树 HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树：通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。 节点的关系 父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹） 在节点树中，顶端节点被称为根（root） 每个节点都有父节点、除了根（它没有父节点） 一个节点可拥有任意数量的子 同胞是拥有相同父节点的节点 HTML DOM方法(元素节点方法) 方法是我们可以在节点上执行的动作获取DOM元素方法 getElementById 1document.getElementById(&apos;id&apos;); getElementsByTagName 1document.getElementsByTagName(&apos;li&apos;) //返回数组 getElementsByClassName 1document.getElementsByClassName(&apos;class&apos;) querySelector 1document.querySelector(&quot;#myid .myclass&quot;); //返回文档中匹配指定的选择器组的第一个元素 querySelectorAll 1document.querySelectorAll(&apos;#myClass&apos;); //返回的 NodeList 将包含文档中的所有节点，这些都是由特定选择器匹配的 获取设置属性接的的方法 getAttribute() 返回元素上一个指定的属性值。如果指定的属性不存在，则返回 null 或 “” （空字符串）let div1 = document.getElementById(“div1”);let align = div1.getAttribute(“align”);12let dive = document.getElementById(&apos;div1&apos;);let align = div.getAttribute(&apos;align&apos;); setAttribute() 设置指定元素上的一个属性值。如果属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值。123456//语法element.setAttribute(name, value);let div1 = document.getElementById(&quot;div1&quot;); div1.setAttribute(&quot;align&quot;, &quot;center&quot;); removeAttribute()从指定的元素中删除一个属性123let div = document.getElementById(&quot;div1&quot;)div.removeAttribute(&quot;align&quot;); HTML DOM属性 属性是节点（HTML 元素）的值，您能够获取或设置。 Element.innerHTML 属性设置或获取描述元素后代的HTML语法 Node.nodeName 返回当前节点的节点名称 nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document Node.nodeName 返回或设置当前节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 Node.nodeType 只读属性,表示的是该节点的类型。 元素类型|NodeType元素|1文本|3注释|8文档(Document)|95.Node.childNodes 返回包含指定节点的子节点的集合(NodeList 类型)]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG Sprites的使用]]></title>
    <url>%2F2017%2F12%2F08%2FSVG%20Sprites%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SVG简介 SVG是一种开放标准的矢量图形语言，使用svg格式我们可以直接用代码来描绘图像，可以用任何文字处理工具打开svg图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来浏览。 SV优缺点 优点 缺点 1.缩放无损还原，显示清晰 1.SVG在绘制的性能上比PNG要差 2.语义性良好 2.局限性，对应单色或普通渐变没什么问题，但对不规则的渐变以及特效叠加效果显示不全 3.可用CSS控制图标样式以及动画 3.兼容性稍差，android4.1才开始支持 4.减少http请求 4.学习应用成本较高 使用 SVG 中的 symbol，use 元素来制作SVG Sprite l;]’SVG Symbols的使用，本质上是对Sprite的进一步优化，通过&lt;symbol&gt;元素来对单个SVG元素进行分组，使用&lt;use&gt;元素引用并进行渲染。这种方法的解决了上述三种方式带来的弊端，少量的http请求，图标能被缓存方便复用，每个SVG图标可以更改大小颜色，整合、使用以及管理起来非常简单 Web应用中SVG的使用方式(了解) 使用img、object、embed 标签直接引用svg 此方法的缺点主要在于每个图标都需单独保存成一个 SVG 文件，使用时单独请求，增加了HTTP请求数量。123&lt;img src=&quot;./example.svg&quot; alt=&quot;svg图标&quot;&gt;&lt;object class=&quot;example&quot; data=&quot;./example.svg&quot; type=&quot;image/svg+xml&quot;&gt;My Example SVG&lt;/object&gt;&lt;iframe src=&quot;example.svg&quot; class=&quot;example&quot;&gt;&lt;/iframe&gt; 直接把SVG写入 HTML 中 Inline SVG 作为HTML文档的一部分，不需要单独请求。临时需要修改某个图标的形状也比较方便。但是Inline SVG使用上比较繁琐，需要在页面中插入一大块SVG代码不适合手写，图标复用起来也比较麻烦。123&lt;svg width=&quot;300&quot; height=&quot;200&quot; class=&quot;example&quot;&gt; &lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;green&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; SVG Sprite 这里的Sprite技术，类似于CSS中的Sprite技术。图标图形整合在一起，实际呈现的时候准确显示特定图标。其实基础的SVG Sprite也只是将原来的位图改成了SVG而已，控制SVG大小、颜色需要重新合并SVG文件123456789101112131415.icon-bg&#123; display: inline-block; width: 30px; height: 30px; background: url(./res/svg-sprite-background.svg); background-size:100% 100%;&#125;.icon-facebook-logo&#123; background-position: 0 0;&#125;.icon-earth&#123; background-position: 0 -30px;&#125;&lt;span class=&quot;icon-bg icon-facebook-logo&quot;&gt;&lt;/span&gt;&lt;span class=&quot;icon-bg icon-earth&quot;&gt;&lt;/span&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语句]]></title>
    <url>%2F2017%2F12%2F04%2FJavaScript%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[一、条件语句1.if12345if (表达式) &#123; //表达式为真执行&#125; else &#123; //否则&#125; 只有false,null,’undefined’,空字符串,数字0,数字NaN的值为假，其他所有值都是真2.switch语句12345678910switch (i) &#123; case 25: alert(25); break; case 36: alert(36); bresk; default: alert(11);&#125; 3.while语句12345var i = 0;while(i&lt;10) &#123; alert(i); i+=1;&#125; 二、循环语句1.for语句123for (var i = 0;i&lt;10; i++) &#123; console.log(i);&#125; 2.for in 语句 判断对象是否有属性myvar12345for (myvar in obj) &#123; if(obj.hasOwnProperty(myvar)) &#123; console.log(&apos;有&apos;) &#125;&#125; 三、强制跳转语句1.break语句立即退出循环，(循环结束)强制执行循环后的语句2.continue语句只退出当前循环，退出循环后会从循环的顶部继续执行。]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2017%2F11%2F08%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[书写 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 hexo server -o #开启服务打开页面 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署 hexo deploy -g hexo server -g]]></content>
      <categories>
        <category>应用工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js--Express框架的学习]]></title>
    <url>%2F2017%2F10%2F12%2FExpress%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Express框架安装 npm install -g express npm install -g express-generator安装Express项目生成器 初始化项目 创建文件名为demo的项目 express --view=ejs demo cd demo npm install 项目启动 npm start 启动文件是/bin/www，默认端口：3000]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习--HTTP模块]]></title>
    <url>%2F2017%2F10%2F12%2FNode.js%E5%AD%A6%E4%B9%A0--HTTP%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[HTTP的基本概念 什么是I/O? 指的的是磁盘的读入和读出input/output 什么是单线程/多线程 单线程：只有一个线程，代码顺序执行，容易出现代码阻塞 多线程：有多个线程，线程间独立运行，能有效地避免代码阻塞，并且提高程序的运行性能，但是要注意资源分配 什么是阻塞/非阻塞 阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。做某件事情，直到完成，除非超时 指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。尝试做，如果不能做，就不做（直接返回），如果能做，就做。 什么是事件驱动 为某个事件注册了函数，但是这个函数不是马上执行，只有事件发生才会调用该函数，这种函数的执行方式就叫做事件驱动。 什么是基于事件驱动的回调 注册的回调函数的执行方式是事件驱动 执行上下文 this的指向问题，当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文就构成了一个执行上下文栈 call和apply方法能改变上下文，改变了this的指向。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>HTTP模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器的命令]]></title>
    <url>%2F2017%2F10%2F11%2FChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Chrome浏览器的命令 chrome://about显示所有的命令 chrome://net-internals抓保工具和DNS管理]]></content>
      <categories>
        <category>浏览器基础</category>
      </categories>
      <tags>
        <tag>Chrome浏览器命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习--URL模块]]></title>
    <url>%2F2017%2F10%2F11%2FNode.js%E5%AD%A6%E4%B9%A0-URL%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[URL模块 url模块提供了两套API处理URL，一套是NOde.js特有的API，另一个是WHATWG URL 规范提供的API,Node.js官方推荐使用WHATWG URLAPI WHATWG URL规范API解析url字符串 在浏览器中，WHATWG URL在全局总是可用的1234567891011121314151617const &#123;URL&#125; = require(&apos;url);let myURL = new URL(&apos;https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;);console.log(myURL);//得到结果URL &#123; href: &apos;https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;, origin: &apos;https://sub.host.com:8080&apos;, protocol: &apos;https:&apos;, username: &apos;user&apos;, password: &apos;pass&apos;, host: &apos;sub.host.com:8080&apos;, hostname: &apos;sub.host.com&apos;, port: &apos;8080&apos;, pathname: &apos;/p/a/t/h&apos;, search: &apos;?query=string&apos;, searchParams: URLSearchParams &#123; &apos;query&apos; =&gt; &apos;string&apos; &#125;, hash: &apos;#hash&apos; &#125; URL.parse()解析网址 在Node.js中，任何情况下打开 或使用一个链接都必须事先引用’url’模块：require(&#39;url&#39;).URL，通过Node.js提供的API解析一个URL: 123456789101112131415161718const url require(&apos;url&apos;);let myURL = url.parse(&apos;http://www.imooc.com:8080/video/6710?from=scott&amp;course=node#floor1&apos;)console.log(myURL);//得到结果Url &#123; protocol: &apos;http:&apos;, //使用的协议 slashes: true, //是否有协议的双斜线 auth: null, // host: &apos;www.imooc.com:8080&apos;, //ip地址(域名) port: &apos;8080&apos;, //端口 hostname: &apos;www.imooc.com&apos;, //主机名 hash: &apos;#floor1&apos;, //锚点内容 search: &apos;?from=scott&amp;course=node&apos;, //查询字符串参数 query: &apos;from=scott&amp;course=node&apos;, //发送给服务器的数据，参数 pathname: &apos;/video/6710&apos;, //访问资源的路径名 path: &apos;/video/6710?from=scott&amp;course=node&apos;, //路径 href: &apos;http://www.imooc.com:8080/video/6710?from=scott&amp; course=node#floor1&apos; //完整的超链接统一资源定位符&#125; URLSearchParams API接口 接口提供对URLquery(查询字符串)部分的读写权限1234567891011121314const &#123; URL, URLSearchParams &#125; = require(&apos;url&apos;);const myURL = new URL(&apos;https://example.org/?abc=123&apos;);const newSeachParams = new URLSearchParams(myURL.searchParams);//实例化成URLSearchParams对象console.log(newSeachParams); //URLSearchParams &#123; &apos;abc&apos; =&gt; &apos;123&apos; &#125;newSeachParams.append(&apos;a&apos;,&apos;c&apos;);console.log(newSeachParams); //URLSearchParams &#123; &apos;abc&apos; =&gt; &apos;123&apos;, &apos;a&apos; =&gt; &apos;c&apos; &#125;console.log(newSeachParams.toString()); //abc=123&amp;a=cnewSeachParams.delete(&apos;a&apos;);console.log(newSeachParams); //URLSearchParams &#123; &apos;abc&apos; =&gt; &apos;123&apos; &#125; url.domainToASCII(domain) 返回Punycode ASCII序列化的域名，如果domain是无效域名，将返回空字符串12const url = require(&apos;url&apos;);console.log(url.domainToUnicode(&apos;汤国斌.com&apos;)); //xn--vcss25ae8e.com url.domainToUnicode(domain) 返回Unicode序列化的domain. 如果domain是无效域名，将返回空字符串。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>URL模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue双向数据绑定原理]]></title>
    <url>%2F2017%2F10%2F10%2FVue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Object.defineProperty 这是一个ES5的方法，可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的；即设置了value属性。 123456789let obj = &#123;name:&apos;vue&apos;&#125;;Object.defineProperty(obj,&apos;age&apos;,&#123; value:3, writable:true, enumerable:true, configurable:true&#125;)o.age = 4;console.log(o.age); //4 存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。 12345678910111213141516171819202122let obj = &#123;name:&apos;vue&apos;&#125;;let bValue;Object.defineProperty(obj,&apos;b&apos;,&#123; get:function() &#123; console.log(&apos;获取&apos;); return bValue; &#125;, set:function (newValue) &#123; console.log(&apos;设置&apos;); bValue = newValue &#125;, enumerable:true, configruable:true&#125;)0.b = &apos;something&apos;;console.log(o.b);console.log(bValue);// 4//设置//获取//something//something 设置了value属性就不能设置getter-setter函数 数据描述符和存取描述符均具有以下可选键值 configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 存取描述符同时具有以下可选键值 get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包的开发及发布]]></title>
    <url>%2F2017%2F10%2F10%2Fnpm%E5%8C%85%E7%9A%84%E5%BC%80%E5%8F%91%E5%8F%8A%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[npm创建 npm init name：填写你这个包的名字，默认是你这个文件夹的名字。不过这里要着重说一下，最好先去npm上找一下有没有同名的包。最好的测试方式就是，在命令行里面输入npm install 你要取的名字，如果报错，那么很好，npm上没有跟你同名的包，你可以放心大胆地把包发布出去. version：你这个包的版本，默认是1.0.0，以后要在package.json文件中更改版本号才能重新发布npm包 description：用一句话描述你的包是干嘛用的。 entry point：入口文件，默认是Index.js，你也可以自己填写你自己的文件名 test command：测试命令，这个直接回车就好了，因为目前还不需要这个。 git repository：这个是git仓库地址，如果你的包是先放到github上或者其他git仓库里，这时候你的文件夹里面会存在一个隐藏的.git目录，npm会读到这个目录作为这一项的默认值。如果没有的话，直接回车继续。 keyword：这个是一个重点，这个关系到有多少人会搜到你的npm包。尽量使用贴切的关键字作为这个包的索引。 author：写你的账号或者你的github账号吧 license：开源文件 npm包的开发 npm包的发布 本地登录npm账号npm login,输入账户，密码，邮箱 发布npm publish]]></content>
      <categories>
        <category>前端构建生态</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stylus的使用]]></title>
    <url>%2F2017%2F09%2F25%2FStylus%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass的使用]]></title>
    <url>%2F2017%2F09%2F25%2FSass%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less的使用]]></title>
    <url>%2F2017%2F09%2F25%2FLess%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Less安装 npm install less -g全局安装less,webStorm编辑器的插件会将less编译为css 浏览器直接使用less 1234//.less 样式表的链接，并将 rel 属性设置为 &quot;stylesheet/less&quot; 在 less.js 之前加载样式表。&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;./index.less&quot;&gt;// 使用`less.js`插件解析less&lt;script src=&quot;http://cdn.bootcss.com/less.js/1.7.0/less.min.js&quot;&gt;&lt;/script&gt; 在vue框架中使用less,安装npm包npm install --save-dev less less-loader Less的语法变量 将常用的值定义在一个地方 定义常用选择器@mySelector:banner;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发]]></title>
    <url>%2F2017%2F09%2F25%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[小程序的基本文件功能 .js后缀的是脚本文件,.json后缀的文件是配置文件,.wxss后缀的是样式表文件 app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量 app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则 小程序模板的使用定义模板 在template文件目录下定义template.wxml文件 使用 name 属性，作为模板的名字。然后在&lt;template/&gt;内定义代码片段 123456&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 使用模板 1234// 引入模板&lt;import src=&apos;./template/template.wxml&apos;&gt;&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt; 小程序请求用户的信息小程序开发遇到的坑小程序request请求不支持cookie，所以使用cookie储存登录状态的方案不可行 造成的问题： http请求header不携带设备信息，服务器无法获取。服务器通过session来识别客服端,小程序request请求不能使用cookie,导致每次请求的session都不同。 解决：小程序支持自定义cookie，通过后台服务器与小程序的关联的接口，获取一次session，之后封装小程序的request请求，在session有效期内每次请求发送给后台的session都一至。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647request: function(url, meth, data, cb) &#123; let that = this; wx.request(&#123; url: url, method: meth, data: data, header: &#123; &quot;Cookie&quot;: that.globalData.Cookie, &#125;, success: function (res) &#123; //session过期 if (res.data.code == 403) &#123; wx.login(&#123; success: res =&gt; &#123; if (res.code) &#123; wx.request(&#123; url: that.globalData.baseUrl + that.globalData.api.getSession, method: &apos;GET&apos;, data: &#123; code: res.code &#125;, header: &#123; &quot;Cookie&quot;: that.globalData.Cookie, &#125;, success: function (res) &#123; //重新获取session that.globalData.Cookie = &apos;JSESSIONID=&apos; + res.data.sessionId; that.request(); &#125;, &#125;); &#125; else &#123; console.log(&apos;获取用户登录态失败！&apos; + res.errMsg) &#125; &#125; &#125;) return false; &#125; else if (res.data.code == 500) &#123; wx.showModal(&#123; content: &apos;服务器繁忙, 请稍后再试&apos;, &#125;) console.log(res.data.msg||&apos;&apos;); return false; &#125; cb(res); &#125;, &#125;) &#125;, 小程序地图 遇到的问题:根据地址名称在小程序地图上展示该位置 使用微信小程序JavaScript SDK123456789101112131415161718192021// 引入SDK核心类var QQMapWX = require(&apos;xxx/qqmap-wx.js&apos;); // 实例化API核心类var demo = new QQMapWX(&#123; key: &apos;开发密钥（key）&apos; // 必填&#125;); // 调用接口demo.geocoder(&#123; address: &apos;北京市海淀区彩和坊路海淀西大街74号&apos;, success: function(res) &#123; console.log(res); &#125;, fail: function(res) &#123; console.log(res); &#125;, complete: function(res) &#123; console.log(res); &#125;&#125;);]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号网页开发]]></title>
    <url>%2F2017%2F09%2F21%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript--作用域]]></title>
    <url>%2F2017%2F09%2F18%2FECMAScript-%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[微信JS-SDK的使用]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%BE%AE%E4%BF%A1JS-SDK%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[概述 微信JS-SDK是微信提供的一套调用微信内部API功能的的插件 JS-SDK使用 域名绑定 引入JS html文件中直接引入JS文件http://res.wx.qq.com/open/js/jweixin-1.2.0.js vue单页面项目使用： 安装npm install --save weixin-js-sdk 组件中使用import wx from &#39;weixin-js-sdk&#39; 通过config接口注入权限验证配置 通过后台提供的接口设置config12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名，见附录1 jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2&#125;); 通过ready接口处理成功验证wx.ready(function(){}) vue单页面项目wx.ready写在主组件里面 通过error接口处理失败验证wx.error(function(res){}) ##接口调用说明 所有接口通过wx对象(也可使用jWeixin对象)来调用，参数是一个对象，除了每个接口本身需要传的参数之外，还有以下通用参数 success：接口调用成功时执行的回调函数。 fail：接口调用失败时执行的回调函数。 complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。 cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。 trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回 基础接口的使用 图片上传 调用wx.chooseImage选择图片或拍照,再调用上传图片接口wx.uploadImage上传到微信服务器获取到serverId，最后调用后台接口上传到公司服务器，根据后台返回的imgURl在页面显示123456789101112131415161718192021222324252627282930313233343536//示例wx.chooseImage(&#123; count: 1, sizeType: [&apos;original&apos;, &apos;compressed&apos;], sourceType: [&apos;album&apos;, &apos;camera&apos;], success: function (res) &#123; let localId = res.localIds.toString(); wx.uploadImage(&#123; localId: localId, isShowProgressTips: 1, success: function (res) &#123; var serverId = res.serverId; // 返回图片的服务器端ID let parms = &#123; mediaid:serverId &#125; that.imgBoxWrapShow = true; imgUpload(parms).then( res =&gt; &#123; let &#123;code,msg,data&#125; = res; if(code!==0) &#123; alert(msg); that.imgBoxWrapShow = false; return false; &#125; that.imgArr.push(data); if(that.imgArr.length&gt;=4) &#123; that.uploadImgShow=false; &#125; that.imgBoxWrapShow = false; &#125;) &#125;, fail: function() &#123; alert(&apos;上传失败&apos;); &#125; &#125;); &#125;, &#125;); 禁止微信的功能 123456789101112131415161718192021//隐藏微信的功能 wx.hideMenuItems(&#123; menuList: [ &apos;menuItem:share:qq&apos;, &apos;menuItem:share:weiboApp&apos;, &apos;menuItem:favorite&apos;, &apos;menuItem:share:facebook&apos;, &apos;menuItem:share:QZone&apos;, &apos;menuItem:editTag&apos;, &apos;menuItem:delete&apos;, &apos;menuItem:copyUrl&apos;, &apos;menuItem:originPage&apos;, &apos;menuItem:readMode&apos;, &apos;menuItem:openWithQQBrowser&apos;, &apos;menuItem:openWithSafari&apos;, &apos;menuItem:share:email&apos;, &apos;menuItem:share:brand&apos;, &apos;menuItem:share:appMessage&apos;, &apos;menuItem:share:timeline&apos; ] &#125;);]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>JS-SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组的使用]]></title>
    <url>%2F2017%2F09%2F18%2F%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、数组的基本方法arr.concat(item…) concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组123var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];var b = [1,2,3,4,5];var c = a.concat(b) // c变成[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,1,2,3,4,5]; arr.join(separator); join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中,默认的separator是逗号’,’,如果separator是空字符串(“”)，则所有元素之间都没有任何字符。join() 方法，不会改变数组。12345678910111213141516let a = [&apos;Wind&apos;, &apos;Rain&apos;, &apos;Fire&apos;];a.join(); // 默认为 &quot;,&quot;// &apos;Wind,Rain,Fire&apos;a.join(&quot;&quot;); // 分隔符 === 空字符串 &quot;&quot;// &quot;WindRainFire&quot;a.join(&quot;-&quot;); // 分隔符 &quot;-&quot;// &apos;Wind-Rain-Fire&apos;console.log(a);// [&apos;Wind&apos;, &apos;Rain&apos;, &apos;Fire&apos;] array.pop() pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。1234567let a = [1, 2, 3];a.length; // 3a.pop(); // 3console.log(a); // [1, 2]a.length; // 2 array.push(item…) push() 方法将一个或多个元素添加到数组的末尾，并返回新数组的长度,如果参数item是一个数组，它会把参数组作为单个元素整个添加到数组中。12345678910var numbers = [1, 2, 3];numbers.push(4);console.log(numbers); // [1, 2, 3, 4]numbers.push([5, 6, 7]);console.log(numbers); // [1, 2, 3, 4, [5, 6, 7]] array.reverse() reverse方法反转array里的元素的顺序，并返回array本身1234var a =[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var b = a.reverse();console.log(a) //[&apos;c&apos;,&apos;b&apos;,&apos;a&apos;]console.log(b) //[&apos;c&apos;,&apos;b&apos;,&apos;a&apos;] array.shift() shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。12345678let a = [1, 2, 3];let b = a.shift();console.log(a); // [2, 3]console.log(b); // 1 array.unshift(item…) unshift 方法将一个或多个元素添加到数组的开头，并返回新数组的长度12345let a = [1, 2, 3];a.unshift(4, 5);console.log(a);// [4, 5, 1, 2, 3] array.slice(begin,end) slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，原始数组不会被修改。 参数begin(可选)：从该索引处开始提取原数组中的元素，如果该参数是负数，则表示从原数组中的倒数第几位元素开始提取(slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素，包含最后一个元素),如果省略begin则索引从0开始 参数end(可选)：如果 end 被省略，则slice 会一直提取到原数组末尾,如果 end 大于数组长度，slice 也会一直提取到原数组末尾。 12345678arr.slice();// [0, end]arr.slice(begin);// [begin, end]arr.slice(begin, end);// [begin, end) slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组,如arguments 123function list() &#123; return Array.prototype.slice.call(arguments); // return [].slice.call(arguments);&#125; array.splice(start) splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。返回一个包含被移除元素的数组。12345array.splice(start)array.splice(start, deleteCount) array.splice(start, deleteCount, item1, item2, ...) 1234567var myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;sturgeon&apos;];myFish.splice(2, 0, &apos;drum&apos;); // 在索引为2的位置插入&apos;drum&apos;// myFish 变为 [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]myFish.splice(2, 1); // 从索引为2的位置删除一项（也就是&apos;drum&apos;这一项）// myFish 变为 [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;] array.sort(comparefn) sort方法 默认排序顺序是根据字符串Unicode码点，如果指明了comparefn，那么数组会按照调用该函数的返回值排序。12345678// 比较数组数组var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);// [1, 2, 3, 4, 5] 二、ES5数组方法forEach() forEach() 方法对数组的每个元素执行一次提供的函数,遍历数组 1234567891011const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr.forEach(function(item,index) &#123; console.log(item) //数组的每一项 console.log(index) //数组的索引&#125;)arr.forEach( (item,index) =&gt; console.log(index+&apos;:&apos;+item));// 0:a// 1:b// 2:c 语法： callback:为数组中每个元素执行的函数，该函数接收三个参数 currentValue(当前值):数组中正在处理的当前元素 index(索引):数组中正在处理的当前元素的索引 array:forEach()方法正在操作的数组 thisArg(可选):可选参数。当执行回调 函数时用作this的值(参考对象)12345array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 使用thisArg 1234567891011121314151617181920function Counter() &#123; this.sum = 0; this.count = 0;&#125;Counter.prototype.add = function(array) &#123; array.forEach(function(entry) &#123; this.sum += entry; ++this.count; &#125;, this); //console.log(this);&#125;;var obj = new Counter();obj.add([1, 3, 5, 7]);obj.count; // 4 === (1+1+1+1)obj.sum;// 16 === (1+3+5+7) forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。 map() map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回一个新数组，每个元素都是回调函数的结果。map 不修改调用它的原数组本身123456789101112131415// ES6let numbers = [1, 5, 10, 15];let doubles = numbers.map( x =&gt; x ** 2);// doubles is now [1, 25, 100, 225]// numbers is still [1, 5, 10, 15]const numbers = [2, 4, 8, 10];let halves = numbers.map(x =&gt; x / 2);let numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots is now [1, 2, 3]// numbers is still [1, 4, 9] filter() filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素,filter不会改变原数组。1234567891011121314151617function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44]// ES6 wayconst isBigEnough = value =&gt; value &gt;= 10;let [...spraed]= [12, 5, 8, 130, 44];let filtered = spraed.filter(isBigEnough);// filtered is [12, 130, 44] some() some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试(即寻找数组中是否有符合条件的值),返回布尔值(符合ture,否则false),不会改变原数组。 some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。123456789const isBiggerThan10 = (element, index, array) =&gt; &#123; return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(isBiggerThan10); // false[12, 5, 8, 1, 4].some(isBiggerThan10); // true every() every() 方法测试数组的所有元素是否都通过了指定函数的测试 为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。12345678//检测数组中的所有元素是否都大于 10function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true indexOf() indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。123456var array = [2, 5, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 lastIndexOf() lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。12345678910111213var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3 isArray() Array.isArray() 用于确定传递的值是否是一个 Array。1234567891011121314151617// 下面的函数调用都返回 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());// 鲜为人知的事实：其实 Array.prototype 也是一个数组。Array.isArray(Array.prototype); // 下面的函数调用都返回 falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray(&apos;Array&apos;);Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); #三、ES6新增数组方法 Array.from(arrayLike, mapFn, thisArg) Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。 123456const bar = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];Array.from(bar);// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]Array.from(&apos;foo&apos;);// [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;] Array.from(arguments) 可以代替Array.prototype.slice.call(arguments)将类数组转换成一个数组]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mockServer的搭建]]></title>
    <url>%2F2017%2F09%2F18%2FmockServer%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用json-server模拟服务器mockServer的思路 以 json-server 作为 mock 服务器， mock.js 生成 mock 数据，以此达到 mock-server 要求。 安装 全局安装npm install -g json-server 项目安装npm install --save-dev json-server 安装mock.js快速创建模拟接口 npm install --save-dev mock.js 配置 在项目根目录下创建mock文件夹 再分别创建db.js作为 mock 数据源、router.js作为 mock 服务、server.js重写路由表 db.js配置接口 123456789101112131415161718// db.jsvar Mock = require(&apos;mockjs&apos;);module.exports = &#123; getComment: Mock.mock(&#123; &quot;error&quot;: 0, &quot;message&quot;: &quot;success&quot;, &quot;result|40&quot;: [&#123; &quot;author&quot;: &quot;@name&quot;, &quot;comment&quot;: &quot;@cparagraph&quot;, &quot;date&quot;: &quot;@datetime&quot; &#125;] &#125;), addComment: Mock.mock(&#123; &quot;error&quot;: 0, &quot;message&quot;: &quot;success&quot;, &quot;result&quot;: [] &#125;)&#125;; 通过路由表routes.js实现路由配置 1234module.exports = &#123; &quot;/comment/get.action&quot;: &quot;/getComment&quot;, &quot;/comment/add.action&quot;: &quot;/addComment&quot;&#125; server.js正式使用json-server 12345678910111213141516171819202122232425262728// server.jsconst jsonServer = require(&apos;json-server&apos;)const db = require(&apos;./db.js&apos;)const routes = require(&apos;./router.js&apos;)const port = 3000;const opn = require(&apos;opn&apos;)const server = jsonServer.create()const router = jsonServer.router(db)const middlewares = jsonServer.defaults()const rewriter = jsonServer.rewriter(routes)let url = &apos;http://localhost:&apos; + portserver.use(middlewares)// 将 POST 请求转为 GETserver.use((request, res, next) =&gt; &#123; request.method = &apos;GET&apos;; next();&#125;)server.use(rewriter) // 注意：rewriter 的设置一定要在 router 设置之前server.use(router)server.listen(port, () =&gt; &#123; console.log(&apos;open mock server at localhost:&apos; + port) opn(url);&#125;) 使用 在package.json中配置命令 配置mockServer启动&quot;mockServer&quot;: &quot;node mock/server.js&quot; 配置mockServer和项目一起启动&quot;mock&quot;: &quot;npm run mockServer | npm run dev&quot; 调用命令启动项目和mockServernpm run mock 端口代理 通过 Webpack 配置 proxy 代理,vue-cli创建的项目在config/index.js中配置 12345678910//配置代理proxyTable: &#123; &apos;/api/&apos;: &#123; target: &apos;http://localhost:3000&apos;, changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125; &#125;&#125;, 接口请求案例,以 axios 为例子 12345function getComments () &#123; axios.get(&apos;api/comment/get.action&apos;, &#123;&#125;).then((res) =&gt; &#123; console.log(res.data) &#125;)&#125;]]></content>
      <categories>
        <category>前端构建生态</category>
      </categories>
      <tags>
        <tag>mockServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS技能学习]]></title>
    <url>%2F2017%2F09%2F14%2FPS%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[截图 选中图层，通过裁剪工具裁剪指定像素，按住回车键裁剪图片，按住ctrl键+shift键+alt键+s存储为web格式 Photoshop界面设置 窗口只显示字符、信息、图层、历史记录 视图&gt;显示勾选上智能参考线，视图 勾选上标尺 Photoshop基本工具操作移动工具设置 快捷键V 快速获取移动工具 通过Ctrl键+鼠标左键获取图层选区工具]]></content>
      <categories>
        <category>Photoshop与切图</category>
      </categories>
      <tags>
        <tag>PS切图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主体配置]]></title>
    <url>%2F2017%2F09%2F13%2FNext%E4%B8%BB%E4%BD%93%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。 hexo的next主题个性化配置教程: https://segmentfault.com/a/1190000009544924#articleHeader19 NexT主题安装下载NexT主题12cd your-hexo-site`git clone https://github.com/iissnan/hexo-theme-next themes/next 修改站点配置文件修改站点配置文件_config.yml，找到以下部分1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape 修改为12345# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/# theme: landscapetheme: next` 至此，NexT主题就安装好了，非常方便，在Hexo中切换主题只需修改站点配置文件中theme属性来配置，想换就换。 选择SchemeNexT 通过 Scheme 提供主题中的主题。Mist是NexT主题自带的主题，可以通过修改主题配置文件中的scheme属性获得。12# Schemesscheme: Mist #去掉默认的注释即可切换为Mist主题 菜单设置NexT主题菜单设置，用于设置博客上方导航栏，在主题配置文件中修改。1234567menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 只是在menu选项中设置还不能让标签页面、分类页面生效，需要我们手动创建 标签页面 运行以下命令1hexo new page &quot;tags&quot; 同时，在/source目录下会生成一个tags文件夹，里面包含一个index.md文件 修改/source/tags目录下的index.md文件 1234title: tagsdate: 2015-09-29 14:37:02type: &quot;tags&quot;--- 修改主题配置文件去掉tags的注释 1234567menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 分类页面 运行以下命令 hexo new page &quot;categories&quot;同时，在/source目录下会生成一个categories文件夹，里面包含一个index.md文件 修改/source/categories目录下的index.md文件 修改主题配置文件:去掉categories的注释 侧边栏头像设置编辑站点配置文件，增加avatar字段 头像avatar: /images/avatar.png123456头像图片须放置在主题的/source/images/目录下### 搜索使用Sitemap插件 可方便管理员通知搜索引擎他们网站上有哪些可供抓取的网页，有助于让别人更好地通过搜索到自己的博客。1. sitemap安装配置 `npm install hexo-generator-sitemap --save`2. 修改站点配置文件 Extensionsplugins: hexo-generator-sitemap1使用以下命令后，你可以在站点的/public目录下找到一个sitemap.xml文件，这个文件就是你的站点地图，里面包含你的站点的网页地址。 hexo cleanhexo g`提交sitemap到google参考如何向google提交sitemap]]></content>
      <categories>
        <category>应用工具</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局学习]]></title>
    <url>%2F2017%2F09%2F12%2Fflex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[flex布局基础知识 main axis(主轴): Flex容器的主轴主要用来配置Flex项目。它不一定是水平，这主要取决于flex-direction属性 main-start|main-end(主轴起点|主轴终点): Flex项目的配置从容器的主轴起点开始,往主轴终点结束 main size(主轴方向长度):Flex项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。 cross axis(侧轴):与主轴垂直的轴称作侧轴，是侧轴方向的延伸。 cross-start | cross-end(侧轴起点|侧轴终点):伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。 cross size(侧轴方向长度):Flex项目的在侧轴方向的宽度或高度就是项目的侧轴长度，Flex项目的侧轴长度属性是width或height属性，由哪一个对着侧轴方向决定。 Flex容器属性(主容器) display: 定义一个Flex容器，根据其取的值来决定是内联还是块。Flex容器会为其内容建立新的伸缩格式化上下文。(定义成flex容器不等于定义成块级容器) flex-direction: 定义主轴方向，Flex项目在Flex容器中放置的方向 row(默认值): Flex项目从左向右排列 row-reverse: 与row相反，Flex项目从右向左排列 column: Flex项目从上向下排列 columne-reverse: 与column相反，Flex项目从下向上排列 flex-wrap: 定义Flex项目是否多行显示 nowrap(默认值): 单行显示，从左向右排列 wrap: 多行显示，从左向右排列 wrap-reverse: 多行显示，从右向左排列 flex-flow: flex-direction和flex-wrap属性的缩写 默认值是row nowrap justify-content: 定义主轴方向的对齐方式 flex-start(默认值): Flex项目主轴起点对齐，伸缩项目向一行的起始位置靠齐。该行的第一个伸缩项目在主轴起点边的外边距与该行在主轴起点的边对齐，同时所有后续的伸缩项目与其前一个项目对齐 flex-end: Flex项目主轴终点对齐，伸缩项目向一行的结束位置靠齐。该行的最后一个伸缩项目在主轴终点边的外边距与该行在主轴终点的边对齐，同时所有前面的伸缩项目与其后一个项目对齐。 center: Flex项目主轴居中对齐，伸缩项目向一行的中间位置靠齐。该行的伸缩项目将相互对齐并在行中居中对齐，同时第一个项目与该行在主轴起点的边的距离等同与最后一个项目与该行在主轴终点的边的距离（如果剩余空间是负数，则保持两端溢出的长度相等）。著作权归作者所有。 space-between: Flex项目主轴两端对齐，伸缩项目会平均地分布在行里。如果剩余空间是负数，或该行只有一个伸缩项目，则此值等效于flex-start。在其它情况下，第一个项目在主轴起点边的外边距会与该行在主轴起点的边对齐，同时最后一个项目在主轴终点边的外边距与该行在主轴终点的边对齐，而剩下的伸缩项目在确保两两之间的空白空间相等下平均分布。 space-around: Flex项目主轴平均分布对齐，伸缩项目会平均地分布在行里，两端保留一半的空间。如果剩余空间是负数，或该行只有一个伸缩项目，则该值等效于center。在其它情况下，伸缩项目在确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半下平均分布。 align-items: 定义侧轴方向的对其方式 flex-start: flex项目侧轴起点对齐，伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边 flex-end: flex项目侧轴终点对齐,伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。 center: flex项目侧轴居中对齐，伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。 baseline: flex项目侧轴基线对齐，如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。 stretch: 如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。 align-content: 定义Flex项目多行的对齐方式，本属性在只有一行的伸缩容器上没有效果 flex-start: 各行向伸缩容器的起点位置堆叠。伸缩容器中第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点的边，之后的每一行都紧靠住前面一行。 flex-end:各行向伸缩容器的结束位置堆叠。伸缩容器中最后一行在侧轴终点的边会紧靠住该伸缩容器在侧轴终点的边，之前的每一行都紧靠住后面一行。 center:各行向伸缩容器的中间位置堆叠。各行两两紧靠住同时在伸缩容器中居中对齐，保持伸缩容器在侧轴起点边的内容边和第一行之间的距离与该容器在侧轴终点边的内容边与第最后一行之间的距离相等。（如果剩下的空间是负数，则行的堆叠会向两个方向溢出的相等距离。） space-between:各行在伸缩容器中平均分布。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于flex-start。在其它情况下，第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点边的内容边，最后一行在侧轴终点的边会紧靠住伸缩容器在侧轴终点的内容边，剩余的行在保持两两之间的空间相等的状况下排列。 space-around:各行在伸缩容器中平均分布，在两边各有一半的空间。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于center。在其它情况下，各行会在保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半的状况下排列。 stretch(默认值):各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于flex-start。在其它情况下，剩余空间被所有行平分，扩大各行的侧轴尺寸。 Flex项目属性 order:默认值是0，Flex项目是按文档源的流顺序排列,根据order重新排序伸缩项目。有最小（负值最大）order的伸缩项目排在第一个。若有多个项目有相同的order值，这些项目照文件顺序排。这个步骤影响了伸缩项目生盒树成的盒子的顺序，也影响了后面的演算法如何处理各项目。著作权归作者所有。 123.item &#123; order:&lt;number&gt;&#125; flex-grow: 定义一个Flex项目的扩大比例。它接受一个没有单位的值作为一个比例。它可以使用Flex项目完全占用Flex容器可用的空间。如果所有Flex项目的flex-grow设置为1时，表示Flex容器中的Flex项目具有相等的尺寸。如果你给其中一个Flex项目设置flex-grow的值为2，那么这个Flex项目的尺寸将是其他Flex项目两倍（其他Flex项目的flex-grow值为1）。flex-grow取负值将失效。 flec-shrink: 可以定义Flex项目的缩小比例,flex-shrink取负值将失效。 flex-basis: 定义主轴方向的长度(width|height)。定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸。main-size值使它具有匹配的宽度或高度，不过都需要取决于flex-direction的值。如果设置为0，内容不在考虑周围额外空间。如果设置为auto，额外空间会基于flex-grow值做分布。 flex: 是flex-grow，flex-shrink和flex-basis三个属性的缩写。第二个和第三个参数(flex-shrink和flex-basis)是可选值。其默认值是0 1 auto。 align-self: 用来在单独的伸缩项目上覆写默认的对齐方式。（对于匿名伸缩项目，align-self的值永远与其关联的伸缩容器的align-items的值相同)。 flex-start: 伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。 flex-end: 伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。 center: 伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。 baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。 stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识体系整理]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前端知识分类 HTML CSS DOM和BOM ECMAScript 前端构建生态 模块化、框架、组件 Node.js 应用工具学习 canvas HTTP协议 浏览器基础 Photoshop与切图 Git HTML meta内容与设置 一般常用标签 HTML5新增语义化标签 HTML常用属性 搜索引擎优化 CSS css常用属性 css层叠概念 css选择器和优先级 盒子模型 css布局方式 编译工具less和sass css实现响应式：利用媒体查询media query css移动端开发：rem和em的原理和实现 css动画及动画库的使用 css的UI框架 bootstrap 基于vue框架-PC端elm框架 基于vue框架-移动端vux框架 DOM和BOM DOM对象document DOMAPI操作 BOM对象的使用 ECMAScript ECMAScript基本语法 内置对象：RegExp、Math、Date、Error、Functio、Arguments、 AJAX原理与实现 面向对象与继承 原型和原型链 作用域和作用域链 执行上下文：由变量对象、this、作用域链组成 函数闭包使用和优缺点 ES6新增语法和特性 构建生态 npm、yarm包管理工具 gulp、webpack开发打包工具 模块化、框架、组件 JQuery、zepto库的使用原理及插件开发 模块化规范：commonJS、AMD规范(RequireJS)和CMD规范(SeaJS)、ES6模块化规范 MVC、MVVM思想 双向数据绑定 Vue框架的使用原理及组件开发 React框架 Node.jscanvas本地存储HTTP HTTP协议内容：HTTP1.0、HTTP1.1、HTTP2.0 HTTP请求过程 HTTP缓存与状态码判断过程 浏览器跨域问题及处理方式 浏览器基础 浏览器的组成 用户界面：用户地址栏、前进后退按钮 浏览器引擎：浏览器指令解析模块 持久化存储：localstorage、webSQL、indexDb、cookie UI后端：浏览器默认控件库 网络模块： 浏览器向服务器发送请求模块 JS解析引擎 浏览器渲染引擎(内核) 应用工具微信Photoshop与切图数据库]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6九————JS中的类]]></title>
    <url>%2F2017%2F08%2F23%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B9%9D--Class%2F</url>
    <content type="text"></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue脚手架vue-cli的学习二--自定义模块]]></title>
    <url>%2F2017%2F08%2F22%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-cli</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6十三]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[模块 模块是自动运行在严格模式下并且没有办法退出运行的Javascript代码，在模块中创建的变量不会自动被添加到全局作用域 模块的两个特性：在模块顶部，this的值是undefined；模块不支持HTML风格的代码注释 模块的导入导出语法 导出的基本语法：用export关键字将代码暴露给其他模块 123456789// 导出数据export var color = &apos;red&apos;;export let name = &apos;tgb&apos;;export const magicNumber = 7;// 导出函数export function sum(num1,num2) &#123; return num1 + num2;&#125; 导入的基本语法：通过import关键字在另一个模块中访问，import语句的两个部分分别是，要导入的标识符和标识符应当从哪个模块导入 1234567import &#123;identifierl,identifier2&#125; from &apos;./example.js&apos;//模块说明符// 导入多个绑定import &#123; sum, multiply, magicNumber&#125; from &apos;./example.js&apos;;// 导入整个模块import * as example from &apos;./expmple.js&apos; // 命名空间导入 模块说明符的注意事项：Node.js遵循文件系统前缀区分本地文件和包的惯例，例如，example是一个包而./example.js是一个本地文件 从模块中导入绑定时，import后面使用的标识符，在该模块不能再次使用。 不管在import语句中把一个模块写了多少次，该模块只执行一次，导入模块的代码执行后，实例化过的模块被保存在内存中，只要另一个import语句引用它就可以重复使用它。 模块语法的限制 export和import的一个重要的限制是，它们必须在其他语句和函数之外使用，所以 必须在顶部使用export和import。 导入的绑定标识符是只读的，标识符只有在被导出的模块中可以修改，导入绑定的模块无法改变绑定值。 导出和导入时的重命名 可以用as关键字来改变导出时元素的名称 1234function sum (num1,num2) &#123; return num1 + num2;&#125;export &#123;sum as add&#125;; 导入时改变名称 1import &#123;add as sum&#125; from &apos;./example.js&apos;; 模块的默认值 模块的默认值是指通过default关键字指定的单个变量，函数或类，只能为模块设置一个默认的导出值 导出默认值 123export default function(num1,num2) &#123; return num1 + num2;&#125; 导入默认值 1import sum from &apos;./example.js&apos; //导入默认值是不使用大括号 导出默认值和非默认值:用逗号将默认的本地名称与大括号包裹的非默认值分割开，在import语句中，默认值必须排在非默认值前。 12345678export let color = &apos;red&apos;;export default function(num1,num2) &#123; return num1 + num2;&#125;// 导入import sum, &#123; color &#125; from &apos;./example.js&apos; 浏览器模块说明符解析 以/开头的解析从根目录开始。 以./开头的解析从当前目录开始。 以../开头的解析从父目录开始。]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际化——Vue-i18n的使用]]></title>
    <url>%2F2017%2F08%2F12%2F%E5%9B%BD%E9%99%85%E5%8C%96%E2%80%94%E2%80%94Vue-i18n%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Vue-i18n安装 npm install vue-i18n --save Vue-i18n的使用 在入口main.js文件配置使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from &apos;vue&apos;import VueI18n from &apos;vue-i18n&apos;Vue.use(VueI18n);/*---------基本使用-----------*/const i18n = new VueI18n(&#123; locale: &apos;CN&apos;, // 语言标识 messages : &#123; en: &#123; message: &#123; hello: &apos;hello world&apos; &#125; &#125;, cn: &#123; message: &#123; hello: &apos;你好、世界&apos; &#125; &#125; &#125;&#125;)/*---------使用语言包-----------*/const i18n = new VueI18n(&#123; locale: &apos;CN&apos;, // 语言标识 messages: &#123; &apos;CN&apos;: require(&apos;./assets/common/lang/cn&apos;), // 中文语言包 &apos;EN&apos;: require(&apos;./assets/common/lang/en&apos;) // 英文语言包 &#125;,&#125;)/*---------语言包内部语法star-----------*/export const message = &#123; language:&apos;语言&apos;, hello: &apos;你好,世界&apos;&#125;/*---------语言包内部语法end-----------*//*---------挂载全局使用-----------*/new Vue(&#123; el: &apos;#app&apos;, i18n, router, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;)/*---------vue组件模板的使用-----------*/ &lt;template&gt; &lt;p&gt;&#123;&#123; $t(&quot;message.hello&quot;) &#125;&#125;&lt;/p&gt; &lt;/template&gt; 单独组件的使用 在单个vue组件中使用，要用到i18n自定义块，需要配置webpack文件webpack.base.conf.js 12345678910111213141516171819module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; // you need to specify `i18n` loaders key with `vue-i18n-loader` (https://github.com/kazupon/vue-i18n-loader) i18n: &apos;@kazupon/vue-i18n-loader&apos; &#125; &#125; &#125;, // ... ] &#125;, // ...&#125; 示例 123456789101112131415161718192021222324252627282930313233&lt;i18n&gt;&#123; &quot;en&quot;: &#123; &quot;hello&quot;: &quot;hello world!&quot; &#125;, &quot;ja&quot;: &#123; &quot;hello&quot;: &quot;你好,世界！&quot; &#125;&#125;&lt;/i18n&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;label for=&quot;locale&quot;&gt;locale&lt;/label&gt; &lt;select v-model=&quot;locale&quot;&gt; &lt;option&gt;en&lt;/option&gt; &lt;option&gt;ja&lt;/option&gt; &lt;/select&gt; &lt;p&gt;message: &#123;&#123; $t(&apos;hello&apos;) &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; locale: &apos;en&apos; &#125; &#125;, watch: &#123; locale (val) &#123; this.$i18n.locale = val &#125; &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-i18</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6六]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Symbol ES6新增的数据类型Symbol 创建Symbol：通过去全局的Symbol函数创建一个Symbol，Symbol函数接受一个可选参数，用于添加一段文本描述即将创建的Symbol,方便阅读和调试Symbol程序 12345678let firstName = Symbol(&apos;first name&apos;); let person = &#123;&#125;; person[firstName] = &apos;Nicholas&apos;; console.log(&apos;first name&apos; in person); //false console.log(person[firstName]); //&apos;Nicholas&apos; console.log(firstName); //&apos;Symbol(first name)&apos; ES6扩展了typeof操作符，支持返回Symbol,可以用typeof来检测变量是否为Symbol类型. Symbol共享体系 ES6提供了一个可以随时访问的全局Symbol注册表,如果要创建一个可共享的Symbol,要使用Symbol.for()方法，该方法只接受一个参数，就是即将创建的Symbol的字符串标识符 1234567let uid = Symbol.for(&apos;uid&apos;);let object = &#123;&#125;;object[uid]=&apos;12345&apos;;console.log(ojbect[uid]);console.log(uid); Symbol.for()方法首先在全局Symbol注册表中搜索键为’uid’的Symbol是否存在，如果存在，直接返回已有的Symbol；否则创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol 可以使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键12345let uid = Symbol.for(&apos;uid&apos;);console.log(Symbol.keyFor(uid)); //&apos;uid&apos;let uid3 = Symbol(&apos;uid&apos;);console.log(Symbol.keyFor(uid3)) //undefined Symbol属性检索 ES6中新增Object.getOwnPropertySymbols()方法来检索对象中的Symbol属性，返回值是一个包含所有Symbol自由属性的数组123456789let uid = Symbol.for(&apos;uid&apos;);let object = &#123; [uid]: &apos;12345&apos;&#125;;let symbols = object.getOwnPropertySymbols(object);console.log(symbols.length); //1console.log(symbols[0]); //&apos;Symbol(uid)&apos;console.log(object[symbols[0]]) //&apos;12345&apos;]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6五]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%BA%94%2F</url>
    <content type="text"><![CDATA[对象解构 对象解构的语法：在赋值操作符(=)左边放置一个对象字面量 1234567let node = &#123; type:&apos;Indet&apos;, name:&apos;noo&apos;&#125;let &#123; type, name&#125; = node;console.log(type);console.log(name); 对象的解构赋值：由于代码块语句不允许出现在赋值语句左侧，所以必须添加小括号将其转换为一个表达式。 12345678910let node = &#123; type:&apos;Indet&apos;, name:&apos;noo&apos;&#125;, type = &apos;Literal&apos;, name = &apos;sss&apos;; (&#123; type, name &#125; = node); console.log(type); //&apos;Indet&apos; console.log(name); //&apos;noo&apos; 函数中也可以传入解构表达式 123456789101112131415let node = &#123; type:&apos;Indet&apos;, name:&apos;noo&apos;&#125;, type = &apos;Literal&apos;, name = &apos;sss&apos;; function outPut(value) &#123; console.log(value === node); &#125; outPut(&#123; type, name &#125; = node); console.log(type); //&apos;Indet&apos; console.log(name); //&apos;noo&apos; 解构赋值表达式可以设置默认值：在属性名称后面添加一个等号和相应的默认值即可。 123456789let node = &#123; type:&apos;Indet&apos;, name:&apos;noo&apos;&#125;;let &#123; type, name, value = true&#125; = node;console.log(type); //&apos;Indet&apos;console.log(name); //&apos;noo&apos;console.log(value); //true 为非同名局部变量赋值 123456789let node = &#123; type:&apos;Indet&apos;, name:&apos;noo&apos;&#125;;// type:localType语法的含义是读取名为type的属性并将其值存储在变量localType中let &#123; type:localType, name:localName&#125; = node;console.log(localType); //&apos;Indet&apos;console.log(localName); //&apos;noo&apos; 嵌套对象解构 123456789101112131415161718let node = &#123; type:&apos;Identifier&apos;, name:&apos;noo&apos;, loc: &#123; start: &#123; line: 1, column:1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125;&#125;let &#123; loc: &#123;start &#125;&#125; = node;console.log(start.line); //1console.log(start.column); //1 数组解构 数组解构语法：使用数组字面量，解构操作全部在数组内完成 1234let colors = [&apos;red&apos;, &apos;grren&apos;, &apos;blue&apos;];let [first, second] = colors;console.log(first); //&apos;red&apos;console.log(second); //&apos;grren&apos; 数组解构赋值 1234567let colors = [&apos;red&apos;, &apos;grren&apos;, &apos;blue&apos;], first = &apos;111&apos;, second = &apos;222&apos;;[first,second] = colors;console.log(first);console.log(second);]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>解构</tag>
        <tag>解构赋值</tag>
        <tag>对象解构</tag>
        <tag>数组解构</tag>
        <tag>不定元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6四]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[ES6规范清晰的定义了对象的类别 普通对象 具有JavaScript对象所有的默认内部行为 特异对象 具有某些与默认行为不符的内部行为 标准对象 ES6中规范定义的对象 内建对象 脚本开始执行时存在于JavaScript执行环境中的对象，所有标准对象都是内建对象 对象字面量语法的扩展 属性初始化简写语法：当一个对象的属性与本地变量同名时，不必要再写冒号和值，简单地只写属性名即可。当对象字面量里只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找其同名变量，如果找到，则该变量的值被复赋值给对象字面量里的同名属性 123456function Person(name,age) &#123; reutrn &#123; name, age &#125;&#125; 对象方法的简写语法：消除了冒号和关键字function,与传统对象方法的区别是简写方法可以使用super关键字 123456let person = &#123; name:&apos;tgb&apos;, sayName() &#123; console.log(this.name); &#125;&#125; 可计算属性名：在ES6中可以在对象字面量中使用可计算属性名称，对象字面中使用方括号表示该属性名称时可计算的 1234567let suffix = &apos;name&apos;let person = &#123; [&apos;first&apos;+suffix]: &apos;Nicholas&apos;, [&apos;last&apos;+suffix]:&apos;Zakas&apos;&#125;console.log(person[&apos;first name&apos;]);console.log(person[&apos;last name&apos;]); ES6新增方法 Object.is()方法：这个方法接受两个参数，如果两个参数的类型相同且具有相同的值，则返回true。用来弥补全等运算符的不准确运算。 12345console.log(+0 === -0) //true;console.log(Object.is(+0,-0)); //falseconsole.log(NaN === Nan); //falseconsole.log(Object.is(NaN,NaN)) //true Object.assign()方法：混入方法，这个方法接受一个对象和任意数量的源对象，最终返回接受对象 123456789101112let obj = &#123;&#125;;Object.assign(obj, &#123; type:&apos;js&apos;; name:&apos;file.js&apos; &#125;, &#123; type:&apos;css //如果多个源对象具有同名的属性则排位靠后的源对象会覆盖排位靠前的 &#125;)console.log(obj.type); //&apos;css&apos;console.log(obj.name); //&apos;file.js&apos; 增强对象原型 ES6新增Object.setPrototypeOf()方法：这个方法可以改变任意指定对象的原型，它接受两个参数；被改变的对象原型的对象以及要替代第一个参数原型的对象 123456789101112131415let person = &#123; getGreeting() &#123; return &apos;Hello&apos;; &#125;&#125;;let dog = &#123; getGreeting() &#123; return &apos;Woof&apos; &#125;&#125;let friend = Object.create(person);console.log(Object.getPrototypeOf(firend)===person); //trueObject.setPrototypeOf(friend,dog);console.log(Object.getPrototypeOf(friend)===dog); //true 简化原型访问的Super引用 Super引用相当于指向对象原型的指针，就是Object.getPrototypeOf(this)的值]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>对象</tag>
        <tag>对象字面量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程语言分类]]></title>
    <url>%2F2017%2F08%2F06%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、看图区分语言类型 二、语法角度的文字表述1. 动态类型语言 运行期间才做数据类型检查的语言，即动态类型语言编程时，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。 优点：方便阅读，不需要写非常多的类型相关的代码； 缺点：不方便调试，命名不规范时会造成读不懂，不利于理解等2. 静态类型语言 编译期间做检查数据类型的语言，即写程序时要声明所有变量的数据类型，是固定的。使用数据之前，必须先声明数据类型（int ,float,double等）。相当于使用之前，首先要为它们分配好内存空间。 优点：结构非常规范，便于调试，方便类型安全 缺点：为此需要写更多类型相关代码，不便于阅读、不清晰明了3. 强类型定义语言（Explicit type conversion，强制数据类型定义语言，类型安全的语言）： 一旦变量被指定某个数据类型，如果不经强制转换，即永远是此数据类型。 举例：若定义了一个整型变量a，若不进行显示转换，不能将a当作字符串类型处理 强类型语言是指需要进行变量/对象类型声明的语言，一般情况下需要编译执行。例如C/C++/Java/C#4. 弱类型定义语言（Implicit type conversion，类型不安全的语言）： 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 三、结论 javaScript是动态语言，是弱类型定义语言（类型不安全的语言）;]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>语言类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6三]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B8%89%2F</url>
    <content type="text"><![CDATA[参数 ES6简化了为形式参数提供默认值的过程 123function makeRequest(rul,timeout = 2000,callback) &#123; //函数其余部分&#125; 上面的函数只有当不为第二个参数传入值或者主动为第二个参数传入undefined时才会使用timeout的默认值 在ES6中一个函数使用了默认参数值，会使得arguments对象保持与命名参数的分离，无论参数如何变化，arguments对象不再随之改变。 123456function mix(first,second=&apos;b&apos;) &#123; console.log(arguments.length); // 1 之传入了一个参数 console.log(first === arguments[0]) // true console.log(second === aruments[1]) // false //arguments[1]是undefined&#125;mix(&apos;a&apos;); 默认参数表达式 ES6中可以使用先定义的参数作为后定义参数的默认值，但是后定义的参数不能作为先定义参数的默认值。 默认参数也存在临时死区，定义参数时会为每个参数创建一个新的标识符绑定，该绑定在初始化之前不可被引用，如果访问会导致程序错误 不定参数 在函数的命名参数钱添加三个点(…)就表明这是一个不定参数，该参数为一个数组，包含着自它之后出入的所有参数，通过这个数组名即可逐一访问里面的参数。 不定参数的使用限制：1.每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾。2.不定参数不能用于对象字面量setter中 arguments对象包含不定参数，无论是否使用不定参数，argumetns对象总是包含所有传入函数的参数 展开运算符- 展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数 - 展开运算符的使用：例如`Math.max()`方法可以接受任意数量的参数并返回值最大的一个，但是该方法不允许传入数组。 123456// ES5使用let values = [25,50,75,100];console.log(Math.max.apply(Math,values)); //100// Es6使用console.log(Math.max(...values)); //100 判断函数被调用的方法 在ES5中判断一个函数是否通过new关键字被调用(或者说，判断该函数是否作为构造函数被调用)，最常使用的是instanceof instanceof语法：Object instanceof constructor; instanceof运算符用来检测constructor.prototype是否存在于参数Object的原型链上 ES6引入了new.target这个元属性，元属性市值非对象的属性，其可以提供非对象目标的补充信息，当调用函数的[construct]方法时，new.target被赋值new操作符的目标，通常是新创建的对象实例。如果用[[call]]方法，则new.target的值为undefined。 块级函数 ES6中允许在代码块中声明函数 12345if(true) &#123; function doSomething() &#123; &#125;&#125; 块级函数的声明提升 函数声明的块级函数会被提升至块的顶部而用let定义的函数表达式不会被提升 ES6严格模式下块级函数只会提升至块的顶部，但是在非严格模式下函数会被提升至外围函数或全局作用域的顶部。 箭头函数 箭头函数是一种使用箭头(=&gt;)定义函数的新语法 与传统函数的不同： 没有this、super、arguments和new.target绑定 这些值由外围一层非箭头函数决定 不能通过new关键字调用 箭头函数没有[[constructor]]方法，如果通过new关键字调用箭头函数，程序会抛出错误。 没有原型 不存在prototype这个属性 不可以改变this的绑定 在函数的生命周期内始终保持一致 不支持arguments对象 不支持重复命名的参数 箭头函数的语法 当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧额表达式被求值后便立即返回 1let reflect = value =&gt; value; 如果要传入两个或两个以上的参数，要在参数的两侧添加一对小括号 1let sum = (num1,num2) =&gt; num1+num2; 如果函数没有参数，也要在声明的时候写一组没有内容的小括号 1let getName = () =&gt; &apos;Tgb&apos;; 可以有函数体 123let sum = (num1,num2) =&gt; &#123; return num1+num2;&#125; 箭头函数返回对象字面量 1let getTempItem = id =&gt; (&#123; id: id,name: &apos;temp&apos; &#125;); 箭头函数的自调用 沙箱模式 1234567let person = ((name) =&gt; &#123; return &#123; getName: function() &#123; retrun name; &#125; &#125;;&#125;)(&apos;tgb&apos;);]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>函数</tag>
        <tag>不定参数</tag>
        <tag>展开运算符</tag>
        <tag>块级函数</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6二]]></title>
    <url>%2F2017%2F07%2F26%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[模板字面量的主要功能 多行字符串：一个正式的多行字符串的概念 基本的字符串格式化：将变量的值嵌入字符串的能力 HTML转义 向HTML插入经过安全转换后的字符串的能力 基础语法1let message = `Hello world`; 模板字面量可以使用反斜杠(/),在模板字面量中不需要转义单,双引号 模板字面量可以很简洁的使用多行字符串 12let message = `Helloworld` 在模板字面量中，可以把任何合法的javascript表达式嵌入到占位符中并将其作为字符串的一部分输出到结果中。占位符有一个左侧的${和右侧的}符号组成，中间可以包含任意的javascript表达式 12let name = &apos;Nicholas&apos;, message = `Hello $&#123;name&#125;` #注意事项 模板字面量可以访问作用域中所有可访问的变量，而嵌入未定义的变量会抛出错误 可以在模板字面量中嵌入另外一个 1234let name = &apos;Nicholas&apos;, message = &apos;Hello, $&#123; `my name is $&#123;name&#125;` &#125;.`; 标签模板 标签模板是在模板字面量第一个反撇号(`)前方标注的字符串 1let message = tag`Hello world` 标签是一个函数，第一个参数是一个数组，包含JavaScript解释过后的字面量字符串，它之后的所有参数都是每一个站位符的解释值 12345678910111213function tag(literals,...substitutions) &#123;&#125; let a = 5,b = 10; let tag = (s,v1,v2)=&gt;&#123; console.log(s); console.log(v1); console.log(v2); &#125; tag`Hello $&#123;a+b&#125; world $&#123;a*b&#125;`; //[&apos;Hello &apos;,&apos; world &apos;,&apos;&apos;] //15 //50 通过String.raw()标签可以访问到字符转义被转换成等价字符前的原声字符串 12345let message1 = `Multiline\nstring`;let message2 = String.raw`Multiline\nstring`;console.log(message1); //&apos;Multiline //string&apos;console.log(message2); //&apos;Multiline\nstring&apos;]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模板字面量</tag>
        <tag>标签模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础标签的掌握]]></title>
    <url>%2F2017%2F07%2F20%2FHTML5%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE%E7%9A%84%E6%8E%8C%E6%8F%A1%2F</url>
    <content type="text"><![CDATA[标签 &lt;abbr&gt; 标签表示简称或缩写，比如 “WWW” 或 “NATO” &lt;abbr&gt; 标签中使用全局的 title 属性，这样就能够在鼠标指针移动到 元素上时显示出简称/缩写的完整版本。1The &lt;abbr title=&quot;People&apos;s Republic of China&quot;&gt;PRC&lt;/abbr&gt; was founded in 1949.]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6一]]></title>
    <url>%2F2017%2F07%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E4%B8%80%2F</url>
    <content type="text"><![CDATA[let声明 Es6中引入块级声明，let声明的变量作用域限制在代码块中； let声明不会被提升; 在同一作用域中不能用let重复定义已经存在的标识符，会抛出错误。 const声明 const声明的变量作用域也会限制在代码块中； const声明的是常量，其值一旦被设定后不可更改，每个通过const声明的常量必须进行初始化(赋值) const声明不允许修改绑定，但允许修改值；例如const声明对象，对象的值是可以修改的 临时死区的存在 临时死区(temporal dead zone)TDZ用来描述let和const的不提升效果； 与var声明不同，let和const声明的变量不会被提升到作用域的顶部，在javascript引擎扫描代码的时候会将let和const的声明放到临时死区中 循环中的块级作用域 常见的循环错误；var声明是全局变量123456789var funcs = [];for(var i=0;i&lt;10;i++) &#123; funcs.push(function() &#123; console.log(i); &#125;)&#125;funcs.forEach(funcion(func) &#123; func(); //输出10次10 &#125;) 使用闭包解决这个问题 12345678910111213var funcs = [];for(var i=0;i&lt;10;i++) &#123; funcs.push((function(value)&#123; // 变量i的值在传递到这个作用域是被赋值给了value; // 此时这个值就不会随外部变量而变化了； return function() &#123; console.log(value); &#125; &#125;)(i));&#125;funcs.forEach(function(func) &#123; func(); //输出0，然后是1,2直到9&#125;) 使用let声明简化 123456789var funcs=[];for(let i=0;i&lt;10;i++) &#123; funcs.push(function() &#123; console.log(i); &#125;)&#125;funcs.forEach(function(func) &#123; func(); //输出0，然后是1,2直到9&#125;) 全局作用域的绑定 当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象(浏览器环境中的window对象)的属性 当在全局作用域中使用let和const,会在全局作用域下创建一个新的绑定，但是该绑定不会添加为全局对象的属性。]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>块级作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2017%2F07%2F18%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存的定义 Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。 缓存的命中和未命中 304 的标准解释： Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 HTTP在验证]]></content>
      <categories>
        <category>浏览器基础</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的学习三]]></title>
    <url>%2F2017%2F07%2F17%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中遇到的问题——对象的拷贝]]></title>
    <url>%2F2017%2F07%2F13%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[遇到的问题 将对象赋值给一个变量时，当我改变变量的值，发现原来的对象也跟着改变。发现原因： 因为对象是应用类型，存放在堆内存中；当我们用变量保存一个对象时，实际上保存的是该对象指针，这个指针指向对象的位置，所以当我们改变变量的时候，会从指针找到对象的位置，从而改变了对象。解决方法：将对象拷贝再赋值给变量 浅拷贝 简单的引用复制 1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true ES6新方法Object.assign()1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 深度拷贝 Array的slice和concat方法 1234567 var array = [1,2,3];var array_shallow = array;var array_concat = array.concat();var array_slice = array.slice(0);console.log(array === array_shallow); //trueconsole.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 123456789 var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;];var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值console.log(array[1]); //[5,2,3]console.log(array_slice[1]); //[5,2,3]array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice JSON对象的parse和stringify 123456789101112131415161718 //例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125;var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //sourceconsole.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的childconsole.log(source.child.name); //childconsole.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; 完整的拷贝方法12345678910111213141516171819202122232425262728293031323334353637var $ = (function()&#123; var types = &apos;Array Object String Date RegExp Function Boolean Number Null Undefined&apos;.split(&apos; &apos;); function type() &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125; for (var i = types.length; i--;) &#123; $[&apos;is&apos; + types[i]] = (function (self) &#123; return function (elem) &#123; return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return $;&#125;)();//类型判断 function copy(obj,deep)&#123; if(obj === null || (!$.isObject(obj) &amp;&amp; !$.isFunction(obj)))&#123; return obj; &#125; if($.isFunction(obj))&#123; return new Function(&quot;return &quot; + obj.toString())(); &#125;else&#123; var name, target = $.isArray(obj) ? [] : &#123;&#125;, value; for(name in obj)&#123; value = obj[name]; if(value === obj) &#123; continue; &#125; if(deep &amp;&amp; ($.isArray(value) || $.isObject(value)))&#123; target[name] = copy(value,deep); &#125;else&#123; target[name] = value; &#125; &#125; return target; &#125; &#125;]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome开发工具指南]]></title>
    <url>%2F2017%2F07%2F12%2FChrome%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[谷歌浏览器开发工具综述 使用开发工具 选择浏览器位于浏览器窗口右上方的菜单栏的工具目录chrome-menu，选择开发者工具选项 右击页面任何位置并选择审查元素 使用快捷键f12 开发者工具窗口 开发者工具窗口的顶部工具栏中排列着任务相关的组。每个工具栏项目和相应的面板让你能够使用网页或应用程序的特定信息来工作，包括 DOM 元素，资源，和源。 总体而言，有八个主要的工具可供查看开发工具 元素面板(Element):许我们从浏览器的角度看页面，也就是说我们可以看到chrome渲染页面所需要的的HTML、CSS和DOM(Document Object Model)对象。此外，还可以编辑这些内容更改页面显示效果； 控制台面板(Console):显示各种警告与错误信息，并且提供了shell用来和文档、开发者工具交互； 源代码面板(sources):主要用来调试js； 网络面板(Network):可以看到页面向服务器请求了哪些资源、资源的大小以及加载资源花费的时间，当然也能看到哪些资源不能成功加载。此外，还可以查看HTTP的请求头，返回内容等； 性能面板(Performance): 内存面板(Memory) 应用面板(Application)(Audits):分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案； 安全面板(Security) 可以使用 Ctrl + [ 和 Ctrl + ] 快捷键在面板之间移动 元素面板(Element)详解 检查和调整页面 实时编辑 DOM 节点：只需双击选定元素，然后进行更改 实时编辑样式： 在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。 要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。 默认情况下，您的 CSS 修改不是永久的，重新加载页面时更改会丢失。 如果您想要在页面加载时保留更改，请设置永久制作 检查和编辑框模型参数： 使用 Computed 窗格检查和编辑当前元素的框模型参数。 框模型中的所有值均可修改，只需点击它们即可 编辑样式 检查应用到元素的样式 顶端为 element.style。这些样式要么直接使用样式属性（例如 ）直接应用到元素，要么在 DevTools 中应用 下方是与元素匹配的任何 CSS 规则。例如，在下面的屏幕截图中，选定元素从 tools.css 中定义的规则接收 line-height:24px 再下方是继承的样式，其中包括与选定元素的祖先实体匹配的任何可继承样式规则。 例如，在下面的屏幕截图中，选定元素从 user agent stylesheet 继承 display:list-item 编辑DOM 元素面板右侧的辅助功能 Styles: 显示用户定义的样式，比如请求的default.css中的样式，和通过Javasript生成的样式，还有开发者工具添加的样式； Computed: 显示开发者工具计算好的元素样式； Event Listeners: 显示当前HTML DOM节点和其祖先节点的所有JavaScript事件监听器，这里的监听脚本可以来自Chrome的插件。可以点击右边小漏斗形状(filter)选择只显示当前节点的事件监听器； DOM Breakpoints: 列出所有的DOM 断点； Properties: 超级全面地列出当前选中内容的属性，不过基本很少用到。 网络面板(Network)详解 点击单个请求展开详细界面 Headers:头信息 - Preview:资源预览 Response:未处理的响应正文 Cookies:请求和返回中所传输的cookies Timing:图形化显示资源加载的时间 Stalled:等待时间，浏览器要发出的请求到这个请求可以发出的这一段时间， Request sent:请求时间，请求的第一个字节发出以前到最后一个自求发出以后时间； Waiting(TFFB):请求发出以后，到收到响应的第一个字节所发费的时间，响应时间； Content Download:收到响应的第一个字节开始到接受完最后一个字节所发费的时间，下载时间]]></content>
      <categories>
        <category>浏览器基础</category>
      </categories>
      <tags>
        <tag>chrome开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的学习二]]></title>
    <url>%2F2017%2F07%2F12%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[URL和资源 URL的基本组成部分 URL的第一部分(http)是URL方案,方案可以告知Web客服端怎样访问资源 URL的第二部分指的是主机(服务器的位置)，这不分告知Web客服端资源位于何处。 URL的第三部分是资源路径，路径说明了请求的是服务器上那个特定的本地资源。 通用URL组件 URL由两种方式：绝对的和相对的 相对URL是不完整的，需要对基础的URL进行解析 相对URL解析为绝对URL的算法 HTTP报文详解 报文的流动性 报文在客服端，服务器和代理之间的流动称为报文流 HTTP使用术语流入(inbound)和流出(outbound)来描述事务处理(transaction)的方向 不管是请求报文还是响应报文，所有的报文都会想下游流动。所有的报文发送者都在接受者的上游 报文的组成部分 报文主要有三个部分组成；①对报文进行描述的起始行，②包含属性的首部块，③包含数据的主体部分。 报文的格式 请求报文格式： 123&lt;method&gt;(方法) &lt;request-URL&gt;(请求URL) &lt;version&gt;(版本)&lt;headers&gt;(首部)&lt;entity-body&gt;(主体部分) 响应报文格式： 123&lt;method&gt;(方法) &lt;status-code&gt;(状态码) &lt;reason-phrase&gt;(原因短语)&lt;headers&gt;(首部)&lt;entity-body&gt;(主体部分) 报文各部分的简要描述 方法(method):客服端希望服务器对资源执行的动作.比如GET,HEAD或者POST 请求URL(request-URL):命名了所请求的资源，或者URL路径组件的完整URL 版本(version):报文所使用的HTTP版本，其格式看起来是这样的HTTP/&lt;major&gt;.&lt;minor&gt;其中主要版本号(major)和次要版本号(minor)都是整数。 状态码(status-code):这三位数字描述了请求过程中所发生的情况。 原因短语(reason-phrase):数字转台码的可读版本，包含终止序列之前的所有文本。 首部(header):可以有零个或者多个首部，每个首部都包含一个名字，后面跟着一个冒号(:),然后是一个可选的空格，接着是一个值，最后是一个CRLF。例如：content-type:text/plain; 主体部分(entity-body):实体的主体部分包含一个有任意数据组成的数据块，并不是所有的报文都包含主体部分。 HTTP常见的请求方法 状态码的基本分类 首部 通用首部：提供报文最基本的信息，客服端和服务器都可以使用 通用的信息性首部 通用缓存首部 请求首部：只在请求报文中有意义，用于说明是谁或什么在发送请求，请求源自何处，或者客服端的喜好及能力。 响应首部 实体首部 扩展首部 状态码详解 400-499客服端错误代码]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的学习一]]></title>
    <url>%2F2017%2F07%2F11%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[初识HTTP协议 HTTP协议是一种数据传输协议，客服端通过HTTP请求向服务器获取资源，服务器通过HTTP响应提供资源给客服端。 媒体类型(MIME类型) HTTP给每种要通过 Web 传输的对象都打上了名为 MIME 类型（MIME type）的数据格式标签 MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔 HTML 格式的文本文档由 text/html 类型来标记 JPEG 版本的图片为 image/jpeg 类型 URI 每个 Web 服务器资源都有一个名字，服务器资源名被称为统一资源标识符，URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源 URI和URL的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。 URI 有两种形式，分别称为 URL 和 URN URL URL：统一资源定位符（URL）是资源标识符最常见的形式。URL 描述了一台特定服务器上某资源的特定位置。 大部分 URL 都遵循一种标准格式，这种格式包含三个部分 URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（http://）。 第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com）。 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif） URN URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。 报文 从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文（response message）。 HTTP 报文包括以下三个部分 起始行 报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况 首部字段 起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单 主体 空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本 事务 一个HTTP事务由一条(从客服端发往服务器的)请求命令来和一个(从服务器发回客服端的)响应结果组成。 方法 HTTP支持几种不同的请求命令，这些命令被称为HTTP方法,这写方法回告诉服务器要执行什么动作。一般有五种常见的HTTP方法。 GET：从服务器向客服端发送命名资源 PUT: 将来自客服端的数据存储到一个命名的服务器的资源中去 DELETE：从服务器中删除命名资源 POST：将客服端数据发送到个服务器网关应用程序 HEAD：仅发送命名资源响应中的HTTP首部 状态码 每条 HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作。 链接 HTTP 网络协议栈 12345HTTP 应用层TCP 传输层IP 网络层网络特有的链路接口 数据链路层物理网络硬件 物理层 在 HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。 (a)浏览器从 URL 中解析出服务器的主机名； (b)浏览器将服务器的主机名转换成服务器的 IP 地址； (c)浏览器将端口号（如果有的话）从 URL 中解析出来； (d)浏览器建立一条与 Web 服务器的 TCP 连接； (e)浏览器向服务器发送一条 HTTP 请求报文； (f)服务器向浏览器回送一条 HTTP 响应报文； (g)关闭连接，浏览器显示文档。 Web的结构组件 代理: 位于客户端和服务器之间的 HTTP 中间实体。 代理位于客户端和服务器之间，接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。 缓存: HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。 Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了 网关: 连接其他应用程序的特殊 Web 服务器。 网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。 隧道: 对 HTTP 通信报文进行盲转发的特殊代理 隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。 Agent 代理: 发起自动 HTTP 请求的半智能 Web 客户端。 用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm的快速使用]]></title>
    <url>%2F2017%2F07%2F06%2Fnpm%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本命令 npm初始化一个包 npm init创建一个新包 需要填写信息 npm init -y快速初始化 安装安装包 常规: npm install pkg, 速记: npm i pkg. 全局安装包: 常规: npm i --global pkg, 速记: npm i -g pkg. 安装包并包含在依赖中: 常规: npm i --save pkg, 速记: npm i -S pkg. 安装包并包含在开发依赖中: 常规: npm i --save-dev pkg, 速记: npm i -D pkg. 有意义的指令 进入安装包的官网 npm repo vue npm home vue 运行测试指令 npm test, 速记：npm t 枚举可用的脚本 当我们开始一个新项目，我们想知道如何开始。我们通常会问自己这样的问题：我们如何运行它？哪些脚本可用 打开package.json文件并检查scripts部分 我们只要运行npm run得到一个的所有可用的脚本的列表 枚举已经安装的包 当查看项目中的哪些依赖项，可以打开package.json文件和检查 枚举项目安装包 使用 npm ls --depth 0 枚举全局安装包 使用 npm ls -g --depth 0 npm更新 npm i -g npm]]></content>
      <categories>
        <category>前端构建生态</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel的使用总结]]></title>
    <url>%2F2017%2F07%2F01%2FBabel%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[babel-polfill插件 由于Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码，所以在IE浏览器下会出现缺少Promise对象的问题 为了完整使用 ES6 的 API ，我们只能安装这个插件npm install babel-polyfill --save-dev node.js 中require(&#39;babel-polyfill&#39;) webpack.config.js中 123module.exports = &#123; entry: [&apos;babel-polyfill&apos;, &apos;./app/js&apos;]&#125; vue-cli配置的环境下,在main.js中引入：import &#39;babel-polyfill&#39; 本地安装和全局安装全局安装：npm install --global babel-cli 这时候我们可以使用 Babel 命令编译文件： 123babel index.js --out-file compiled.js#或babel index.js -o compiled.js 编译目录： 123babel src -out-dir lib#或babel src -d lib 本地安装，记在项目的根目录下： npm install --save-dev babel-cli 但是在本地就不能用 babel 命令了，我们可以在 package.json 文件中添加点东西： 12345&#123; &quot;script&quot;: &#123; &quot;build&quot;: &quot;babel src -d lib&quot; &#125;&#125; 然后，运行 npm run build 即可把 src 目录编译输出到 lib]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习三]]></title>
    <url>%2F2017%2F06%2F27%2FVue-js%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[钩子函数的理解 文档翻译造成的问题，原名是“hook”（不负责任的直译为“钩子”而已），它是一种事件劫持机制，也就是说它会比你的事件更早进行执行处理。 可以简单地把它理解为vue的内置事件，但是这个内置事件是由你去配置的。 vue的生命周期详解vue生命周期图示 生命周期总共分为八个阶段 beforeCreate（组件实例创建前） el和data并未初始化 实例创建前：这个阶段实例的data、methods是读不到的 created（组件实例创建后）, 完成了 data 数据的初始化，el没有 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染 beforeMount(模板编译/挂载之前), 完成了 el 和 data 初始化 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted（模板编译/挂载之后） 完成挂载 el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染 beforeUpdate（组件更新之前） data的值改变后，组件更新，触发update的操作 数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理 updated（组件更新之后） data的值改变后，组件更新，触发update的操作 这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行 beforeDestroy（组件销毁前） 实例销毁之前调用。 destroyed（组件销毁后） 销毁完成后，我们再重新改变data中的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。 Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。钩子函数的使用 beforecreate : 可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 created：进行ajax请求异步数据的获取、初始化数据 mounted：挂载元素内dom节点的获取 nextTick：针对单一事件更新数据后立即操作dom updated：任何数据的更新，如果要做统一的业务逻辑处理 watch：监听具体数据变化，并做相应的处理 render(渲染)函数的使用(解决重复html) template模板中有重复HTMl的时候可以用render函数编译 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;mycomment :level=&quot;2&quot;&gt; 这是h2元素 &lt;/mycomment&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/x-template&quot; id=&quot;is&quot;&gt; &lt;div&gt; &lt;h1 v-if=&quot;level === 1&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-if=&quot;level === 2&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-if=&quot;level === 3&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-if=&quot;level === 4&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-if=&quot;level === 5&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-if=&quot;level === 6&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt; &lt;/div&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&apos;mycomment&apos;,&#123; template:&apos;#is&apos;, props:&#123; level:&#123; type:Number, required:true, &#125; &#125; &#125;) var app =new Vue(&#123; el:&apos;#app&apos;, &#125;) &lt;/script&gt; 用Render函数解决代码冗长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;render-teample :level=&quot;4&quot; &gt; &lt;div class=&quot;jah&quot; slot=&quot;myslot&quot;&gt;render function&lt;/div&gt; &lt;/render-teample&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.component(&apos;render-teample&apos;,&#123; render:function(createElement)&#123; return createElement( &apos;h&apos;+this.level, &#123; &apos;class&apos;:&#123; show:true, hide:false, &#125;, style:&#123; width:&apos;200px&apos;, height:&apos;400px&apos;, background:&apos;red&apos;, &#125;, attrs:&#123; name:&apos;h-ex&apos;, id:&apos;h-id&apos; &#125;, props:&#123; myprops:true, &#125;, on: &#123; click: function(event)&#123; alert(this.num) &#125; &#125;, nativeOn:&#123; click:function(event) &#123; alert(1111) &#125; &#125; &#125;, [ this.$slots.myslot, createElement(&apos;div&apos;,&#123; domProps:&#123; innerHTML:&apos;holle render&apos; &#125; &#125;) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;); var app=new Vue(&#123; el:&quot;#app&quot;, data:&#123; num:110 &#125; &#125;); &lt;/script&gt; vue自定义指令 当项目中需要对纯 DOM 元素进行底层操作,就要用到自定义指令vue自定义指令的注册 注册全局自定义指令 12345Vue.directive(&apos;focus&apos;, &#123; inserted: function (el) &#123; el.focus() &#125;&#125;) 注册局部自定义指令 1234567directives: &#123; focus: &#123; inserted:function (el) &#123; el.focus() &#125; &#125;&#125; ###自定义指令函数提供的钩子函数 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下） componentUpdated: 被绑定元素所在模板完成一次更新周期时调用 unbind: 只调用一次， 指令与元素解绑时调用###钩子函数的参数 el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习二]]></title>
    <url>%2F2017%2F06%2F23%2FVue-js%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Class与Style绑定绑定HTML Class 对象语法： 给v-bind:class一个对象，以动态切换class,语法表示classactive的更新将取决于数据属性 isActive 是否为真值 1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 在对象中传入更多属性用来动态切换多个 class ,v-bind:class 指令可以与普通的 class 属性共存 123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt; 直接绑定数据里的一个对象 1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125; 数组语法 把一个数组传给 v-bind:class ，以应用一个 class 列表： 12345&lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 用三元表达式，据条件切换列表中的 class 1&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt; 条件渲染 v-if是“真正的”条件渲染，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换 区别：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好 vue时间处理器 用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码 v-on 可以接收一个定义的方法来调用，方法定义在methods事件修饰符 vue推荐methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节,当我们要调用 event.preventDefault() 或 event.stopPropagation(),就可以使用事件修饰符 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;div v-on:click.once=&apos;doThat&apos;&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。 关键修饰符 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 12&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt; Vue 为最常用的按键提供了别名 1234&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt; 全部的按键别名 123456789.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right vue的数据绑定 “Mustache” 语法（双大括号） 单向的数据绑定 v-model 双向数据绑定v-model可以添加修饰符 可以添加一个修饰符 lazy ,从而转变为在 change 事件中同步： 12&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; 将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值 1&lt;input v-model.number=&apos;age&apos; type=&apos;number&apos;&gt; 如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入： 1&lt;input v-model.trim=&quot;msg&quot;&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2017%2F06%2F23%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装hexo 第一步、执行npm install hexo-cli -g 安装hexo 第二步、找到你想写博客的文件夹，执行hexo init blog生成文件 第三步、在生成的文件blog中执行hexo server，访问http://localhost:4000/ 安装和配置Next主题 在hexo目录下右键Git bash通过命令git clone https://github.com/iissnan/hexo-theme-next themes/nextnext主题自动下载到themes目录下 在blog文件下的站点配置文件_config.yml,找到 theme 字段，并将其值更改为 nexttheme:next hexo s验证主题配置是否成功，浏览器输入 http://localhost:4000 hexo书写博客 在source文件夹的_posts里面,通过hexo new 博客标题命令生成markdown文件 文章写好后，执行hexo generate命令生成静态的html文件 发送博客到github上 我们把public里面的文件发布到github上面 在创建github仓库是取名一定要去[github用户名].github.io 例子:saber-tgb.github.io 用git发送到githoub是一定要发送到master分支 不用更改生成的博客html文件的css，js的路径 传上去后路径就会正确 next主题的配置和优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat:#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>应用工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信页面开发的注意事项]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[页面搜索框 为了保持和微信搜索一致，搜索框未点击时搜索图标在中间显示，点击搜索框后，搜索图标在左边 实现手机键盘显示搜索按钮&lt;form&gt;标签里面包含&lt;input type=search&gt;，&lt;form&gt;标签必须有action属性, 123456789&lt;form action=&quot;&quot; class=&quot;searchForm&quot; v-show=&quot;searchShow1&quot;&gt; &lt;input type=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;搜索&quot; class=&quot;search&quot; @focus=&quot;searchFocus&quot;&gt; &lt;i class=&quot;iconfont icon-sousuo icoImg&quot;&gt;&lt;/i&gt;&lt;/form&gt;&lt;form action=&quot;&quot; class=&quot;searchForm2&quot; v-show=&quot;searchShow2&quot;&gt; &lt;input type=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;搜索&quot; class=&quot;search&quot; v-model=&quot;keywords2&quot; @keydown=&quot;searchVk($event)&quot;&gt; &lt;i class=&quot;iconfont icon-sousuo icoImg&quot; @click=&quot;getVkBusList()&quot;&gt;&lt;/i&gt; &lt;span class=&quot;btn&quot; @click=&quot;cancelSearch&quot;&gt;取消&lt;/span&gt;&lt;/form&gt; vue绑定事件在&lt;input&gt;标签上,用监听键盘事件@keydown,要使用e.preventDefault()阻止默认事件触发。 页面1px边框显示问题 使用淘宝的flexible.js插件转化为1rem. 微信页面禁止缩放页面]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm,browser-sync,gulp工具的学习]]></title>
    <url>%2F2017%2F06%2F16%2Fnpm-browser-sync-gulp%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[npm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 删除指定包:npm remove jquery --save 卸载一般用 npm uninstall –save jquery 或者 npm remove –save jquery 下载安装package.json中dependencies属性对的文件:npm install --production npm的使用步骤 第一步、npm init创建一个文件夹（注意：不要用中文名,不能以数字开头，不能有空格） 第二步、执行npm init -y 第三步、安装需要的js库 npm install –save jquery browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev -dev安装在本地 之所以在全局安装了一次还有在项目中安装，是为了保证gulp的版本的控制，每次使用的时候重新安装能控制gulp的版本 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 得到gulp对象var gulp = require(&quot;gulp&quot;);//引入gulp-uglify插件 用来压缩jsvar uglify = require(&apos;gulp-uglify&apos;);//引入gulp-concat插件 用来合并代码 js,css都能合并var concat = require(&apos;gulp-concat&apos;);//引入gulp-cssnano插件 用来对css进行压缩var cssnano = require(&apos;gulp-cssnano&apos;);//引入gulp-htmlmin插件 用来对html代码进行压缩var htmlmin = require(&apos;gulp-htmlmin&apos;);//引入gulp-imagemin插件 对图片进行压缩var imagemin = require(&apos;gulp-imagemin&apos;);//引入gulp-spriter插件 合并成精灵图var spriter = require(&apos;gulp-spriter&apos;);&lt;!-- more --&gt;//创建js压缩任务gulp.task(&apos;script&apos;,function()&#123; // 这里写任务具体需要做的事情. // 2.匹配到app.js文件,如果使用多个规则，需要以数组的形式来书写第一个参数，数组中的每一个元素都是一个规则。 gulp.src([&apos;./app.js&apos;,&apos;./signIn.js&apos;]) //合并后生成的文件名 .pipe(concat(&apos;all.js&apos;)) //调用方法 压缩js .pipe(uglify()) //将合格的js文件 输出到指定目录 .pipe(gulp.dest(&apos;./dist&apos;))&#125;);//创建css压缩任务gulp.task(&apos;style&apos;,function()&#123; // 匹配css文件 gulp.src([&apos;./style.css&apos;,&apos;./signIn.css&apos;]) .pipe(concat(&apos;all.css&apos;)) // 需要指定一个名字，作为压缩后文件的文件名 .pipe(cssnano()) .pipe(gulp.dest(&apos;./dist&apos;))&#125;);//创建html压缩任务gulp.task(&apos;htmlmin&apos;,function()&#123; gulp.src(&apos;./index.html&apos;) .pipe(htmlmin(&#123; //collapseWhitespace:清除空格 collapseWhitespace:true, //collapseBooleanAttributes:省略布尔属性的值， collapseBooleanAttributes:true, //removeComments:清除html中注释的部分 removeComments:true, //removeEmptyAttributes:清除所有的空属性 removeEmptyAttributes:true, //removeSciptTypeAttributes:清除所有script标签中的type=&quot;text/javascript&quot;属性。 removeScriptTypeAttributes:true, //removeStyleLinkTypeAttributes:清楚所有Link标签上的type属性 removeStyleLinkTypeAttributes:true, //minifyJS:压缩html中的javascript代码。 minifyJS:true, //minifyCSS:压缩html中的css代码 minifyCSS:true &#125;)) .pipe(gulp.dest(&apos;./dist&apos;));&#125;);//创建合并压缩方法gulp.task(&apos;concat&apos;,function()&#123; // 匹配文件 gulp.src([&apos;./1.js&apos;,&apos;./2.js&apos;]) //调用合并方法 生成新的文件名 .pipe(concat(&apos;index.js&apos;)) //调用压缩方法 .pipe(uglify()) //输出到指定目录 .pipe(gulp.dest(&apos;./build&apos;));&#125;)//创建图片压缩方法gulp.task(&apos;imagemin&apos;,function()&#123; //引入图片地址方法 gulp.src(&apos;./images/*&apos;) //调用图片压缩 .pipe(imagemin()) //输出压缩后图片的存放地址 .pipe(gulp.dest(&apos;dist/images&apos;));&#125;);//创建合并精灵图任务gulp.task(&apos;spriter&apos;,function()&#123; return gulp.src(&apos;./style.css&apos;)//原始的css文件地址 //调用spriter精灵图合并方法 .pipe(spriter(&#123; sprite:&apos;test.png&apos;,//合并后图片的名字 slice:&apos;./slice&apos;,//原始小图片路径 outpath:&apos;build/tests&apos;//合并后的大图的地址 &#125;)) //合并精灵图后的css的文件地址 .pipe(gulp.dest(&apos;./build/css&apos;));&#125;)//创建监视任务gulp.task(&quot;watch&quot;,function()&#123; //调用watch方法 //第一个参数是监视目标文件,第二个参数是执行的任务 gulp.watch([&apos;./app.js&apos;,&apos;./signIn.js&apos;],[&quot;script&quot;]); &#125;) 调用方法直接在控制台输入gulp 任务名 gulp监视文件的改变 监视文件,当文件发生改变时,watch方法就会执行目标文件所绑定的事件 使用：在cmd命令窗口直接调用gulp myWatch方法 第一个参数是监视目标文件,第二个参数是执行的任务12345gulp.task(&quot;myWatch&quot;,function()&#123; gulp.watch([&quot;./a.html&quot;,&quot;./b.html&quot;],function()&#123; console.console.log() &#125;)&#125;) gup 结合browsr-sync使用12345678910111213141516//gulp结合browser-sync一起使用//当你改动html,css,js的时候 --&gt; 合并,压缩我们的html,js,css --&gt; browser-sync刷新浏览器//使用之前要在当前项目安装browser-sync 命令:npm install --save-dev browser-syncvar browserSync = require(&apos;browser-sync&apos;) //得到browserSync对象//创建browserSync任务gulp.task(&quot;browserSync&quot;,function()&#123; // 静态服务器 //第一步先用gulp监视index.html,如果有改动就会执行htmlmin这个任务 gulp.watch([&quot;./index.html&quot;],[&quot;htmlmin&quot;]); //第二步开启browserSyn,一旦html文件夹里面压缩的html有改动，就会刷新浏览器 browserSync(&#123; server:&#123; baseDir:&quot;./html&quot; //创建服务器的文件夹 &#125;, files:[&quot;./html/index.html&quot;] //同步的html代码 &#125;); &#125;) gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin 对图片进行压缩 gulp-imagemin 合并精灵图 gulp-spriter]]></content>
      <categories>
        <category>前端构建生态</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>browser-sync</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用]]></title>
    <url>%2F2017%2F06%2F16%2FGit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。 分布式，集中式版本管理工具 git属于分布式 svn集中式 git安装git初始化一个仓库 创建一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 对比文件差异 命令: git diff 用来比较暂存区文件内容与工作区文件内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 找到生成的ssh钥匙文件的地址：C盘/用户/用户名/.ssh/id_rsa.pub 找到公钥 在github右上角 –&gt; setting –&gt; ssh设置选项 把我们的公钥拷贝到github当中 以后push代码仓库的时候，使用ssh协议，也就是去使用git开头的那个链接 拉取github服务器上的代码及多人协作冲突处理 从服务器拉取代码的方式 方式一:’git clone git url’ 方式二:’git init’+ &apos;git pull url&apos; git pull和git clone这二种拉取方式的区别： 用git pull的话默认没有设置origin这个变量，必须自己手动设置(git remote add …..),而用了git clone则不需要了，默认origin这个变量就存在了 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 解决拒绝提交代码 执行git pull origin master 手动更改代码，解决冲突 执行:’git add’ 执行:’git commit 执行:’git pull origin master’ 执行:’git push origin master’ 如何避免尽量不会出现冲突？ 在每次push之前执行一次git pull git pull的作用： 更新本地仓库至最新改动，相当于先从远程服务器获取最新代码，接着进行自动合并(merge)，如果有冲突会提示你冲突，让你在本地手动解决掉冲突之后，再推送到服务器上面 多人共同使用同一个github服务器仓库 第一步、建立好一个github上面的仓库 第二步、点击setting 第三步、点击add collaborator，在里面找到你的小伙伴的用户名 第四步、生成一个邀请链接 第五步、把这个链接发给你的小伙伴，他同意之后就可以把自己写的代码提交到这个仓库了]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习]]></title>
    <url>%2F2017%2F06%2F05%2Fvuex%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[理解Vuex 运用Vue进行多组件开发时，多个组件间的数据通信和状态管理很难维护，使用Vuex将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了。 状态管理模式 vuex的状态自管理应用包含以下几个部分 state，驱动应用的数据源; view，以声明方式将state映射到视图； actions，响应在view上的用户输入导致的状态变化 State 每个应用将仅仅包含一个 store 实例,用来存储状态]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扎实基础JS一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80JS%E4%B8%80%2F</url>
    <content type="text"></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ECMAScript语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扎实基础CSS一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80CSS%E4%B8%80%2F</url>
    <content type="text"><![CDATA[文本超出显示省略号1234width: 300px //要设置宽度overflow: hidden;white-space: nowrap; text-overflow: ellipsis;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扎实基础HTML一]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%89%8E%E5%AE%9E%E5%9F%BA%E7%A1%80HTML%E4%B8%80%2F</url>
    <content type="text"><![CDATA[html5新增的音频和视频 音频audio&lt;audio src=&#39;&#39;&gt;&lt;/audio&gt; 视频video&lt;video src=&#39;&#39;&gt;&lt;/video&gt; html5语义化标签的使用 头部–header和nav标签 header头部，body下的直接子元素header一般用于放页面的介绍性的信息如网站名称、logo或者导航栏nav。12345678910&lt;header&gt; &lt;h1&gt;html5语义化标签&lt;/h1&gt; &lt;nav&gt; &lt;h1&gt;导航&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;章节标签&lt;/li&gt; &lt;li&gt;标题标签&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; 主体部分——main和section main标签表示页面的主体部份，section标签给页面区分不同的章节。section是一个章节标签，构建页面的大纲(outline)。除此外还有nav、artical和aside三个标签能够勾勒页面的轮廓。章节标签通常会带上h1~h6的标题标签。不同的章节标题是独立的，嵌套的章节标题也跟着嵌套。另外多个标题可以用hgroup包括起来，在页面提纲里成为独立的一条内容。 &lt;hgroup&gt;标签用于对网页或区段（section）的标题进行组合。12345678910111213141516 &lt;main&gt; &lt;section&gt; &lt;hgroup&gt; &lt;h2&gt;章节标签&lt;/h2&gt; &lt;p&gt;为页面区分不同的章节&lt;/p&gt; &lt;/hgroup&gt; &lt;div&gt;包括section article nav aside &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;hgroup&gt; &lt;h2&gt;标题标签&lt;/h2&gt; &lt;p&gt;为不同的章节定义标题&lt;/p&gt; &lt;/hgroup&gt; &lt;div&gt;h1 h2 h3 h4 h5 h6六个标题标签&lt;/div&gt; &lt;/section&gt;&lt;/main&gt; 尾部——footer footer和header一样，用在不同的章节里，可以显示该章节（如body整个页面）相关的外链、版权等信息。123&lt;footer&gt; &lt;p&gt;copyright &amp;copy hello, world&lt;/p&gt;&lt;/footer&gt; div和section、section和article的区别 div是一个普通的容器，而section不能当作一个普通的容器使用，使用section要让其起outline的作用，而article比section的章节概念更强。article适用于独立性强的内容，如本身就是一篇文章、博客，或者用户的评论等，article比section更加强调需要包含一个标题标签h1~h6。如果使用article的语义性更好的时候，就不用section。或者，内容可再继续细分章节的也应使用article。 章节的内容是独立的，并且可以嵌套 独立是指每个章节都可以有自己的标题标签、header、footer和nav，并且章节可以相互嵌套123456789101112131415&lt;body&gt; &lt;h1&gt;html标签&lt;/h1&gt; &lt;article&gt; &lt;h1&gt;html5标签&lt;/h1&gt; &lt;section&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;章节标签&lt;/h1&gt; &lt;/section&gt; &lt;/article&gt; &lt;article&gt; &lt;h1&gt;html4标签&lt;/h1&gt; &lt;/article&gt;&lt;/body&gt; 5 其它常用标签 figure用作照片及其注释的容器 1234&lt;figure&gt; &lt;img src=&quot;Mars.jpg&quot; alt=&quot;&quot;&gt; &lt;figcaption&gt;火星&lt;/figcaption&gt; &lt;/figure&gt; aside的内容与页面的主体内容相切，可用作侧边栏]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue脚手架vue-cli的学习一]]></title>
    <url>%2F2017%2F06%2F03%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[vue-cli的模板 vue-cli的脚手架项目模板有webpack-simple 和 webpack 两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能 vue-cli的项目结构1234567891011121314151617181920212223242526272829.|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico |-- index.html // 入口页面|-- package.json // 项目基本信息 package.json文件 package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。自定义npm相关命令 在package.json文件里有一个scripts字段。1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125; 在开发环境下，在命令行中运行npm run dev就相当于在执行node build/dev-server.js。所以script字段是用来指定npm相关命令的缩写的。 dependencies字段和devDependencies字段 dependencies字段指定了项目运行时所依赖的模块 devDependencies字段指定了项目开发时所依赖的模块(项目环境依赖) 在命令行中运行npm install命令，会自动安装dependencies和devDependencies字段中的模块。webpack配置相关 详情在webpack相关博客dev-server.js12345678910111213141516......// http-proxy可以实现转发所有请求代理到后端真实API地址，以实现前后端开发完全分离// 在config/index.js中可以对proxyTable想进行配置var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)......// 热加载要使用webpack-dev-middleware在没有webpack-dev-server的时候进行热加载var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)// 当html-webpack-plugin模板改变是强制进行页面重新加载compiler.plugin(&apos;compilation&apos;, function (compilation) &#123; compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) &#123; hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;) cb() &#125;)&#125;) webpack.base.conf.js123456789101112131415161718192021222324252627282930......module.export = &#123; // 编译入口文件 entry: &#123;&#125;, // 编译输出路径 output: &#123;&#125;, // 一些解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js文件用babel转码 &#123; test: /\.js$/, loader: &apos;babel&apos;, include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // vue文件一些相关配置 vue: &#123;&#125;&#125; check-version.js 这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。12345678910111213141516171819202122232425262728293031323334353637// 加载语义化版本测试库var semver = require(&apos;semver&apos;)// 定制控制台日志的输入样式var chalk = require(&apos;chalk&apos;)// 引入package.json文件var packageConfig = require(&apos;../package.json&apos;)var exec = function (cmd) &#123; return require(&apos;child_process&apos;) .execSync(cmd).toString().trim()&#125;// 定义node和npm版本需求所组成的数组var versionRequirements = [ &#123; name: &apos;node&apos;, currentVersion: semver.clean(process.version), versionRequirement: packageConfig.engines.node &#125;, &#123; name: &apos;npm&apos;, currentVersion: exec(&apos;npm --version&apos;), versionRequirement: packageConfig.engines.npm &#125;]module.exports = function () &#123; var warnings = [] // 依次判断版本是否符合要求 for (var i = 0; i &lt; versionRequirements.length; i++) &#123; var mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &apos;: &apos; + chalk.red(mod.currentVersion) + &apos; should be &apos; + chalk.green(mod.versionRequirement) ) &#125; &#125; ...&#125; .babelrc Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码12345// 设定转码规则&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],// 转码的一些插件&quot;plugins&quot;: [&quot;transform-runtime&quot;],&quot;comments&quot;: false .editorconfig 该文件定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要。123456789root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格 配置代理 在config/index.js文件中配置12345678910//配置代理proxyTable: &#123; &apos;/api/&apos;: &#123; target: &apos;http://localhost:3000&apos;, changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125; &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-cli</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios的使用]]></title>
    <url>%2F2017%2F05%2F24%2FAxios%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[axios 基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 功能特性 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 自动转换 JSON 数据 客户端支持保护安全免受 XSRF 攻击 默认配置 可以为每一个请求指定默认配置。 全局 axios 默认配置123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 自定义实例默认配置1234let axiosIns = axios.create(&#123; baseURL: &apos;https://api.example.com&apos;, timeout: 10 * 1000&#125;); 请求方法别名 axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 例子 发送一个 GET 请求 123456789101112131415161718192021// Make a request for a user with a given IDaxios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;);// Optionally the request above could also be done asaxios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送一个 POST 请求 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求 123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); axios API 可以通过给 axios传递对应的参数来定制请求：axios(config)12345678axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 请求配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; //用来向服务器发送请求的url地址 url: &apos;/user&apos;, //请求方法，默认是GET方法 method: &apos;get&apos;, //基础URL路径，假如url不是绝对路径，如 https://some-domain.com/api/v1/login?name=jack,那么向服务器发送请求的URL将会是baseURL + url baseURL: &apos;https://some-domain.com/api/&apos;, // transformRequest方法允许在请求发送到服务器之前修改该请求，此方法只适用于PUT、POST和PATCH方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。 transformRequest: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], //transformResponse方法允许在数据传递到then/catch之前修改response数据。此方法最后也要返回数据。 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // 发送自定义Headers头文件，头文件中包含了http请求的各种信息。 headers: &#123;&apos;Content-Type&apos;:&apos;application/json&apos;&#125;, // params是发送请求的查询参数对象，对象中的数据会被拼接成url?param1=value1&amp;param2=value2。 params: &#123; ID: 12345 &#125;, //params参数序列化器 paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, //data是在发送POST、PUT或者PATCH请求的数据对象。 data: &#123; firstName: &apos;Fred&apos; &#125;, //请求超时设置，单位为毫秒 timeout: 1000, //表明是否有跨域请求需要用到证书 withCredentials: false, // default //adapter允许用户处理更易于测试的请求。返回一个Promise和一个有效的response adapter: function (resolve, reject, config) &#123; /* ... */ &#125;, //auth表明提供凭证用于完成http的身份验证。这将会在headers中设置一个Authorization授权信息。自定义Authorization授权要设置在headers中。 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125; //表示服务器将返回响应的数据类型，有arraybuffer、blob、document、json、text、stream这6个类型，默认是json类似数据。 responseType: &apos;json&apos;, // default // 用作 xsrf token 值的 cookie 名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // 带有 xsrf token 值 http head 名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // 允许在上传过程中的做一些操作,允许在下载过程中的做一些操作 progress: function(progressEvent) &#123; // Do whatever you want with the native progress event &#125;&#125; 响应的数据结构12345678910111213141516&#123; // 服务器返回的数据 data: &#123;&#125;, // HTTP状态吗 status: 200, // 服务器返回的消息 statusText: &apos;OK&apos;, // 返回头 headers: &#123;&#125;, // 在返回我们的配置 config: &#123;&#125;&#125;]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router的API学习]]></title>
    <url>%2F2017%2F05%2F24%2FVue-router%E7%9A%84API%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&lt;router-link&gt; 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。自定义属性(props) to 表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。1234&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt; replace重定向 设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。1&lt;router-link :to=&quot;&#123; path: &apos;/abc&apos;&#125;&quot; replace&gt;&lt;/router-link&gt; append 设置 append 属性后，则在当前（相对）路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b tab 有时候想要 渲染成某种标签，例如 。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。123&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;li&gt;foo&lt;/li&gt; exact “是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 也会被设置 CSS 类名。 按照这个规则， 将会点亮各个路由！想要链接使用 “exact 匹配模式”，则使用 exact 属性：12&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt; events 声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。 active-class 设置 链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 将”激活时的CSS类名”应用在外层元素 有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 标签本身，那么可以用 渲染外层元素，包裹着内层的原生 标签： 123&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt; &lt;a&gt;/foo&lt;/a&gt;&lt;/router-link&gt; 在这种情况下， 将作为真实的链接（它会获得正确的 href 的），而 “激活时的CSS类名” 则设置到外层的 。 组件是一个 functional 组件，渲染路径匹配到的视图组件。 渲染的组件还可以内嵌自己的 ，根据嵌套路径，渲染嵌套组件。 属性 name 如果 设置了名称，则会渲染对应的路由配置中 components 下的相应组件。查看 命名视图 中的例子。 行为表现 其他属性（非 router-view 使用的属性）都直接传给渲染的组件， 很多时候，每个路由的数据都是包含在路由参数中。 因为它也是个组件，所以可以配合 和 使用。如果两个结合一起用，要确保在内层使用 ：12345&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 路由信息对象- 一个 route object（路由信息对象） 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的 route records（路由记录）。 - route object 是 immutable（不可变） 的，每次成功的导航后都会产生一个新的对象。 路由信息对象的属性- $route.path - 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 - $route.params - 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。 - $route.query - 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 - $route.hash - 当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 - $route.fullPath - 完成解析后的 URL，包含查询参数和 hash 的完整路径。 - $route.matched - 一个数组，包含当前路由的所有嵌套路径片段的 路由记录 。路由记录就是 routes 配置数组中的对象副本（还有在 children 数组）。 - 当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象（副本）。 - $route.name - 当前路由的名称，如果有的话]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router的使用一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-router%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80%2F</url>
    <content type="text"><![CDATA[vue-router的使用 javascript部分 1234567891011121314151617181920212223242526272829303132333435// 0. 使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;Vue.use(VueRouter)// 1. 定义（路由）组件。// 可以从其他文件 import 进来import Foo from &apos;@/page/login.vue&apos;import Bar from &apos;@/page/login.vue&apos;// 2. 定义路由// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: &apos;/foo&apos;, component: Foo &#125;, &#123; path: &apos;/bar&apos;, component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount(&apos;#app&apos;)// 现在，应用已经启动了！ html部分 12345678910111213141516&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; vue动态路由的设置 使用场景：例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』 1234567891011const User = &#123; template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: &apos;/user/:id&apos;, component: User &#125; ]&#125;)// /user/foo 和 /user/bar 都将映射到相同的路由 一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用. 1234// 我们可以更新 User 的模板，输出当前用户的 IDconst User = &#123; template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125; 响应路由参数的变化 当使用路由参数时，例如从 /user/foo 导航到 user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。 想对路由参数的变化作出响应的话，你可以简单地 watch（监测变化） $route 对象：12345678const User = &#123; template: &apos;...&apos;, watch: &#123; &apos;$route&apos; (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 路由匹配优先级 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 嵌套路由 使用children配置来设置嵌套路由 注意事项：以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。children 配置就是像 routes 配置一样的路由配置数组 1234567891011121314151617181920const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;profile&apos;, component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;posts&apos;, component: UserPosts &#125; ] &#125; ]&#125;) 基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: &apos;&apos;, component: UserHome &#125;, // ...其他子路由 ] &#125; ]&#125;) 用JS控制导航 router.push(location) 1声明式: &lt;router-link :to=&quot;...&quot;&gt; 编程式: router.push(...) 除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。 当你点击 &lt;router-link&gt; 时，这个方法会在内部调用，所以说，点击 &lt;router-link :to=&quot;...&quot;&gt; 等同于调用 router.push(…)。1234567891011// 字符串router.push(&apos;home&apos;)// 对象router.push(&#123; path: &apos;home&apos; &#125;)// 命名的路由router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;) router.replace(location) 它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录1声明式: &lt;router-link :to=&quot;...&quot; replace&gt; 编程式: router.replace(...) router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 命名路由 通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。123456789const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:userId&apos;, name: &apos;user&apos;, component: User &#125; ]&#125;) 命名视图 使用场景：同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。 123&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）： 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向 和 别名 重定向 重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b： 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: &apos;/b&apos; &#125; ]&#125;) 重定向的目标也可以是一个命名的路由 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125; ]&#125;) 甚至是一个方法，动态返回重定向目标： 12345678const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125;&#125; ]&#125;) 别名 /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125; ]&#125;) HTML5 History 模式 vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。1234const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;)]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router的使用一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-router%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[导航钩子 vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消。有多种方式可以在路由导航发生时执行钩子：全局的, 单个路由独享的, 或者组件级的 全局钩子 可以使用 router.beforeEach 注册一个全局的 before 钩子 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中 钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 某个路由独享的钩子1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内钩子123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当钩子执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; beforeRouteEnter 钩子 不能 访问 this，因为钩子在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 识别路由，为路由设置元信息 定义路由的时候配置meta字段来识别路由 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, children: [ &#123; path: &apos;bar&apos;, component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 访问meta字段来判断路由 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录 路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航钩子中的 route 对象）的 $route.matched 数组 通过遍历 $route.matched 来检查路由记录中的 meta字段,来识别路由12345678910111213141516 router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 123456789101112131415router.beforeEach((to,from,next) =&gt; &#123; //只有配置了meta字段的路由才会判断 if(to.meta.requireAuth) &#123; //判断是不是主代理商 if (authStatus==1) &#123; next(); &#125;else &#123; globStatus=true; next(&#123; path: &apos;/&apos;, &#125;) &#125; &#125;else &#123; next(); &#125; 滚动行为 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。注意: 这个功能只在 HTML5 history 模式下可用 当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法：scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。 如果返回一个布尔假的值，或者是一个空对象，那么不会发生滚动。返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：1234567scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125; 数据获取 导航完成之后获取 当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div class=&quot;post&quot;&gt; &lt;div class=&quot;loading&quot; v-if=&quot;loading&quot;&gt; Loading... &lt;/div&gt; &lt;div v-if=&quot;error&quot; class=&quot;error&quot;&gt; &#123;&#123; error &#125;&#125; &lt;/div&gt; &lt;div v-if=&quot;post&quot; class=&quot;content&quot;&gt; &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; loading: false, post: null, error: null &#125; &#125;, created () &#123; // 组件创建完后获取数据， // 此时 data 已经被 observed 了 this.fetchData() &#125;, watch: &#123; // 如果路由有变化，会再次执行该方法 &apos;$route&apos;: &apos;fetchData&apos; &#125;, methods: &#123; fetchData () &#123; this.error = this.post = null this.loading = true // replace getPost with your data fetching util / API wrapper getPost(this.$route.params.id, (err, post) =&gt; &#123; this.loading = false if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125;) &#125; &#125;&#125; 导航完成之前获取 通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 beforeRouteEnter 钩子中获取数据，当数据获取成功后只调用 next 方法。12345678910111213141516171819202122232425262728293031323334export default &#123; data () &#123; return &#123; post: null, error: null &#125; &#125;, beforeRouteEnter (to, from, next) &#123; getPost(to.params.id, (err, post) =&gt; if (err) &#123; // display some global error message next(false) &#125; else &#123; next(vm =&gt; &#123; vm.post = post &#125;) &#125; &#125;) &#125;, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 watch: &#123; $route () &#123; this.post = null getPost(this.$route.params.id, (err, post) =&gt; &#123; if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习一]]></title>
    <url>%2F2017%2F05%2F24%2FVue-js%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[VueJs的单文件组件 vuejs 自定义了一种.vue文件，可以把html, css, js 写到一个文件中，从而实现了对一个组件的封装， 一个.vue 文件就是一个单独的组件。 .vue文件是自定义的，浏览器不认识，所以需要对该文件进行解析，在webpack构建中，需要安装vue-loader 对.vue文件进行解析。 好处：项目更易于维护，代码模块化清晰明了，能够使用构建工具开发更有效率 生产环境的部署 使用vue的脚手架vue-cli来配置 vue的过滤器 过滤器可以用在mustache 插值和 v-bind 表达式即: 12&#123;&#123;message | capitalize&#125;&#125;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 过滤器方法注册在filters函数中 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; vue的计算属性 计算属性方法写在computed函数中12345678data: &#123; message: &apos;Hello&apos; &#125;,computed: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; &#125;, vue基本指令 v-for vue的迭代渲染数据必须使用特定语法item in items 可以为数组索引指定别名(或者用于对象的键)(item, index) in items vueJs推荐提供一个 key 的特殊属性来做提示,以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key 属性v-for=&quot;item in items&quot; :key=&quot;item.id&quot; v-show v-show 是简单地切换元素的 CSS 属性 display,用来显示或者隐藏元素 v-show 必须提供布尔值，不支持 &lt;template&gt; 语法，也不支持 v-else。 v-if 根据表达式的值的真假条件渲染元素 v-else-if 前一兄弟元素必须有 v-if 或 v-else-if v-else 不需要表达式 前一兄弟元素必须有 v-if 或 v-else-if v-text 绑定数据，只能渲染成文本格式&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; v-html 绑定输出真正的HTML格式&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt; v-bind 为元素动态地绑定一个或多个特性，或一个组件 prop 到表达式。 v-bind缩写：例&lt;img v-bind:src=&quot;imageSrc&quot;&gt;等同&lt;img :src=&quot;imageSrc&quot;&gt; class和style的动态绑定 &lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;类active是否起作用取决于属性isActive 是否为真值,isActive必须是布尔值 可以在对象中传入更多属性用来动态切换多个 class v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError } 数组语法v-bind:class=&quot;[{ active: isActive }, errorClass] 绑定内联样式：&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&quot;&gt;&lt;/div&gt; 绑定到一个样式对象：1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0——从环境搭建到发布]]></title>
    <url>%2F2017%2F05%2F23%2FVue2-0%E2%80%94%E2%80%94%E4%BB%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%88%B0%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Vue开发环境的配置 安装Nodejsnpm install nodejs 安装webpacknpm install webpack 安装vue脚手架npm install vue-cli -g 用vue-cli创建模板 vue-cli的模板分为两套 精简版：vue init webpack-simple 工程名字 常规版：vue init webpack 工程名字 初始化设置根据需求来设定，多人开发时开启Project name (vue-test)(语法检测)安装项目依赖 npm install 有可能安装速度会很慢可以使用cnpm 安装淘宝镜像npm install -g cnpm项目启动 cd进入项目中npm run devVue项目组件的使用 组件放在工程目录/src下创建component文件夹,组件都在这个目录下创建使用 组件的使用 引入：import firstcomponent from &#39;./component/firstcomponent.vue 注册：data 代码块后面加上components: { firstcomponent } 使用：在&lt;template&gt;&lt;/template&gt;内加上&lt;firstcomponent&gt;&lt;/firstcomponent&gt; Vue路由 安装vue-routernpm install vue-router --save 在man.js中导入路由模块import VueRouter from &#39;vue-router&#39; 使用：Vue.use(VueRouter) 挂载：new Vue({ el: &#39;#app&#39;, router, template: &#39;&lt;App/&gt;&#39;, components: { App } }) 配置项目路由 在router文件夹的index.js文件中配置 导入路由模块import Router from &#39;vue-router&#39; 引入页面模块:import login from &#39;@/page/login.vue&#39; 路由的配置：export default new Router({ routes: [{path: &apos;/login&apos;,name:&apos;登录&apos;,component:login} ]}) 路由的使用：在视图标签中webpack的配置 在config文件夹下的index.js中改变文件打包后指定到的文件夹 index: path.resolve(__dirname, &#39;../../webapp/index.html&#39;), assetsRoot: path.resolve(__dirname, &#39;../../webapp&#39;), assetsSubDirectory: &#39;static&#39;, assetsPublicPath: &#39;/&#39;,-dev: { port:8888}改变文件的端口号#文件打包 npm run build]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-cli</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
</search>
